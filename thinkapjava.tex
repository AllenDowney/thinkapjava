% LaTeX source for ``Think Java: How to think like a computer scientist''
% Copyright (C) 2011  Allen B. Downey

% Permission is granted to copy, distribute, transmit and adapt
% this work under a Creative Commons 
% Attribution-NonCommercial-ShareAlike 3.0 Unported License:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

% If you are interested in distributing a commercial version of this
% work, please contact Allen B. Downey.

% The original form of this book is LaTeX source code.  Compiling this
% LaTeX source has the effect of generating a device-independent
% representation of the book, which can be converted to other formats
% and printed.

% The LaTeX source for this book is available from http://thinkapjava.com
% and http://code.google.com/p/thinkapjava/source/checkout

% This book was typeset using LaTeX .  The illustrations were
% drawn in xfig.  All of these are free, open-source programs.

%%----------------------------------------------------------------

% How to compile this document:
% If your environment provides latex, makeindex, and dvips,
% the following commands should produce a Postscript version
% of the book.

%        latex book
%        makeindex book
%        latex book
%        dvips -o book.ps book

% You will also need the following (fairly standard) latex
% packages: url, epsfig, makeidx, fancyhdr

% This distribution also includes a Makefile that should
% compile both the Postscript and PDF versions of the book.

%%-----------------------------------------------------------------

\documentclass{book}
\usepackage{epsfig}
\usepackage{makeidx}
\usepackage{url}
\usepackage{fancyhdr}


% the exercise environment

\newcounter{exercisenum}                                                  
     
% by default, the exercise number includes the chapter number             
% this way, an exercise label is a complete, unique exercise id           
     
\renewcommand{\theexercisenum}{{\thechapter}.\arabic{exercisenum}}  

% Standard font size for exercise/problem text                            

\newenvironment{exercisesize}{\begin{small}}{\end{small}}                 

\newcommand{\exerciseheader}[2]{                                          
     
  \begin{exercisesize}                                                    
     
  % Use alphabetic chars for subparts of exercises,                            
  % and roman numerals for subparts of them.
     
  \def\theenumi{\alph{enumi}}                                             
  \def\labelenumi{\theenumi.}                                             
  \def\theenumii{\roman{enumii}}                                          
  \def\labelenumii{\theenumii.}                                           
  {\bf Exercise {#1}{#2}}\hspace{0.1in}                 
}                                                                         

\newcommand{\startexercise}[1]{%
  \refstepcounter{exercisenum}                                            
  \exerciseheader{\theexercisenum}{#1}                                    
}                                                                         

\newcommand{\stopexercise}{%                                                   
  {\hfill}                                                               
  \end{exercisesize}      
}                                                         
     
\newcommand{\normaldif}{}                                                 
     
\newcommand{\bigdif}{\dag{}}                                              
     
\newcommand{\verybigdif}{\ddag{}}             

\newenvironment{exercise}{\startexercise{\normaldif{}}}{\stopexercise}    
     
\newenvironment{hardexercise}{\startexercise{\bigdif{}}}{\stopexercise}   
     
%% end of the exercise environment


%%------------------------------------------------------------
% formatting commands

\sloppy
\setlength{\topmargin}{0.125in}
\setlength{\oddsidemargin}{0.875in}
\setlength{\evensidemargin}{0.875in}

\setlength{\headsep}{3ex}
\setlength{\textheight}{8in}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{1.7ex plus 0.5ex minus 0.5ex}
\renewcommand{\baselinestretch}{1.02}

% see LaTeX Companion page 62
\setlength{\topsep}{-0.0\parskip}
\setlength{\partopsep}{-0.5\parskip}
\setlength{\itemindent}{0.0in}
\setlength{\listparindent}{0.0in}

% see LaTeX Companion page 26
% these are copied from /usr/local/teTeX/share/texmf/tex/latex/base/book.cls
% all I changed is afterskip

\makeatletter
\renewcommand{\section}{\@startsection 
    {section} {1} {0mm}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection {subsection}{2}{0mm}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection {subsubsection}{3}{0mm}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}

\makeatother

\newcommand{\beforeverb}{\vspace{0.6\parskip}}
\newcommand{\afterverb}{\vspace{0.6\parskip}}

\newcommand{\adjustpage}[1]{\enlargethispage{#1\baselineskip}}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\newcommand{\blankpage}{\pagestyle{empty}\vspace*{1in}\newpage}

\newcommand{\beforefig}{\vspace{1.3\parskip}}
\newcommand{\afterfig}{\vspace{-0.2\parskip}}
\newcommand{\myfig}[1]{
    \beforefig
    \centerline{\epsfig{#1,scale=0.8}}
    \afterfig
}

\newcommand{\beforechapter}{
%    \clearemptydoublepage 
    \cleardoublepage 
    \setcounter{exercisenum}{0}
}

\pagestyle{fancyplain}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}{}}

\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}

% turn off the rule under the header
%\setlength{\headrulewidth}{0pt}

% the following is a brute-force way to prevent the headers
% from getting transformed into all-caps
\renewcommand\MakeUppercase{}


%%-----------------------------------------------------------
% beginning of the document


\title{Think Java: How to Think Like a Computer Scientist}

\author{Allen B. Downey}

\makeindex

\begin{document}

\frontmatter


%-half title--------------------------------------------------


\thispagestyle{empty}

\begin{flushright}
\vspace*{2.5in}

{\huge Think Java}

\vspace{1in}

{\LARGE How to Think Like a Computer Scientist}

\vfill

\end{flushright}

%--verso------------------------------------------------------

%\clearemptydoublepage
\cleardoublepage

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.5in}

{\huge Think Java}

\vspace{0.25in}

{\LARGE How to Think Like a Computer Scientist}

\vspace{1in}

{\Large
Allen B. Downey
}


\vspace{1in}

{\Large Version 5.0}

\vfill

\end{flushright}


%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Copyright \copyright ~2011 Allen Downey.

\vspace{0.25in}

Permission is granted to copy, distribute, transmit and adapt
this work under a Creative Commons 
Attribution-NonCommercial-ShareAlike 3.0 Unported License:
\url{http://creativecommons.org/licenses/by-nc-sa/3.0/}.

If you are interested in distributing a commercial version of this
work, please contact Allen B. Downey.

The original form of this book is \LaTeX\ source code.  Compiling this
\LaTeX\ source has the effect of generating a device-independent
representation of the book, which can be converted to other formats
and printed.

The \LaTeX\ source for this book is available from

\begin{verbatim}
      thinkapjava.com
\end{verbatim}

This book was typeset using \LaTeX .  The illustrations were
drawn in xfig.  All of these are free, open-source programs.

\vspace{0.25in}


%-----------------------------------------------------------------

\chapter{Preface}

\begin{quote}
``As we enjoy great Advantages from the Inventions of others,
we should be glad of an Opportunity to serve others by any
Invention of ours, and this we should do freely and generously.''

---Benjamin Franklin, quoted in {\em Benjamin Franklin} by
Edmund S. Morgan.
\end{quote}

\subsection* {Why I wrote this book}

This is the fifth edition of a book I started writing in 1999,
when I was teaching at Colby College.  I had taught an introductory
computer science class using the Java programming language, but I
had not found a textbook I was happy with.  For one thing,
they were all too big!  There was no way my students would read
800 pages of dense, technical material, even if I wanted them to.
And I didn't want them to.  Most of the material was too
specific---details about Java and its libraries that would be obsolete
by the end of the semester, and that obscured the material I really
wanted to get to.

The other problem I found was that the introduction to object
oriented programming was too abrupt.  Many students who were otherwise
doing well just hit a wall when we got to objects, whether we did
it at the beginning, middle or end.

So I started writing.  I wrote a chapter a day for 13 days, and on
the 14th day I edited.  Then I sent it to be photocopied and bound.
When I handed it out on the first day of class, I told the students
that they would be expected to read one chapter a week.  In other
words, they would read it seven times slower than I wrote it.


\subsection*{The philosophy behind it}

Here are some of the ideas that make the book the way it is:

\begin{itemize}

\item Vocabulary is important.  Students need to be able to talk
about programs and understand what I am saying.  I try to
introduce the minimum number of terms, to define them carefully 
when they are first used, and to organize them in glossaries
at the end of each chapter.  In my class, I include vocabulary
questions on quizzes and exams, and require students to use
appropriate terms in short-answer responses.

\item In order to write a program, students have to understand the
algorithm, know the programming language, and they have to be
able to debug.  I think too many books neglect debugging.  This
book includes an appendix on debugging and an appendix on program
development (which can help avoid debugging).  I recommend that
students read this material early and come back to it often.

\item Some concepts take time to sink in.  Some of the more
difficult ideas in the book, like recursion, appear several times.
By coming back to these ideas, I am trying to give students a
chance to review and reinforce or, if they missed it the first time,
a chance to catch up.

\item I try to use the minimum amount of Java to get the
maximum amount of programming power.  The purpose of this book
is to teach programming and some introductory ideas from computer
science, not Java.  I left out some language features, like
the {\tt switch} statement, that are unnecessary, and avoided
most of the libraries, especially the ones like the AWT that have been
changing quickly or are likely to be replaced.

\end{itemize}

The minimalism of my approach has some advantages.
Each chapter is about ten pages, not including the exercises.
In my classes I ask students to read each chapter before we
discuss it, and I have found that they are willing to do that
and their comprehension is good.  Their preparation makes
class time available for discussion of the more abstract material,
in-class exercises, and additional topics that aren't in the
book.

But minimalism has some disadvantages.  There is not much here
that is intrinsically fun.  Most of my examples demonstrate the
most basic use of a language feature, and many of the exercises
involve string manipulation and mathematical ideas.  I think some
of them are fun, but many of the things that excite students
about computer science, like graphics, sound and network applications,
are given short shrift.

The problem is that many of the more exciting features involve
lots of details and not much concept.  Pedagogically, that means
a lot of effort for not much payoff.  So there is a tradeoff between
the material that students enjoy and the material that is most
intellectually rich.  I leave it to individual teachers to find
the balance that is best for their classes.  To help, the book
includes appendices that cover graphics, keyboard input and
file input.

\subsection*{Object-oriented programming}

Some books introduce objects immediately;
others warm up with a more procedural style and develop
object-oriented style more gradually.  This book is probably
the extreme of the ``objects late'' approach.

Many of Java's object-oriented features are motivated
by problems with previous languages, and their implementations
are influenced by this history.  Some of these features are
hard to explain if students aren't familiar with the problems
they solve.

It wasn't my intention to postpone object-oriented programming.
On the contrary, I got to it as quickly as I could, limited by
my intention to introduce concepts one at a time, as clearly
as possible, in a way that allows students to practice each
idea in isolation before adding the next.  It just happens
that it takes 13 steps.

\subsection* {The Computer Science AP Exam}

During Summer 2001 I worked with teachers at the Maine School of
Science and Mathematics on a version of the book that would help
students prepare for the Computer Science Advanced Placement Exam,
which used C++ at the time.  The translation went quickly because,
as it turned out, the material I covered was almost identical to
the AP Syllabus.

Naturally, when the College Board announced that the AP Exam
would switch to Java, I made plans to update the Java version of
the book.  Looking at the proposed AP Syllabus, I saw that their
subset of Java was all but identical to the subset I had chosen.

During January 2003, I worked on the Fourth Edition of the book,
making these changes:

\begin{itemize}

\item I added a new chapter covering Huffman codes.

\item I revised several sections that I had found problematic,
including the transition to object-oriented programming and the
discussion of heaps.

\item I improved the appendices on debugging and program development.

\item I added a few sections to improve coverage of the AP syllabus.

\item I collected the exercises, quizzes, and exam questions I
had used in my classes and put them at the end of the appropriate
chapters.  I also made up some problems that are intended to
help with AP Exam preparation.

\end{itemize}


\subsection* {Free books!}

Since the beginning, this book and its descendents have been available
under licenses that allow users to copy, distribute and modify the
book.  Readers can download the book in a variety of formats
and print it or read it on screen.  Teachers are free to send the book
to a short-run printer and make as many copies as they need.  And,
maybe most importantly, anyone is free to customize the book for their
needs.  You can download the \LaTeX\ source code, and then add,
remove, edit, or rearrange material, and make the book that is best
for you or your class.

People have translated the book into other computer languages
(including Python and Eiffel), and other natural languages (including
Spanish, French and German).  Many of these derivatives are also
available under free licenses.

This approach to publishing has a lot of advantages, but there is
one drawback: my books have never been through a formal editing and
proofreading process and sometimes it shows.  Motivated by Open
Source Software, I have adopted the philosophy of releasing the
book early and updating it often.  I do my best to minimize the
number of errors, but I also depend on readers to help out.

The response has been great.  I get messages almost every day from
people who have read the book and liked it enough to take the trouble
to send in a ``bug report.''  Often I can correct an error
and post an updated version almost immediately.  I think of the
book as a work in progress, improving a little whenever I have time
to make a revision, or when readers take the time to send feedback.

\subsection* {Oh, the title}

I get a lot of grief about the title of the book.  Not everyone
understands that it is---mostly---a joke.
Reading this book will probably not make you think like a computer
scientist.  That takes time, experience, and probably a few more
classes.

But there is a kernel of truth in the title: this book is not
about Java, and it is only partly about programming.  If it is
successful, this book is about a way of thinking.  Computer scientists
have an approach to problem-solving, and a way of crafting solutions,
that is unique, versatile and powerful.  I hope that this book
gives you a sense of what that approach is, and that at some
point you will find yourself thinking like a computer scientist.

\vspace{0.2in}

\begin{flushleft}
Allen Downey\\
Needham, Massachusetts\\
July 13, 2011
\end{flushleft}


\section*{Contributors List}

When I started writing free books, it didn't occur to me to keep
a contributors list.  When Jeff Elkner suggested it, it seemed so
obvious that I am embarassed by the omission.  This list starts
with the 4th Edition, so it omits many people who contributed
suggestions and corrections to earlier versions.

\begin{itemize}

\item Ellen Hildreth used this book to teach Data Structures at
Wellesley College, and she gave me a whole stack of corrections,
along with some great suggestions.

\item Tania Passfield pointed out that the glossary of Chapter 4
has some leftover terms that no longer appear in the text.

\item Elizabeth Wiethoff noticed that my series expansion of
$e^{-x^2}$ was wrong.  She is also working on a Ruby version of
the book!

\item Matt Crawford sent in a whole patch file full of corrections!

\item Chi-Yu Li pointed out a typo and an error in one of the code
examples.

\item Doan Thanh Nam corrected an example in Chapter 3.

\end{itemize}



% The following lines add a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother
\setcounter{tocdepth}{1}

\tableofcontents

\mainmatter

\beforechapter
\chapter{The way of the program}
\label{chap01}

The goal of this book is to teach you to think like a
computer scientist.  I like the way computer scientists think because
they combine some of the best features of Mathematics, Engineering,
and Natural Science.  Like mathematicians, computer scientists use formal
languages to denote ideas (specifically computations).  Like
engineers, they design things, assembling components into systems and
evaluating tradeoffs among alternatives.  Like scientists,
they observe the behavior of complex systems, form hypotheses, and test
predictions.

The single most important skill for a computer scientist is {\bf
problem-solving}.  By that I mean the ability to formulate problems,
think creatively about solutions, and express a solution clearly and
accurately.  As it turns out, the process of learning to program is an
excellent opportunity to practice problem-solving skills.  That's why
this chapter is called ``The way of the program.''

On one level, you will be learning to program, which is a useful
skill by itself.  On another level you will use programming
as a means to an end.  As we go along, that end will
become clearer.

\section{What is a programming language?}
\index{programming language}
\index{language!programming}

The programming language you will be learning is Java, which is
relatively new (Sun released the first version in May, 1995).  Java is
an example of a {\bf high-level language}; other high-level languages
you might have heard of are Python, C or C++, and Perl.

As you might infer from the name ``high-level language,'' there are
also {\bf low-level languages}, sometimes called machine
language or assembly language.  Loosely-speaking, computers can only
run programs written in low-level languages.  Thus, programs
written in a high-level language have to be translated before they can
run.  This translation takes time, which is a small disadvantage
of high-level languages.

\index{portable}
\index{high-level language}
\index{low-level language}
\index{language!high-level}
\index{language!low-level}

The advantages are enormous.  First,
it is {\em much} easier to program in a high-level language:
the program takes less time to write,
it's shorter and easier to read, and it's more likely to be
correct.  Second, high-level languages are {\bf portable},
meaning that they can run on different kinds of computers with
few or no modifications.  Low-level programs can only run
on one kind of computer, and have to be rewritten to run on
another.

Due to these advantages, almost all programs are written in
high-level languages.  Low-level languages are only used for
a few special applications.

\index{compile}
\index{interpret}

There are two ways to translate a program;
{\bf interpreting} and {\bf compiling}.  An interpreter
is a program that reads a high-level program
and does what it says.  In effect, it translates
the program line-by-line, alternately reading lines and
carrying out commands.

A compiler is a program that reads a high-level program and
translates it all at once, before running any of the commands.
Often you compile the program as a separate step, and then
run the compiled code later.  In this case, the high-level
program is called the {\bf source code}, and the translated
program is called the {\bf object code} or the {\bf executable}.

The Java language is unusual because it is both compiled and
interpreted.  Instead of translating Java programs into
machine language, the Java compiler generates Java byte code.
Byte code is easy (and fast) to interpret, like machine language,
but it is also portable, like a high-level language.  Thus,
it is possible to compile a Java program on one machine,
transfer the byte code to another machine,
and then interpret the byte code on the other machine.  This
ability is an advantage of Java over many other
high-level languages.


\myfig{figure=figs/java.eps}


Although this process may seem complicated, in most program
development environments these steps
are automated for you.  Usually you will only have to write a program
and press a button or type a single command to compile and run it.  On
the other hand, it is useful to know what steps are
happening in the background, so if something goes wrong you can
figure out what it is.



\section{What is a program?}

A program is a sequence of instructions that specifies how to perform
a computation\footnote{This definition does not apply to all
  programming languages; for alternatives, see
  \url{http://en.wikipedia.org/wiki/Declarative_programming}.}.  The
computation might be something mathematical, like solving a system of
equations or finding the roots of a polynomial, but it can also be a
symbolic computation, like searching and replacing text in a document
or (strangely enough) compiling a program.

\index{statement}

The instructions, which we will call {\bf statements}, look different
in different programming languages, but there are a few basic
operations most languages perform:

\begin{description}

\item[input:] Get data from the keyboard, or a file, or some
other device.

\item[output:] Display data on the screen or send data to a
file or other device.

\item[math:] Perform basic mathematical operations like addition and
multiplication.

\item[testing:] Check for certain conditions and run the
appropriate sequence of statements.

\item[repetition:] Perform some action repeatedly, usually with
some variation.

\end{description}

That's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is
made up of statements that perform these operations.  Thus,
one way to describe programming is the process of breaking a
large, complex task up into smaller and smaller subtasks
until the subtasks are simple enough to be performed
with one of these basic operations.


\section{What is debugging?}
\index{debugging}
\index{bug}

For whimsical reasons,
programming errors are called {\bf bugs} and the process
of tracking them down and correcting them is called
{\bf debugging}.

There are a three kinds of errors that can occur
in a program, and it is useful to distinguish them
to track them down more quickly.

\subsection{Syntax errors}
\index{syntax error}
\index{error!syntax}

The compiler can only translate a program if the program is
syntactically correct; otherwise, the compilation fails and
you will not be able to run your program.  {\bf Syntax}
refers to the structure of your program and the rules about
that structure.
\index{syntax}

For example, in English, a sentence must begin with a capital
letter and end with a period.  this sentence contains a syntax
error.  So does this one

For most readers, a few syntax errors are not a significant
problem, which is why we can read the poetry of e e cummings
without spewing error messages.

Compilers are not so forgiving.  If there is a single syntax
error anywhere in your program, the compiler will print an
error message and quit, and you will not be able to run
your program.

To make matters worse, there are more syntax rules in Java
than there are in English, and the error messages you get from
the compiler are often not very helpful.  During the first
weeks of your programming career, you will probably
spend a lot of time tracking down syntax errors.  As you
gain experience, you will make fewer errors and find
them faster.

\subsection{Run-time errors}
\label{run-time}
\index{run-time error}
\index{error!run-time}
\index{exception}
\index{safe language}
\index{language!safe}

The second type of error is a run-time error, so-called because
the error does not appear until you run the program.  In Java,
run-time errors occur when the interpreter is running the byte
code and something goes wrong.

Java tends to be a {\bf safe}
language, which means that the compiler catches a lot of errors.
So run-time errors are rare, especially
for simple programs.

In Java, run-time errors are called {\bf exceptions},
and in most environments they appear as windows or dialog
boxes that contain information about what happened and what
the program was doing when it happened.  This information is
useful for debugging.

\subsection{Logic errors and semantics}
\index{semantics}
\index{logic error}
\index{error!logic}

The third type of error is the {\bf logic} or {\bf semantic} error.
If there is a logic error in your program, it will compile and run
without generating error messages, but it will not do the right thing.
It will do something else.  Specifically, it will do what you told it
to do.

The problem is that the program you wrote is not the program you
wanted to write.  The semantics, or meaning of the program, are wrong.
Identifying logic errors can be tricky because you have to work
backwards, looking at the output of the program and trying to figure
out what it is doing.

\subsection{Experimental debugging}

One of the most important skills you will acquire in this
class is debugging.  Although debugging can be frustrating, it
is one of the most interesting, challenging, and
valuable parts of programming.

Debugging is like detective work.  You are
confronted with clues and you have to infer the processes
and events that lead to the results you see.

Debugging is also like an experimental science.  Once you have an idea
what is going wrong, you modify your program and try again.  If your
hypothesis was correct, then you can predict the result of the
modification, and you take a step closer to a working program.  If
your hypothesis was wrong, you have to come up with a new one.  As
Sherlock Holmes pointed out, ``When you have eliminated the
impossible, whatever remains, however improbable, must be the truth.''
(from A. Conan Doyle's {\em The Sign of Four}).

\index{Holmes, Sherlock}
\index{Doyle, Arthur Conan}

For some people, programming and debugging are the
same thing.  That is, programming is the process of gradually
debugging a program until it does what you want.  The idea
is that you should always start with a working program that
does {\em something}, and make small modifications, debugging
them as you go, so that you always have a working program.

For example, Linux is an operating system that contains thousands of
lines of code, but it started out as a simple program Linus Torvalds
used to explore the Intel 80386 chip.  According to Larry Greenfield,
``One of Linus's earlier projects was a program that would switch
between printing AAAA and BBBB.  This later evolved to Linux''
(from {\em The Linux Users' Guide} Beta Version 1).

\index{Linux}
\index{Torvalds, Linux}
\index{Greenfield, Larry}

In later chapters I will make more suggestions about debugging
and other programming practices.

\section{Formal and natural languages}
\index{formal language}
\index{natural language}
\index{language!formal}
\index{language!natural}

{\bf Natural languages} are the languages that people speak,
like English, Spanish, and French.  They were not designed
by people (although people try to impose order on them);
they evolved naturally.

{\bf Formal languages} are languages designed by people for
specific applications.  For example, the notation that mathematicians
use is a formal language that is particularly good at denoting
relationships among numbers and symbols.  Chemists use a formal
language to represent the chemical structure of molecules.  And
most importantly:

\begin{quote}
{\bf Programming languages are formal languages that have been
designed to express computations.}
\end{quote}

Formal languages have strict rules
about syntax.  For example, $3+3=6$ is a syntactically correct
mathematical statement, but $3 \$ =$ is not.  Also, $H_2O$ is a
syntactically correct chemical name, but $_2Zz$ is not.

Syntax rules come in two flavors, pertaining to tokens and structure.
Tokens are the basic elements of the language, like words and numbers
and chemical elements.  One of the problems with $3 \$ =$ is that
$\$$ is not a legal token in mathematics (at least as far as I
know).  Similarly, $_2Zz$ is not legal because there is no element with
the abbreviation $Zz$.

The second type of syntax rule pertains to the structure of a
statement; that is, the way the tokens are arranged.  The statement
$3 \$ =$ is structurally illegal, because you can't have an equals
sign at the end of an equation.  Similarly, molecular formulas
have to have subscripts after the element name, not before.

When you read a sentence in English or a statement in a formal
language, you have to figure out what the structure of the sentence is
(although in a natural language you do this unconsciously).  This
process is called {\bf parsing}.

\index{parse}

Although formal and natural languages have features in
common---tokens, structure, syntax and semantics---there are
differences.

\index{ambiguity}
\index{redundancy}
\index{literalness}

\begin{description}

\item[ambiguity:] Natural languages are full of ambiguity, which
  people deal with by using contextual clues and other information.
  Formal languages are designed to be unambiguous, which means that
  any statement has exactly one meaning, regardless of context.

\item[redundancy:] To make up for ambiguity and reduce
  misunderstandings, natural languages are often redundant.  Formal
  languages are more concise.

\item[literalness:] Natural languages are full of idiom and
metaphor.  Formal languages mean exactly what they say.

\end{description}

People who grow up speaking a natural language (everyone) often have a
hard time adjusting to formal languages.  In some ways the difference
between formal and natural language is like the difference between
poetry and prose, but more so:

\index{poetry}
\index{prose}

\begin{description}

\item[Poetry:] Words are used for their sounds as well as for
their meaning, and the whole poem together creates an effect or
emotional response.  Ambiguity is common and deliberate.

\item[Prose:] The literal meaning of words is more important
and the structure contributes more meaning.

\item[Programs:] The meaning of a computer program is unambiguous
and literal, and can be understood entirely by analysis of the
tokens and structure.

\end{description}

Here are some suggestions for reading programs (and other formal
languages).  First, remember that formal languages are much more dense
than natural languages, so it takes longer to read them.  Also, the
structure is important, so it is usually not a good idea to read
from top to bottom, left to right.  Instead, learn to parse the
program in your head, identifying the tokens and interpreting the
structure.  Finally, remember that the details matter.  Little things
like spelling errors and bad punctuation, which you can get away
with in natural languages, can make a big difference in a formal
language.

\section{The first program}
\label{hello}
\index{hello world}

Traditionally the first program people write in a new language
is called ``Hello, World.'' because all it does is display the
words ``Hello, World.''  In Java, this program looks like this:

\begin{verbatim}
class Hello {

  // main: generate some simple output

  public static void main(String[] args) {
    System.out.println("Hello, world.");
  }
}
\end{verbatim}
%
This program includes features that are hard to explain to
beginners, but it provides a preview of topics we
will see in detail later.

Java programs are made up of {\bf class definitions}, which have
the form:

\index{class definition}
\index{definition!class}

\begin{verbatim}
class CLASSNAME {

  public static void main (String[] args) {
    STATEMENTS
  }
}
\end{verbatim}
%
Here {\tt CLASSNAME} indicates a name chosen by the programmer.
The class name in the example is {\tt Hello}.

\index{class!name}
\index{public}
\index{static}

{\tt main} is a {\bf method}, which is a named collection of
statements.  The name {\tt main} is special; it marks the place in the
program where execution begins.  When the program runs, it starts at
the first statement in {\tt main} and ends when it finishes the last
statement.

\index{method}
\index{print}
\index{statement!print}

{\tt main} can have any number of statements, but the example has one.
It is a {\bf print statement}, meaning that it displays a message on
the screen.  Confusingly, ``print'' can mean ``display something on
the screen,'' or ``send something to the printer.''  In this book I
won't say much about sending things to the printer; we'll do all our
printing on the screen.  The print statement ends with a semi-colon
({\tt ;}).

{\tt System.out.println} is a method provided by one of Java's
libraries.  A {\bf library} is a collection of class and method
definitions.
\index{library}

Java uses squiggly-braces (\{ and \}) to group things together.  The
outermost squiggly-braces (lines 1 and 8) contain the class
definition, and the inner braces contain the definition of {\tt main}.

\index{braces, squiggly}
\index{squiggly braces}
\index{comment}
\index{statement!comment}

Line 3 begins with {\tt //}.  That means it's 
a {\bf comment}, which is a bit of
English text that you can put a program,
usually to explain what it does.  When the compiler
sees {\tt //}, it ignores everything from there until the end
of the line.


\section{Glossary}

\begin{description}

\item[problem-solving:]  The process of formulating a problem, finding
a solution, and expressing the solution.

\item[high-level language:]  A programming language like Java that
is designed to be easy for humans to read and write.

\item[low-level language:]  A programming language that is designed
to be easy for a computer to run.  Also called ``machine
language'' or ``assembly language.''

\item[formal language:]  Any of the languages people have designed
for specific purposes, like representing mathematical ideas or
computer programs.  All programming languages are formal languages.

\item[natural language:]  Any of the languages people speak that
have evolved naturally.

\item[portability:]  A property of a program that can run on more
than one kind of computer.

\item[interpret:]  To run a program in a high-level language
by translating it one line at a time.

\item[compile:]  To translate a program in a high-level language
into a low-level language, all at once, in preparation for later
execution.

\item[source code:]  A program in a high-level language, before
being compiled.

\item[object code:]  The output of the compiler, after translating
the program.

\item[executable:]  Another name for object code that is ready
to run.

\item[byte code:]  A special kind of object code used for Java
programs.  Byte code is similar to a low-level language, but it is
portable, like a high-level language.

\item[statement:] A part of a program that specifies a computation.

\item[print statement:] A statement that causes output to be displayed
  on the screen.

\item[comment:] A part of a program that contains information
about the program, but that has no effect when the program runs.

\item[method:] A named collection of statements.

\item[library:] A collection of class and method definitions.

\item[bug:]  An error in a program.

\item[syntax:]  The structure of a program.

\item[semantics:]  The meaning of a program.

\item[parse:]  To examine a program and analyze the syntactic structure.

\item[syntax error:]  An error in a program that makes it impossible
to parse (and therefore impossible to compile).

\item[exception:]  An error in a program that makes it fail at
run-time.  Also called a run-time error.

\item[logic error:]  An error in a program that makes it do something
other than what the programmer intended.

\item[debugging:]  The process of finding and removing any of
the three kinds of errors.

\index{problem-solving}
\index{high-level language}
\index{low-level language}
\index{formal language}
\index{natural language}
\index{interpret}
\index{compile}
\index{syntax}
\index{semantics}
\index{parse}
\index{exception}
\index{error}
\index{debugging}
\index{statement}
\index{comment}

\end{description}

\section{Exercises}

\begin{exercise}

Computer scientists have the annoying habit of using common
English words to mean something different from their common
English meaning.  For example, in English, statements and
comments are the same thing, but in programs they are different.

The glossary at the end of each chapter is intended to highlight
words and phrases that have special meanings in computer science.
When you see familiar words, don't assume that you know what 
they mean!

\begin{enumerate}

\item In computer jargon, what's the difference between a statement
and a comment?

\item What does it mean to say that a program is portable?

\item What is an executable?

\end{enumerate}

\end{exercise}

\begin{exercise}

Before you do anything else, find out how to compile and run a Java
program in your environment.  Some environments provide sample programs
similar to the example in Section~\ref{hello}.

\begin{enumerate}

\item Type in the ``Hello, world'' program, then compile and run it.

\item Add a print statement that prints a second message after
the ``Hello, world!''.  Something witty like, ``How are you?''
Compile and run the program again.

\item Add a comment to the program (anywhere), recompile, and run
it again.  The new comment should not affect the result.

\end{enumerate}

This exercise may seem trivial, but it is the starting place for many
of the programs we will work with.  In order to debug with confidence,
you have to have confidence in your programming environment.  In some
environments, it is easy to lose track of which program is executing,
and you might find yourself trying to debug one program while you are
accidentally running another.  Adding (and changing) print statements
is a simple way to be sure that the program you are looking at is
the program you are running.

\end{exercise}


\begin{exercise}

It is a good idea to commit as many errors as you can think of,
so that you see what error messages the compiler produces.
Sometimes the compiler tells you exactly what is wrong, and all
you have to do is fix it.  But sometimes the error messages are
misleading.  You will develop a sense for when you can
trust the compiler and when you have to figure things out yourself.

\begin {enumerate}

\item Remove one of the open squiggly-braces.

\item Remove one of the close squiggly-braces.

\item Instead of {\tt main}, write {\tt mian}.

\item Remove the word {\tt static}.

\item Remove the word {\tt public}.

\item Remove the word {\tt System}.

\item Replace {\tt println} with {\tt Println}.

\item Replace {\tt println} with {\tt print}.  This one is
tricky because it is a logic error, not a syntax error.
The statement {\tt System.out.print} is legal, but it may or may
not do what you expect.

\item Delete one of the parentheses.  Add an extra one.

\end {enumerate}
\end{exercise}





\beforechapter

\chapter{Variables and types}
\label{chap02}

\section{More printing}
\index{print}
\index{statement!print}

You can put as many
statements as you want in {\tt main}; for example, to
print more than one line:

\begin{verbatim}
class Hello {

  // Generates some simple output.

  public static void main(String[] args) {
    System.out.println("Hello, world.");     // print one line
    System.out.println("How are you?");      // print another
  }
}
\end{verbatim}
%
As this example demonstrates, you can put comments at the
end of a line, as well as on a line by themselves.

\index{String}
\index{type!String}

The phrases that appear in quotation marks are called {\bf strings},
because they are made up of a sequence (string) of characters.
Strings can contain any combination of letters, numbers, punctuation
marks, and other special characters.

\index{newline}

{\tt println} is short for ``print line,'' because after each
line it adds a special character, called a {\bf newline}, that
moves the cursor to the next line of the display.
The next time {\tt println} is invoked, the new text appears
on the next line.

To display the output from multiple print
statements all on one line, use {\tt print}:

\begin{verbatim}
class Hello {

  // Generates some simple output.

  public static void main(String[] args) {
    System.out.print("Goodbye, ");
    System.out.println("cruel world!");
  }
}
\end{verbatim}
%
The output appears on a single line as
{\tt Goodbye, cruel world!}.  There is a space
between the word ``Goodbye'' and the second quotation mark.
This space appears in the output, so it affects the behavior
of the program.

Spaces that appear outside of quotation marks generally do
not affect the behavior of the program.  For example, I
could have written:

\begin{verbatim}
class Hello {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel world!");
}
}
\end{verbatim}
%
This program would compile and run just as well as the original.
The breaks at the ends of lines (newlines) do not affect
the program's behavior either, so I could have written:

\begin{verbatim}
class Hello { public static void main(String[] args) {
System.out.print("Goodbye, "); System.out.println
("cruel world!");}}
\end{verbatim}
%
That would work, too, but
the program is getting harder and harder to read.  Newlines and
spaces are useful for organizing your program visually, making
it easier to read the program and locate errors.


\section {Variables}
\index{variable}
\index{value}

One of the most powerful features of a programming language is the
ability to manipulate {\bf variables}.  A variable is a named location
that stores a {\bf value}.  Values are things that can be printed, stored
and (as we'll see later) operated on.  The strings we have been
printing ({\tt "Hello, World."}, {\tt "Goodbye, "}, etc.)  are values.

In order to store a value, you have to create a variable.  Since
the values we want to store are strings, we declare that
the new variable is a string:

\begin{verbatim}
    String bob;
\end{verbatim}
%
This statement is a {\bf declaration}, because it declares that the
variable named {\tt bob} has the type {\tt String}.  Each variable
has a type that determines what kind of values it can store.  For
example, the {\tt int} type can store integers, and the {\tt String}
type can store strings.

\index{declaration}
\index{statement!declaration}

Some types begin with a capital letter and some
with lower-case.  We will learn the significance of this distinction
later, but for now you should take care to get it right.  There is no
such type as {\tt Int} or {\tt string}, and the compiler will object
if you try to make one up.

To create an integer variable, the syntax is {\tt int bob;},
where {\tt bob} is the arbitrary name you made up for the
variable.  In general, you will want to make up variable names
that indicate what you plan to do with the variable.  For
example, if you saw these variable declarations:

\begin{verbatim}
    String firstName;
    String lastName;
    int hour, minute;
\end{verbatim}
%
you could guess what values
would be stored in them.  This example
also demonstrates the syntax for declaring multiple variables
with the same type: {\tt hour} and {\tt second}
are both integers ({\tt int} type).

\section{Assignment}
\index{assignment}
\index{statement!assignment}

Now that we have created variables, we want to
store values.  We do that with an {\bf assignment
statement}.

\begin{verbatim}
    bob = "Hello.";     // give bob the value "Hello."
    hour = 11;           // assign the value 11 to hour
    minute = 59;         // set minute to 59
\end{verbatim}
%
This example shows three assignments, and the comments show
three different ways people sometimes talk about assignment
statements.  The vocabulary can be confusing here, but the
idea is straightforward:

\begin{itemize}

\item When you declare a variable, you create a named storage location.

\item When you make an assignment to a variable, you give it a value.

\end{itemize}

A common way to represent variables on paper is to draw a box
with the name of the variable on the outside and the value
of the variable on the inside.  This figure shows
the effect of the three assignment statements:


\myfig{figure=figs/assign.eps}


As a general rule,
a variable has to have the same type as the
value you assign it.  You cannot store a {\tt String} in {\tt minute} or an
integer in {\tt bob}.

On the other hand, that rule can be confusing, because there are many
ways that you can convert values from one type to another, and Java
sometimes converts things automatically.  For now you should
remember the general rule, and we'll talk about exceptions later.

Another source of confusion is that some strings {\em look}
like integers, but they are not.  For example, {\tt bob}
can contain the string {\tt "123"}, which is made up of the
characters {\tt 1}, {\tt 2} and {\tt 3}, but that is not
the same thing as the {\em number} {\tt 123}.

\begin{verbatim}
    bob = "123";     // legal
    bob = 123;       // not legal
\end{verbatim}


\section{Printing variables}
\label{printing}

You can print the value of a variable using {\tt println} or
{\tt print}:

\begin{verbatim}
class Hello {
  public static void main(String[] args) {
    String firstLine;
    firstLine = "Hello, again!";
    System.out.println(firstLine);
  }
}
\end{verbatim}
%
This program creates a variable named {\tt firstLine}, assigns
it the value {\tt "Hello, again!"} and then prints that value.
When we talk about ``printing a variable,'' we mean printing
the {\em value} of the variable.  To print the {\em name} of
a variable, you have to put it in quotes.
For example: {\tt System.out.println("firstLine");}

For example, you can write

\begin{verbatim}
    String firstLine;
    firstLine = "Hello, again!";
    System.out.print("The value of firstLine is ");
    System.out.println(firstLine);
\end{verbatim}
%
The output of this program is

\begin{verbatim}
The value of firstLine is Hello, again!
\end{verbatim}
%
I am happy to report that the syntax for printing a variable
is the same regardless of the variable's type.

\begin{verbatim}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("The current time is ");
    System.out.print(hour);
    System.out.print(":");
    System.out.print(minute);
    System.out.println(".");
\end{verbatim}
%
The output of this program is {\tt The current time is 11:59.}

WARNING: It is common practice to use several {\tt print} statements
followed by a {\tt println}, in order to put multiple values
on the same line.  But you have to be careful to remember
the {\tt println} at the end.  In many environments, the
output from {\tt print} is stored without being displayed until
{\tt println} is invoked, at which point the entire
line is displayed at once.  If you omit {\tt println}, the
program may terminate without ever displaying the stored output!


\section{Keywords}
\index{keyword}

A few sections ago, I said that you can make up any name you
want for your variables, but that's not quite true.  There
are certain words that are reserved in Java because they are
used by the compiler to parse the structure of your program,
and if you use them as variable names, it will get confused.
These words, called {\bf keywords}, include {\tt public},
{\tt class}, {\tt void}, {\tt int}, and many more.

The complete list is available at \url{http://download.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html}.
This site, provided by Oracle, includes Java documentation I refer to
throughout the book.

Rather than memorize the list, I suggest you
take advantage of a feature provided in many Java development
environments: code highlighting.  As you type,
parts of your program should appear in different colors.  For
example, keywords might be blue, strings red, and other code
black.  If you type a variable name and it turns blue, watch
out!  You might get some strange behavior from the compiler.


\section{Operators}
\index{operator}

{\bf Operators} are symbols used to represent
computations like addition and multiplication.  Most
operators in Java do what you expect them
to do because they are common mathematical symbols.  For
example, the operator for addition is {\tt +}.  Subtraction
is {\tt -}, multiplication is {\tt *}, and division is {\tt /}.

\begin{verbatim}
1+1        hour-1       hour*60 + minute     minute/60
\end{verbatim}
%
Expressions can contain both variable
names and numbers.  Variables are
replaced with their values before the computation is performed.

\index{expression}

Addition, subtraction and multiplication all do what you
expect, but you might be surprised by division.  For example,
this program:

\begin{verbatim}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("Number of minutes since midnight: ");
    System.out.println(hour*60 + minute);
    System.out.print("Fraction of the hour that has passed: ");
    System.out.println(minute/60);
\end{verbatim}
%
generates this output:

\begin{verbatim}
Number of minutes since midnight: 719
Fraction of the hour that has passed: 0
\end{verbatim}
%
The first line is expected, but the second line is
odd.  The value of {\tt minute} is 59, and
59 divided by 60 is 0.98333, not 0.  The problem is that
Java is performing {\bf integer division}.

\index{type!int}
\index{integer division}
\index{arithmetic!integer}
\index{division!integer}
\index{operand}

When both {\bf operands} are integers (operands are the things
operators operate on), the result is also an integer,
and by convention integer division always rounds {\em down},
even in cases like this where the next integer is so close.

An alternative is to calculate a percentage
rather than a fraction:

\begin{verbatim}
    System.out.print("Percentage of the hour that has passed: ");
    System.out.println(minute*100/60);
\end{verbatim}
%
The result is:

\begin{verbatim}
Percentage of the hour that has passed: 98
\end{verbatim}
%
Again the result is rounded down, but at least now the answer
is approximately correct.  In order to get a more accurate
answer, we can use a different type of variable, called
floating-point, that can store fractional values.
We'll get to that in the next chapter.


\section{Order of operations}
\index{precedence}
\index{order of operations}

When more than one operator appears in an expression, the order
of evaluation depends on the rules of {\bf precedence}.  A
complete explanation of precedence can get complicated, but
just to get you started:

\begin{itemize}

\item Multiplication and division happen before
addition and subtraction.  So {\tt 2*3-1} yields 5, not 4, and
{\tt 2/3-1} yields -1, not 1 (remember that in integer division
{\tt 2/3} is 0).

\item If the operators have the same precedence they are evaluated
from left to right.  So in the expression {\tt minute*100/60},
the multiplication happens first, yielding {\tt 5900/60}, which
in turn yields {\tt 98}.  If the operations had gone from right
to left, the result would be {\tt 59*1} which is {\tt 59}, which
is wrong.

\item Any time you want to override the rules of precedence (or
you are not sure what they are) you can use parentheses.  Expressions
in parentheses are evaluated first, so {\tt 2 *(3-1)} is 4.
You can also use parentheses to make an expression easier to
read, as in {\tt(minute * 100) / 60}, even though it doesn't
change the result.

\end{itemize}


\section{Operators for {\tt Strings}}
\index{string operator}
\index{operator!string}

In general you cannot perform mathematical operations on {\tt String}s,
even if the strings look like numbers.  The following are
illegal (if we know that bob has type {\tt String})

\begin{verbatim}
bob - 1         "Hello"/123      bob * "Hello"
\end{verbatim}
%
By the way, can you tell by looking at those expressions
whether {\tt bob} is an integer or a string?  Nope.
The only way to tell the type of a variable is to look at
the place where it is declared.

\index{concatenate}

Interestingly, the {\tt +} operator {\em does} work with
{\tt String}s, but it might not do what you expect.
For {\tt String}s, the {\tt +} operator represents {\bf concatenation},
which means joining up the two operands by linking them
end-to-end.  So {\tt "Hello, " + "world."} yields the string
{\tt "Hello, world."} and {\tt bob + "ism"} adds the suffix
{\em ism} to the end of whatever {\tt bob} is, which is
handy for naming new forms of bigotry.


\section{Composition}
\index{composition}
\index{expression}

So far we have looked at the elements of a programming
language---variables, expressions, and statements---in
isolation, without talking about how to combine them.

One of the most useful features of programming languages
is their ability to take small building blocks and
{\bf compose} them.  For example, we know how to multiply
numbers and we know how to print; it turns out we can
combine them in a single statement:

\begin{verbatim}
    System.out.println(17 * 3);
\end{verbatim}
%
Any expression involving numbers, strings
and variables, can be used inside a print statement.  We've
already seen one example:

\begin{verbatim}
    System.out.println(hour*60 + minute);
\end{verbatim}
%
But you can also put arbitrary expressions on the right-hand
side of an assignment statement:

\begin{verbatim}
    int percentage;
    percentage = (minute * 100) / 60;
\end{verbatim}
%
This ability may not seem impressive now, but we will see
examples where composition 
expresses complex computations neatly and concisely.

WARNING: The left side of an assignment
has to be a {\em variable} name, not an expression.
That's because the left side indicates the storage location
where the result will go.  Expressions
do not represent storage locations, only values.  So the
following is illegal:  {\tt minute+1 = hour;}.

\section{Glossary}

\begin{description}

\item[variable:] A named storage location for values.  All
variables have a type, which is declared when the variable
is created.

\item[value:] A number or string (or other thing to be named later)
that can be stored in a variable.  Every value belongs to a type.

\item[type:] A set of values.  The type of a variable
determines which values can be stored there.  So far, the types
we have seen are integers ({\tt int} in Java) and strings
({\tt String} in Java).

\item[keyword:]  A reserved word used by the compiler
to parse programs.  You cannot use keywords, like {\tt public},
{\tt class} and {\tt void} as variable names.

\item[declaration:] A statement that creates a new variable and
determines its type.

\item[assignment:] A statement that assigns a value to a variable.

\item[expression:] A combination of variables, operators and
values that represents a single value.  Expressions also
have types, as determined by their operators and operands.

\item[operator:] A symbol that represents a
computation like addition, multiplication or string
concatenation.

\item[operand:] One of the values on which an operator operates. 

\item[precedence:] The order in which operations are evaluated.

\item[concatenate:] To join two operands end-to-end.

\item[composition:] The ability to combine simple
expressions and statements into compound statements and expressions
in order to represent complex computations concisely.

\index{variable}
\index{value}
\index{type}
\index{keyword}
\index{assignment}
\index{expression}
\index{operator}
\index{concatenate}
\index{operand}
\index{composition}

\end{description}


\section{Exercises}

\begin{exercise}

If you are using this book in a class, you might enjoy this exercise:
find a partner and play "Stump the Chump'':  

Start with a program that compiles and runs correctly.  One player
turns away while the other player adds an error to the program.  Then
the first player tries to find and fix the error.  You get two points
if you find the error without compiling the program, one point if you
find it using the compiler, and your opponent gets a point if you
don't find it.

Note: please don't remove the ``l'' from ``public.''  It's not as
funny as you think.
\end{exercise}


\begin{exercise}
\label{ex.date}

\begin{enumerate}

\item Create a new program named {\tt Date.java}.  Copy or
type in something like the ``Hello, World'' program and make
sure you can compile and run it.

\item Following the example in Section~\ref{printing}, write a program
that creates variables named {\tt day}, {\tt date}, {\tt month}
and {\tt year}.  {\tt day} will contain the day of the week and {\tt
date} will contain the day of the month.  What type is each variable?
Assign values to those variables that represent today's date.

\item Print the value of each variable on a line by itself.  This is
an intermediate step that is useful for checking that everything is
working so far.

\item Modify the program so that it prints the date in standard
American form: {\tt Saturday, July 16, 2011}.

\item Modify the program again so that the total output is:

\begin{verbatim}
American format:
Saturday, July 16, 2011
European format:
Saturday 16 July, 2011
\end{verbatim}

\end{enumerate}

The point of this exercise is to use string concatenation to display
values with different types ({\tt int} and {\tt String}), and to
practice developing programs gradually by adding a few statements
at a time.

\end{exercise}


\begin{exercise}

\begin{enumerate}

\item Create a new program called {\tt Time.java}.  From now
on, I won't remind you to start with a small, working program,
but you should.

\item Following the example in Section 2.6, create variables
named {\tt hour}, {\tt minute} and {\tt second}, and assign
them values that are roughly the current time.  Use a 24-hour
clock, so that at 2pm the value of {\tt hour} is 14.

\item Make the program calculate and print the number of
seconds since midnight.

\item Make the program calculate and print the number of
seconds remaining in the day.

\item Make the program calculate and print the percentage of
the day that has passed.

\item Change the values of {\tt hour}, {\tt minute} and {\tt second}
to reflect the current time (I assume that some time has elapsed), and
check to make sure that the program works correctly with different
values.

\end{enumerate}

The point of this exercise is to use some of the arithmetic
operations, and to start thinking about compound entities like the
time of day that that are represented with multiple values.  Also,
you might run into problems computing percentages with {\tt ints},
which is the motivation for floating point numbers in the next
chapter.

HINT: you may want to use additional variables to hold values
temporarily during the computation.  Variables like this, that
are used in a computation but never printed, are sometimes called
intermediate or temporary variables.

\end{exercise}

\beforechapter

\chapter{Methods}
\label{chap03}

\section{Floating-point}
\index{floating-point}
\index{type!double}
\index{double(floating-point)}

In the last chapter we had some problems dealing with numbers
that were not integers.  We worked around the problem by measuring
percentages instead of fractions, but a more general solution is
to use floating-point numbers, which can represent fractions
as well as integers.  In Java, the floating-point type is
called {\tt double}, which is short for ``double-precision.''

You can create floating-point variables and assign values to them
using the same syntax we used for the other types.  For example:

\begin{verbatim}
    double pi;
    pi = 3.14159;
\end{verbatim}
%
It is also legal to declare a variable and assign a value to it at the
same time:

\begin{verbatim}
    int x = 1;
    String empty = "";
    double pi = 3.14159;
\end{verbatim}
%
This syntax is common; a combined declaration
and assignment is sometimes called an {\bf initialization}.
\index{initialization}

Although floating-point numbers are useful, they are
a source of confusion because there seems to be an
overlap between integers and floating-point numbers.  For
example, if you have the value {\tt 1}, is that an integer,
a floating-point number, or both?

Java distinguishes the integer value {\tt 1}
from the floating-point value {\tt 1.0}, even though they
seem to be the same number.  They belong to
different types, and strictly speaking, you are not allowed
to make assignments between types.  For example, the following
is illegal:

\begin{verbatim}
    int x = 1.1;
\end{verbatim}
%
because the variable on the left is an {\tt int}
and the value on the right is a {\tt double}.  But it is easy
to forget this rule, especially because there are places where Java
will automatically convert from one type to another.
For example:

\begin{verbatim}
    double y = 1;
\end{verbatim}
%
should technically not be legal, but Java allows it by converting the
{\tt int} to a {\tt double} automatically.  This leniency is
convenient, but it can cause problems; for example:

\begin{verbatim}
    double y = 1 / 3;
\end{verbatim}
%
You might expect the variable {\tt y} to get the value
{\tt 0.333333}, which is a legal floating-point value, but in
fact it gets {\tt 0.0}.  The reason is that the
expression on the right is the ratio of two integers,
so Java does {\em integer} division, which yields the integer
value {\tt 0}.  Converted to floating-point, the result is
{\tt 0.0}.

One way to solve this problem (once you figure out what
it is) is to make the right-hand side a floating-point
expression:

\begin{verbatim}
    double y = 1.0 / 3.0;
\end{verbatim}
%
This sets {\tt y} to {\tt 0.333333}, as expected.

\index{arithmetic!floating-point}

The operations we have seen so far---addition, subtraction,
multiplication, and division---also work on floating-point values,
although you might be interested to know that the underlying mechanism
is completely different.  In fact, most processors have special
hardware just for performing floating-point operations.


\section{Converting from {\tt double} to {\tt int}}
\label{rounding}
\index{rounding}
\index{typecasting}

As I mentioned, Java converts {\tt int}s
to {\tt double}s automatically if necessary, because no
information is lost in the translation.  On the other hand,
going from a {\tt double} to an {\tt int} requires rounding
off.  Java doesn't perform this operation automatically, in
order to make sure that you, as the programmer, are aware
of the loss of the fractional part of the number.

The simplest way to convert a floating-point value to an integer is to
use a {\bf typecast}.  Typecasting is so called because it allows you
to take a value that belongs to one type and ``cast'' it into another
type (in the sense of molding or reforming).

The syntax for typecasting is to put
the name of the type in parentheses and use it as an operator.
For example,

\begin{verbatim}
    double pi = 3.14159;
    int x = (int) pi;
\end{verbatim}
%
The {\tt(int)} operator has the effect of converting what
follows into an integer, so {\tt x} gets the value 3.

Typecasting takes precedence over arithmetic operations,
so in the following example, the value of {\tt pi} gets
converted to an integer first, and the result
is 60.0, not 62.

\begin{verbatim}
    double pi = 3.14159;
    double x = (int) pi * 20.0;
\end{verbatim}
% 
Converting to an integer always rounds down, even if the fraction
part is 0.99999999.  These behaviors (precedence and rounding)
can make typecasting error-prone.


\section{Math methods}
\index{Math class}
\index{class!Math}
\index{expression}
\index{argument}

In mathematics, you have probably seen functions like $\sin$ and
$\log$, and you have learned to evaluate expressions like
$\sin(\pi/2)$ and $\log(1/x)$.  First, you evaluate the
expression in parentheses, which is called the {\bf argument} of the
function.
Then you can evaluate the function itself, either by looking it up in
a table or by performing various computations.

This process can be applied repeatedly to evaluate more complicated
expressions like $\log(1/\sin(\pi/2))$.  First we evaluate the
argument of the innermost function, then evaluate the function,
and so on.

Java provides functions that perform the most
common mathematical operations.  These functions
are called {\bf methods}.
The math methods are invoked using a syntax that is similar to
the {\tt print} statements we have already seen:

\begin{verbatim}
     double root = Math.sqrt(17.0);
     double angle = 1.5;
     double height = Math.sin(angle);
\end{verbatim}
%
The first example sets {\tt root} to the square root of 17.
The second example finds the sine of the value of {\tt angle},
which is {\tt 1.5}.  Java assumes that the
values you use with {\tt sin} and the other trigonometric functions
({\tt cos}, {\tt tan}) are in {\em radians}.  To
convert from degrees to radians, you can divide by 360
and multiply by $2 \pi$.  Conveniently, Java provides {\tt Math.PI}:

\begin{verbatim}
     double degrees = 90;
     double angle = degrees * 2 * Math.PI / 360.0;
\end{verbatim}
%
Notice that {\tt PI} is in all capital letters.  Java does
not recognize {\tt Pi}, {\tt pi}, or {\tt pie}.

Another useful method in the {\tt Math} class is {\tt round},
which rounds a floating-point value off to the nearest integer
and returns an {\tt int}.

\begin{verbatim}
    int x = Math.round(Math.PI * 20.0);
\end{verbatim}
%
In this case the multiplication happens first, before the
method is invoked.  The result is 63 (rounded up from 62.8319).


\section {Composition}
\label{composition}
\index{composition}
\index{expression}

Just as with mathematical functions, Java methods can be {\bf
composed}, meaning that you use one expression as part of another.
For example, you can use any expression as an argument to a method:

\begin{verbatim}
    double x = Math.cos(angle + Math.PI/2);
\end{verbatim}
%
This statement takes the value {\tt Math.PI}, divides it by two and
adds the result to the value of the variable {\tt angle}.  The sum is
then passed as an argument to {\tt cos}. ({\tt
PI} is the name of a variable, not a method, so there are no
arguments, not even the empty argument {\tt()}).

You can also take the result of one method and pass it as
an argument to another:

\begin{verbatim}
    double x = Math.exp(Math.log(10.0));
\end{verbatim}
%
In Java, the {\tt log} method always uses base $e$, so this
statement finds the log base $e$ of 10 and then raises $e$ to that
power.  The result gets assigned to {\tt x}; I hope you know what it
is.

\section{Adding new methods}
\label{adding_methods}
\index{method!definition}
\index{main}
\index{method!main}

So far we have used methods from the Java libraries,
but it is also possible to add new methods.  We have already
seen one method definition: {\tt main}.  The method named {\tt main}
is special, but the syntax is the same for other methods:

\begin{verbatim}
  public static void NAME( LIST OF PARAMETERS ) {
    STATEMENTS
  }
\end{verbatim}
%
You can make up any name you want for your method, except
that you can't call it {\tt main} or any other
Java keyword.  By convention, Java methods start with a lower
case letter and use ``camel caps,'' which is a cute name for
{\tt jammingWordsTogetherLikeThis}.

The list of
parameters specifies what information, if any, you have to
provide in order to use (or {\bf invoke}) the new method.

\index{body!method}

The parameter for {\tt main} is {\tt String[] args}, which
means that whoever invokes {\tt main} has to provide an array of
Strings (we'll get to arrays in Chapter~\ref{arrays}).  The first
couple of methods we are going to write have no parameters, so the
syntax looks like this:

\begin{verbatim}
  public static void newLine() {
    System.out.println("");
  }
\end{verbatim}
%
This method is named {\tt newLine}, and the empty parentheses
mean that it takes no parameters.  It contains one
statement, which prints an empty {\tt String}, indicated by {\tt ""}.
Printing a {\tt String} with no letters in it may not seem all that
useful, but {\tt println} skips to the next
line after it prints, so this statement skips to the next line.

In {\tt main} we invoke this new method the same way we invoke 
Java methods:

\begin{verbatim}
  public static void main(String[] args) {
    System.out.println("First line.");
    newLine();
    System.out.println("Second line.");
  }
\end{verbatim}
%
The output of this program is

\begin{verbatim}
First line.

Second line.
\end{verbatim}
%
Notice the extra space between the lines.  What if we wanted
more space between the lines?  We could invoke the same
method repeatedly:

\begin{verbatim}
  public static void main(String[] args) {
    System.out.println("First line.");
    newLine();
    newLine();
    newLine();
    System.out.println("Second line.");
  }
\end{verbatim}
%
Or we could write a new method, named {\tt threeLine}, that 
prints three new lines:

\begin{verbatim}
  public static void threeLine() {
    newLine();  newLine();  newLine();
  }

  public static void main(String[] args) {
    System.out.println("First line.");
    threeLine();
    System.out.println("Second line.");
  }
\end{verbatim}
%
You should notice a few things about this program:

\begin{itemize}

\item You can invoke the same procedure more than once.

\item You can have one method invoke another method.  In this
case, {\tt main} invokes {\tt threeLine} and {\tt threeLine}
invokes {\tt newLine}.

\item In {\tt threeLine} I wrote three statements all on the same
  line, which is syntactically legal (remember that spaces and new
  lines usually don't change the meaning of a program).  It is usually
  a good idea to put each statement on its own line, but I sometimes
  break that rule.

\end{itemize}

So far, it may not be clear why it is worth the trouble to
create all these new methods.  There are several
reasons; this example demonstrates two:

\begin{enumerate}

\item Creating a new method gives you an opportunity to
give a name to a group of statements.  Methods can simplify a program
by hiding a complex computation behind a single statement, and by using
English words in place of arcane code.  Which is clearer, {\tt
newLine} or {\tt System.out.println("")}?

\item Creating a new method can make a program smaller by eliminating
repetitive code.  For example, to print nine consecutive
new lines, you could invoke {\tt threeLine} three times.

\end{enumerate}

In Section~\ref{methods} we will come back to this question and list
some additional benefits of dividing programs into methods.


\section{Classes and methods}
\index{class}
\index{method}

Pulling together the code fragments from the previous
section, the class definition looks like this:

\begin{verbatim}
class NewLine {

  public static void newLine() {
    System.out.println("");
  }

  public static void threeLine() {
    newLine();  newLine();  newLine();
  }

  public static void main(String[] args) {
    System.out.println("First line.");
    threeLine();
    System.out.println("Second line.");
  }
}
\end{verbatim}
%
The first line indicates that this is the class definition for a new
class called {\tt NewLine}.  A class is a collection of related
methods.  In this case, the class named {\tt NewLine} contains three
methods, named {\tt newLine}, {\tt threeLine}, and {\tt main}.

The other class we've seen is the {\tt Math} class.  It contains
methods named {\tt sqrt}, {\tt sin}, and others.  When
we invoke a mathematical method, we have to specify
the name of the class ({\tt Math}) and the name of the method.
That's why the syntax is slightly different for Java
methods and the methods we write:

\begin{verbatim}
    Math.pow(2.0, 10.0);
    newLine();
\end{verbatim}
%
The first statement invokes the {\tt pow} method in
the {\tt Math class} (which raises the first argument to the
power of the second argument).  The second statement invokes
the {\tt newLine} method, which Java assumes 
is in the {\tt NewLine} class, which is what we are writing.

If you try to invoke a method from the wrong class, the
compiler will generate an error.  For example, if you
type:

\begin{verbatim}
    pow(2.0, 10.0);
\end{verbatim}
%
The compiler will say something like, ``Can't find a method
named {\tt pow} in class {\tt NewLine}.''  If you have
seen this message, you might have wondered why it was looking
for {\tt pow} in your class definition.  Now you know.


\section {Programs with multiple methods}

When you look at a class definition that contains several methods, it
is tempting to read it from top to bottom, but that is likely to be
confusing, because that is not the {\bf order of execution} of the
program.

Execution always begins at the first statement of {\tt main},
regardless of where it is in the program (in this example I deliberately
put it at the bottom).  Statements are executed one at a time, in
order, until you reach a method invocation.  Method invocations are
like a detour in the flow of execution.  Instead of going to the next
statement, you go to the first line of the invoked method, execute all
the statements there, and then come back and pick up again where you
left off.

That sounds simple enough, except that you have to remember that one
method can invoke another.  Thus, while we are in the middle of {\tt
main}, we might have to go off and execute the statements in {\tt
threeLine}.  But while we are executing {\tt threeLine}, we get
interrupted three times to go off and execute {\tt newLine}.

For its part, {\tt newLine} invokes the Java method
{\tt println}, which causes yet another detour.  Fortunately,
Java is adept at keeping track of where it is, so when
{\tt println} completes, it picks up where it left off in
{\tt newLine}, and then gets back to {\tt threeLine}, and then
finally gets back to {\tt main} so the program can terminate.

Technically, the program does not terminate at the
end of {\tt main}.  Instead, execution picks up where it left
off in the program that invoked {\tt main}, which is the
Java interpreter.  The Java interpreter takes care of things
like deleting windows and general cleanup, and {\em then}
the program terminates.

What's the moral of this sordid tale?  When you
read a program, don't read from top to bottom.  Instead,
follow the flow of execution.


\section {Parameters and arguments}
\index{parameter}
\index{argument}

Some of the Java methods we have used have {\bf parameters},
which are values that you provide to let the method do its
job.  For example, if you want to find the sine of a number,
you have to provide the number.  So {\tt sin}
takes a {\tt double} as a parameter.  To print a string,
you have to provide the string, which is why {\tt println}
takes a {\tt String} as a parameter.

Some methods take more than one parameter, like {\tt pow},
which takes two {\tt doubles}, the base and the exponent.

We have to specify not
only how many parameters there are, but also what type they
are.  So it shouldn't surprise you that when you write a
class definition, the parameter list indicates the type of
each parameter.  For example:

\begin{verbatim}
  public static void printTwice(String s) {
    System.out.println(s);
    System.out.println(s);
  }
\end{verbatim}
%
This method takes a single parameter, named {\tt s}, that
has type {\tt String}.  Whatever that parameter is(and at
this point we have no idea what it is), it gets printed
twice.  I chose the name {\tt s} as a hint that the parameter
is a string, but in general you can choose any name you want.

In order to invoke this method, we have to provide a {\tt String}.
For example, we might have a {\tt main} method like this:

\begin{verbatim}
  public static void main(String[] args) {
    printTwice("Don't make me say this twice!");
  }
\end{verbatim}

The string you provide is called an {\bf argument}, and we
say that the argument is {\bf passed} to the method.  In
this case we are creating a string value that contains the
text ``Don't make me say this twice!'' and passing that
string as an argument to {\tt printTwice} where, contrary
to its wishes, it will get printed twice.

Alternatively, if we had a {\tt String} variable, we could
use it as an argument instead:

\begin{verbatim}
  public static void main(String[] args) {
    String argument = "Never say never.";
    printTwice(argument);
  }
\end{verbatim}
%
Notice something very important: the name of the variable we pass
as an argument ({\tt argument}) has nothing to do with the name of the
parameter ({\tt s}).  Let me say that again:

\begin{quote}

{\bf The name of the variable we pass as an argument has nothing to do
with the name of the parameter.}

\end{quote}

They can be the same or they can be different, but it is important
to realize that they are not the same thing, except that they happen
to have the same value (in this case the string {\tt "Never say never."}).

The value you provide as an argument must have the same type as
the parameter of the method you invoke.  This rule is
important, but it gets complicated in Java for two reasons:

\begin {itemize}

\item There are some methods that can accept arguments with many
different types.  For example, you can send {\em any} type to
{\tt print} and {\tt println}, and it will do the right thing
no matter what.  This sort of thing is an exception, though.

\item If you violate this rule, the compiler often generates
a confusing error message.  Instead of saying something like,
``You are passing the wrong kind of argument to this method,''
it will probably say something to the effect that it could
not find a method with that name that would accept an argument
with that type.  Once you have seen this error message a few
times, though, you will figure out how to interpret it.

\end{itemize}


\section {Stack diagrams}
\label{stack}
\index{stack diagram}
\index{diagram!stack}

Parameters and other
variables only exist inside their own methods.  Within the
confines of {\tt main}, there is no such thing as {\tt s}.
If you try to use it, the compiler will complain.  Similarly,
inside {\tt printTwice} there is no such thing as {\tt argument}.

One way to keep track of where each variable is defined is
with a {\bf stack diagram}.  The stack diagram for the previous
example looks like this:

\myfig{figure=figs/stack.eps}

For each method there is a gray box called a {\bf frame} that contains
the method's parameters and variables.  The name of the method
appears outside the frame.  As usual, the value of each variable
is drawn inside a box with the name of the variable beside it.



\section {Methods with multiple parameters}
\label{time}
\index{parameter!multiple}
\index{method!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking methods with multiple
parameters is a common source of errors.  First, remember
that you have to declare the type of every parameter.  For
example

\begin{verbatim}
  public static void printTime(int hour, int minute) {
    System.out.print(hour);
    System.out.print(":");
    System.out.println(minute);
  }
\end{verbatim}
%
It might be tempting to write {\tt int hour, minute}, but
that format is only legal for variable declarations, not
for parameters.

Another common source of confusion is that you do not have
to declare the types of arguments.  The following is wrong!

\begin{verbatim}
    int hour = 11;
    int minute = 59;
    printTime(int hour, int minute);   // WRONG!
\end{verbatim}
%
In this case, Java can tell the type of {\tt hour}
and {\tt minute} by looking at their declarations.  It is
not necessary to include the type when you pass them
as arguments.  The correct
syntax is {\tt printTime(hour, minute)}.

\begin{exercise}
Draw a stack frame that shows the state of the program
when {\tt main} invokes {\tt printTime}
with the arguments {\tt 11} and {\tt 59}.
\end{exercise}


\section {Methods with results}
\index{fruitful method}
\index{method!fruitful}

Some of the methods we are using,
like the {\tt Math} methods, yield results.  Other methods,
like {\tt println} and {\tt newLine}, perform an action but
they don't return a value.  That raises some questions:

\begin{itemize}

\item What happens if you invoke a method and you don't
do anything with the result (i.e. you don't assign it to
a variable or use it as part of a larger expression)?

\item What happens if you use a {\tt print} method as part
of an expression, like {\tt System.out.println("boo!") + 7}?

\item Can we write methods that yield results, or are we
stuck with things like {\tt newLine} and {\tt printTwice}?

\end{itemize}

The answer to the third question is ``yes, you can write methods that
return values,'' and we'll do it in a couple of chapters.  I will
leave it up to you to answer the other two questions by trying them
out.  In fact, any time you have a question about what is legal or
illegal in Java, a good way to find out is to ask the compiler.


\section{Glossary}

\begin{description}

\item[initialization:]  A statement that declares a new variable
and assigns a value to it at the same time.
\index{initialization}

\item[floating-point:] A type of variable (or value) that can contain
fractions as well as integers.  The floating-point type we will
use is {\tt double}.

\item[class:]  A named collection of methods.  So far, we have used
the {\tt Math} class and the {\tt System} class, and we have
written classes named {\tt Hello} and {\tt NewLine}.

\item[method:]  A named sequence of statements that performs a
useful function.  Methods may or may not take parameters, and may
or may not produce a result.

\item[parameter:]  A piece of information a method requires before
it can run.  Parameters are variables: they contain values and have types.

\item[argument:]  A value that you provide when you invoke a
method.  This value must have the same type as the corresponding
parameter.

\item[frame:] A structure (represented by a gray box in stack diagrams)
that contains a method's parameters and variables.

\item[invoke:]  Cause a method to execute.

\index{floating-point}
\index{class}
\index{method}
\index{parameter}
\index{argument}

\end{description}

\section{Exercises}

\begin{exercise}

The point of this exercise is to practice reading code and to
make sure that you understand the flow of execution through
a program with multiple methods.

\begin{enumerate}

\item What is the output of the following program?  Be precise
about where there are spaces and where there are newlines.

HINT: Start by describing in words what {\tt ping} and
{\tt baffle} do when they are invoked.

\item Draw a stack diagram that shows the state of the program
the first time {\tt ping} is invoked.

\end{enumerate}

\begin{verbatim}
  public static void zoop() {
    baffle();    
    System.out.print("You wugga ");
    baffle();
  }

  public static void main(String[] args) {
    System.out.print("No, I ");
    zoop();
    System.out.print("I ");
    baffle();
  }

  public static void baffle() {
    System.out.print("wug");
    ping();
  }

  public static void ping() {
    System.out.println(".");
  }
\end{verbatim}
\end{exercise}


\begin{exercise}
The point of this exercise is to make sure you understand how
to write and invoke methods that take parameters.

\begin{enumerate}

\item Write the first line of a method named {\tt zool} that
takes three parameters: an {\tt int} and two {\tt Strings}.

\item Write a line of code that invokes {\tt zool}, passing
as arguments the value {\tt 11}, the name of your first pet,
and the name of the street you grew up on.
\end{enumerate}
\end{exercise}


\begin{exercise}

The purpose of this exercise is to take code from a previous exercise
and encapsulate it in a method that takes parameters.  You should
start with a working solution to Exercise~\ref{ex.date}.

\begin{enumerate}

\item Write a method called {\tt printAmerican}
that takes the day, date, month and year as parameters and that
prints them in American format.

\item Test your method by invoking it from {\tt main} and passing
appropriate arguments.  The output should look something like this
(except that the date might be different):
%
\begin{verbatim}
Saturday, July 16, 2011
\end{verbatim}
%
\item Once you have debugged {\tt printAmerican}, write another
method called {\tt printEuropean} that prints the date in
European format.

\end{enumerate}
\end{exercise}



\beforechapter
\chapter{Conditionals and recursion}
\label{chap04}
\label{condrecursion}

\section{The modulus operator}
\index{modulus}
\index{operator!modulus}

The modulus operator works on integers (and integer expressions)
and yields the {\em remainder} when the first operand is divided
by the second.  In Java, the modulus operator is a percent sign,
{\tt \%}.  The syntax is the same as for other operators:

\begin{verbatim}
    int quotient = 7 / 3;
    int remainder = 7 % 3;
\end{verbatim}
%
The first operator, integer division, yields 2.  The second
operator yields 1.  Thus, 7 divided by 3 is 2 with 1 left over.

The modulus operator turns out to be surprisingly useful.  For
example, you can check whether one number is divisible by
another: if {\tt x \% y} is zero, then {\tt x} is divisible
by {\tt y}.

Also, you can use the modulus operator to extract the rightmost
digit or digits from a number.  For example, {\tt x \% 10} yields
the rightmost digit of {\tt x} (in base 10).  Similarly
{\tt x \% 100} yields the last two digits.


\section{Conditional execution}
\index{conditional}
\index{statement!conditional}

In order to write useful programs, we almost always need
to check conditions and change the behavior of the program
accordingly.  {\bf Conditional statements} give us this ability.  The
simplest form is the {\tt if} statement:

\begin{verbatim}
    if (x > 0) {
      System.out.println("x is positive");
    }
\end{verbatim}
%
The expression in parentheses is called the condition.
If it is true, then the statements in brackets get executed.
If the condition is not true, nothing happens.

\index{operator!comparison}
\index{operator!relational}
\index{comparison!operator}
\index{relational operator}

The condition can contain any of the comparison operators,
sometimes called {\bf relational operators}:

\begin{verbatim}
    x == y               // x equals y
    x != y               // x is not equal to y
    x > y                // x is greater than y
    x < y                // x is less than y
    x >= y               // x is greater than or equal to y
    x <= y               // x is less than or equal to y
\end{verbatim}
%
Although these operations are probably familiar to you, the
syntax Java uses is a little different from mathematical
symbols like $=$, $\neq$ and $\le$.  A common error is
to use a single {\tt =} instead of a double {\tt ==}.  Remember
that {\tt =} is the assignment operator, and {\tt ==} is
a comparison operator.  Also, there is no such thing as
{\tt =<} or {\tt =>}.

The two sides of a condition operator have to be the same
type.  You can only compare {\tt ints} to {\tt ints} and
{\tt doubles} to {\tt doubles}.

The operators {\tt ==} and {\tt !=} work with Strings, but they
don't do what you expect.  And the other relational operators
don't do anything at all.
We will see how to compare strings Section~\ref{incomparable}.


\section {Alternative execution}
\label{alternative}
\index{conditional!alternative}

A second form of conditional execution is alternative execution,
in which there are two possibilities, and the condition determines
which one gets executed.  The syntax looks like:

\begin{verbatim}
    if (x%2 == 0) {
      System.out.println("x is even");
    } else {
      System.out.println("x is odd");
    }
\end{verbatim}
%
If the remainder when {\tt x} is divided by 2 is zero, then
we know that {\tt x} is even, and this code prints a message
to that effect.  If the condition is false, the second
print statement is executed.  Since the condition must
be true or false, exactly one of the alternatives will be
executed.

As an aside, if you think you might want to check the parity
(evenness or oddness) of numbers often, you might want to
``wrap'' this code up in a method, as follows:

\begin{verbatim}
  public static void printParity(int x) {
    if (x%2 == 0) {
      System.out.println("x is even");
    } else {
      System.out.println("x is odd");
    }
  }
\end{verbatim}
%
Now you have a method named {\tt printParity} that will print
an appropriate message for any integer you care to provide.
In {\tt main} you would invoke this method like this:

\begin{verbatim}
    printParity(17);
\end{verbatim}
%
Always remember that when you {\em invoke} a method, you do
not have to declare the types of the arguments you provide.
Java can figure out what type they are.  You should resist the
temptation to write things like:

\begin{verbatim}
    int number = 17;
    printParity(int number);         // WRONG!!!
\end{verbatim}


\section {Chained conditionals}
\index{conditional!chained}

Sometimes you want to check for a number of related conditions
and choose one of several actions.  One way to do this is by
{\bf chaining} a series of {\tt if}s and {\tt else}s:

\begin{verbatim}
    if (x > 0) {
      System.out.println("x is positive");
    } else if (x < 0) {
      System.out.println("x is negative");
    } else {
      System.out.println("x is zero");
    }
\end{verbatim}
%
These chains can be as long as you want, although they can
be difficult to read if they get out of hand.  One way to
make them easier to read is to use standard indentation,
as demonstrated in these examples.  If you keep all the
statements and squiggly-brackets lined up, you are less
likely to make syntax errors and more likely to find them
if you do.


\section{Nested conditionals}
\index{conditional!nested}

In addition to chaining, you can also nest one conditional
within another.  We could have written the previous example
as:

\begin{verbatim}
    if (x == 0) {
      System.out.println("x is zero");
    } else {
      if (x > 0) {
        System.out.println("x is positive");
      } else {
        System.out.println("x is negative");
      }
    }
\end{verbatim}
%
There is now an outer conditional that contains two branches.  The
first branch contains a simple {\tt print} statement, but the second
branch contains another conditional statement, which has two branches
of its own.  Those two branches are both {\tt print}
statements, but they could have been conditional statements as
well.

Indentation helps make the structure
apparent, but nevertheless, nested conditionals get difficult to read
very quickly.  Avoid them when you can.
\index{nested structure}

On the other hand, this kind of {\bf nested structure} is common, and
we will see it again, so you better get used to it.


\section{The return statement}
\index{return}
\index{statement!return}

The {\tt return} statement allows you to terminate the execution
of a method before you reach the end.  One reason to use it
is if you detect an error condition:

\begin{verbatim}
  public static void printLogarithm(double x) {
    if (x <= 0.0) {
      System.out.println("Positive numbers only, please.");
      return;
    }

    double result = Math.log(x);
    System.out.println("The log of x is " + result);
  }
\end{verbatim}
%
This defines a method named {\tt printLogarithm} that takes a
{\tt  double} named {\tt x} as a parameter.  It checks whether
{\tt  x} is less than or equal to zero, in which case it prints an error
message and then uses {\tt return} to exit the method.  The flow of
execution immediately returns to the caller and the remaining lines of
the method are not executed.

I used a floating-point value on the right side of the condition
because there is a floating-point variable on the left.


\section {Type conversion}
\index{type!conversion}
\index{typecasting}

You might wonder how you can get away with an expression like {\tt
"The log of x is " + result}, since one of the operands is a {\tt String}
and the other is a {\tt double}.  In this case Java is being
smart on our behalf, automatically converting the {\tt double} to a
{\tt String} before it does the string concatenation.

%This kind of feature is an example of a common problem in designing a
%programming language, which is that there is a conflict between {\em
%formalism}, which is the requirement that formal languages should have
%simple rules with few exceptions, and {\em convenience}, which is the
%requirement that programming languages be easy to use in practice.

%More often than not, convenience wins, which is usually good for
%expert programmers (who are spared from rigorous but unwieldy
%formalism), but bad for beginning programmers, who are often baffled
%by the complexity of the rules and the number of exceptions.  In this
%book I have tried to simplify things by emphasizing the rules and
%omitting many of the exceptions.

Whenever you try to ``add'' two
expressions, if one of them is a {\tt String}, Java converts the
other to a {\tt String} and then perform string concatenation.  What do you
think happens if you perform an operation between an integer and a
floating-point value?


\section{Recursion}
\label{recursion}
\index{recursion}

I mentioned in the last chapter that it is legal for one method to
invoke another, and we have seen several examples.  I neglected to
mention that it is also legal for a method to invoke itself.  It may
not be obvious why that is a good thing, but it turns out to be one of
the most magical and interesting things a program can do.

For example, look at the following method:

\begin{verbatim}
  public static void countdown(int n) {
    if (n == 0) {
      System.out.println("Blastoff!");
    } else {
      System.out.println(n);
      countdown(n-1);
    }
  }
\end{verbatim}
%
The name of the method is {\tt countdown} and it takes a single
integer as a parameter.  If the parameter is zero, it prints
the word ``Blastoff.''  Otherwise, it prints the number and
then invokes a method named {\tt countdown}---itself---passing
{\tt n-1} as an argument.

What happens if we invoke this method, in {\tt main}, like
this:

\begin{verbatim}
    countdown(3);
\end{verbatim}
%
The execution of {\tt countdown} begins with {\tt n=3}, and
since {\tt n} is not zero, it prints the value 3, and then
invokes itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=2}, and
since {\tt n} is not zero, it prints the value 2, and then
invokes itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=1}, and
since {\tt n} is not zero, it prints the value 1, and then
invokes itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=0}, and
since {\tt n} is zero, it prints the word ``Blastoff!''
and then returns.
\end{quote}

The {\tt countdown} that got {\tt n=1} returns.

\end{quote}

The {\tt countdown} that got {\tt n=2} returns.

\end{quote}

The {\tt countdown} that got {\tt n=3} returns.

\noindent And then you're back in {\tt main}.  So the
total output looks like:

\begin{verbatim}
3
2
1
Blastoff!
\end{verbatim}
%
As a second example, let's look again at the methods
{\tt newLine} and {\tt threeLine}.

\begin{verbatim}
  public static void newLine() {
    System.out.println("");
  }

  public static void threeLine() {
    newLine();  newLine();  newLine();
  }
\end{verbatim}
%
Although these work, they would not be much help if we wanted
to print 2 newlines, or 106.  A better alternative would be

\begin{verbatim}
  public static void nLines(int n) {
    if (n > 0) {
      System.out.println("");
      nLines(n-1);
    }
  }
\end{verbatim}
%
This program similar to {\tt countdown}; as long as {\tt n} is greater
than zero, it prints a newline and then invokes itself to
print {\tt n-1} additional newlines.  The total number
of newlines that get printed is {\tt 1 +(n-1)}, which usually
comes out to roughly {\tt n}.

\index{recursive}
\index{newline}

When a method invokes itself, that's called {\bf recursion}, and
such methods are {\bf recursive}.


\section{Stack diagrams for recursive methods}
\index{stack}
\index{diagram!state}
\index{diagram!stack}

In the previous chapter we used a stack diagram to represent the
state of a program during a method invocation.  The same kind
of diagram can make it easier to interpret a recursive method.

Remember that every time a method gets called it creates
a new frame that contains a new version of
the method's parameters and variables.

The following figure is a stack diagram for countdown, called
with {\tt n = 3}:

\myfig{figure=figs/stack2.eps}
% 
There is one frame for {\tt main} and four frames for {\tt countdown},
each with a different value for the parameter {\tt n}.  The bottom of
the stack, {\tt countdown} with {\tt n=0} is called the {\bf base
  case}.  It does not make a recursive call, so there are no more
frames for {\tt countdown}.

The frame for {\tt main} is empty because {\tt main} does not
have any parameters or variables.

\begin{exercise}
Draw a stack diagram that shows the state of the program
after {\tt main} invokes {\tt nLines} with the parameter {\tt n=4},
just before the last invocation of {\tt nLines} returns.
\end{exercise}


\section{Glossary}

\begin{description}

\item[modulus:]  An operator that works on integers and yields
the remainder when one number is divided by another.  In Java
it is denoted with a percent sign({\tt \%}).

\item[conditional:]  A block of statements that may or may not
be executed depending on some condition.

\item[chaining:]  A way of joining several conditional statements
in sequence.

\item[nesting:] Putting a conditional statement inside one or both
branches of another conditional statement.

\item[coordinate:]  A variable or value that specifies a location
in a two-dimensional graphical window.

\item[pixel:]  The unit in which coordinates are measured.

\item[bounding box:]  A common way to specify the coordinates of
a rectangular area.

\item[typecast:]  An operator that converts from one type to another.
In Java it appears as a type name in parentheses, like {\tt(int)}.

\item[interface:]  A description of the parameters required by
a method and their types.

\item[prototype:]  A way of describing the interface to a method
using Java-like syntax.

\item[recursion:]  The process of invoking the same method you
are currently executing.

\item[base case:] A condition that causes a recursive method {\em not}
  to make a recursive call.


\index{modulus}
\index{conditional}
\index{conditional!chained}
\index{conditional!nested}
\index{coordinate}
\index{bounding box}
\index{typecast}
\index{interface}
\index{prototype}
\index{recursion}
\index{base case}

\end{description}

\section{Exercises}

\begin{exercise}
This exercise reviews the flow of execution through a program
with multiple methods.  Read the following code and answer the
questions below.

\begin{verbatim}
public class Buzz {

    public static void baffle(String blimp) {
        System.out.println(blimp);
        zippo("ping", -5);
    }

    public static void zippo(String quince, int flag) {
        if (flag < 0) {
            System.out.println(quince + " zoop");
        } else {
            System.out.println("ik");
            baffle(quince);
            System.out.println("boo-wa-ha-ha");
        } 
    }

    public static void main(String[] args) {
        zippo("rattle", 13);
    }
}
\end{verbatim}

\begin{enumerate}

\item Write the number {\tt 1} next to the first {\em statement}
of this program that will be executed.  Be careful to distinguish
things that are statements from things that are not.

\item Write the number {\tt 2} next to the second statement, and so on
until the end of the program.  If a statement is executed more than
once, it might end up with more than one number next to it.

\item What is the value of the parameter {\tt blimp} when {\tt baffle}
gets invoked?

\item What is the output of this program?

\end{enumerate}
\end{exercise}


\begin{exercise}
The first verse of the song ``99 Bottles of Beer'' is:

\begin{quote}
99 bottles of beer on the wall,
99 bottles of beer,
ya' take one down, ya' pass it around,
98 bottles of beer on the wall.
\end{quote}

Subsequent verses are identical except that the number
of bottles gets smaller by one in each verse, until the
last verse:

\begin{quote}
No bottles of beer on the wall,
no bottles of beer,
ya' can't take one down, ya' can't pass it around,
'cause there are no more bottles of beer on the wall!
\end{quote}
%
And then the song(finally) ends.

Write a program that prints the entire lyrics of
``99 Bottles of Beer.''  Your program should include a
recursive method that does the hard part, but you
might want to write additional methods to separate the major
functions of the program.

As you develop your code, test it with a small number of
verses, like ``3 Bottles of Beer.''

The purpose of this exercise is to take a problem and break it
into smaller problems, and to solve the smaller problems by writing
simple methods.
\end{exercise}

\begin{exercise}
What is the output of the following program?

\begin{verbatim}
public class Narf {

    public static void zoop(String fred, int bob) {
        System.out.println(fred);
        if (bob == 5) {
            ping("not ");
        } else {
            System.out.println("!");
        }
    }

    public static void main(String[] args) {
        int bizz = 5;
        int buzz = 2;
        zoop("just for", bizz);
        clink(2*buzz);
    }

    public static void clink(int fork) {
        System.out.print("It's ");
        zoop("breakfast ", fork) ;
    }

    public static void ping(String strangStrung) {
        System.out.println("any " + strangStrung + "more ");
    }
}
\end{verbatim}
\end{exercise}

\begin{exercise}
Fermat's Last Theorem says that there are no integers
$a$, $b$, and $c$ such that

\[a^n + b^n = c^n \]
%
except in the case when $n=2$.

Write a method named {\tt checkFermat} that takes four
integers as parameters---{\tt a}, {\tt b}, {\tt c} and {\tt n}---and
that checks to see if Fermat's theorem holds.  If
$n$ is greater than 2 and it turns out to be true that 
$a^n + b^n = c^n$,
the program should print ``Holy smokes, Fermat was wrong!''
Otherwise the program should print ``No, that doesn't work.''

You should assume that there is a method named {\tt raiseToPow}
that takes two integers as arguments and that raises the
first argument to the power of the second.  For example:

\begin{verbatim}
    int x = raiseToPow(2, 3);
\end{verbatim}
%
would assign the value {\tt 8} to {\tt x}, because $2^3 = 8$.
\end{exercise}

\beforechapter
\chapter{GridWorld: Part One}
\label{gridworld}

\section{Getting started}

Now is a good time to start working with the AP Computer Science Case
Study, which is a program called GridWorld.  To get started, install
GridWorld, which you can download from the College Board:
\url{http://www.collegeboard.com/student/testing/ap/compsci_a/case.html}.

When you unpack this code, you should have a folder named {\tt
  GridWorldCode} that contains {\tt projects/firstProject}, which
contains {\tt BugRunner.java}.

Make a copy of {\tt BugRunner.java} in another folder and then import it
into your development environment.  There are instructions here that
might help: \url{http://www.collegeboard.com/prod_downloads/student/testing/ap/compsci_a/ap07_gridworld_installation_guide.pdf}.

Once you run {\tt BugRunner.java}, download the GridWorld Student
Manual from \url{http://www.collegeboard.com/prod_downloads/student/testing/ap/compsci_a/ap07_gridworld_studmanual_appends_v3.pdf}.

The Student Manual uses vocabulary I have not presented yet, so to
get you started, here is a quick preview:

\begin{itemize}

\item The components of GridWorld, including Bugs, Rocks and the Grid
itself, are {\bf objects}.

\item A {\bf constructor} is a special method that creates new objects.

\item A {\bf class} is a set of objects; every object belongs to a
class.

\item An object is also called an {\bf instance} because it is a member,
or instance, of a class.

\item An {\bf attribute} is a piece of information about an object, like
its color or location.

\item An {\bf accessor method} is a method that returns an attribute of
an object.

\item A {\bf modifier method} changes an attribute of an object.

\end{itemize}

Now you should be able to read Part 1 of the Student Manual and do
the exercises.

\section{{\tt BugRunner}}

{\tt BugRunner.java} contains this code:

\begin{verbatim}
import info.gridworld.actor.ActorWorld;
import info.gridworld.actor.Bug;
import info.gridworld.actor.Rock;

public class BugRunner
{
    public static void main(String[] args)
    {
        ActorWorld world = new ActorWorld();
        world.add(new Bug());
        world.add(new Rock());
        world.show();
    }
}
\end{verbatim}

The first three lines are {\tt import} statements; they list
the classes from GridWorld used in this program.

Like the other programs we have seen, BugRunner defines a class
that provides a {\tt main} method.  The first line of {\tt main}
creates an {\tt ActorWorld} object.  {\tt new} is a Java keyword
that creates new objects.

The next two lines create a Bug and a Rock, and add them to {\tt world}.
The last line shows the world on the screen.

Open {\tt BugRunner.java} for editing and replace this line:

\begin{verbatim}
    world.add(new Bug());
\end{verbatim}

with these lines:

\begin{verbatim}
    Bug redBug = new Bug();
    world.add(redBug);
\end{verbatim}

The first line assigns the Bug to a variable named {\tt redBug};
we can use {\tt redBug} to invoke the Bug's methods.  Try this:

\begin{verbatim}
    System.out.println(redBug.getLocation());
\end{verbatim}

Note: If you run this before adding the Bug to the {\tt world}, the result is
{\tt null}, which means that the Bug doesn't have a location yet.

Invoke the other accessor methods and print the bug's attributes.
Invoke the methods {\tt canMove}, {\tt move} and {\tt turn} and
be sure you understand what they do.  Now try these exercises:

\begin{exercise}
\begin{enumerate}

\item Write a method named {\tt moveBug} that takes a bug as a parameter
and invokes {\tt move}.  Test your method by calling it from {\tt main}.

\item Modify {\tt moveBug} so that it invokes {\tt canMove} and moves
the bug only if it can.

\item Modify {\tt moveBug} so that it takes an integer, {\tt n}, as a
parameter, and moves the bug {\tt n} times (if it can).

\item Modify {\tt moveBug} so that if the bug can't move, it invokes
{\tt turn} instead.

\end{enumerate}
\end{exercise}


\begin{exercise}
\begin{enumerate}

\item The {\tt Math} class provides a method named {\tt random}
that returns a double between 0.0 and 1.0 (not including 1.0).

\item Write a method named {\tt randomBug} that takes a Bug as a
  parameter and sets the Bug's direction to one of 0, 90, 180 or 270
  with equal probability, and then moves the bug if it can.

\item Modify {\tt randomBug} to take an integer {\tt n} and repeat
{\tt n} times.

The result is a random walk, which you can read about
at \url{http://en.wikipedia.org/wiki/Random_walk}.

\item To see a longer random walk, you can give ActorWorld a bigger stage.
At the top of {\tt BugRunner.java}, add this {\tt import} statement:

\begin{verbatim}
import info.gridworld.grid.UnboundedGrid;
\end{verbatim}

Now replace the line that creates the ActorWorld with this:

\begin{verbatim}
    ActorWorld world = new ActorWorld(new UnboundedGrid());
\end{verbatim}

You should be able to run your random walk for a few thousand
steps (you might have to use the scrollbars to find the Bug).

\end{enumerate}
\end{exercise}


\begin{exercise}

GridWorld uses Color objects, which are defined in the Java libraries.
You can read the documentation at
\url{http://download.oracle.com/javase/6/docs/api/java/awt/Color.html}.

To create Bugs with different colors, we have to import
{\tt Color}:

\begin{verbatim}
import java.awt.Color;
\end{verbatim}

Then you can access the predefined colors, like {\tt Color.blue}, or
create a new color like this:

\begin{verbatim}
    Color purple = new Color(148, 0, 211);
\end{verbatim}

Make a few bugs with different colors.  Then write a method named
{\tt colorBug} that takes a Bug as a parameter, reads its location,
and sets the color.

The Location object you get from
{\tt getLocation} has methods named {\tt getRow} and {\tt getCol} that
return integers.  So you can get the x-coordinate of a Bug like this:

\begin{verbatim}
    int x = bug.getLocation().getCol();
\end{verbatim}

Write a method named {\tt makeBugs} that takes an ActorWorld and an
integer {\tt n} and creates {\tt n} bugs colored according to their
location.  Use the row number to control the red level and the column
to control the blue.


\end{exercise}



\beforechapter
\chapter{Fruitful methods}
\label{chap05}

\section{Return values}
\index{return}
\index{statement!return}
\index{method!fruitful}
\index{fruitful method}
\index{return value}
\index{void}
\index{method!void}

Some of the Java methods we have used, like the Math
functions, produce results.  That is, the effect of
invoking the method is to generate a new value, which we
usually assign to a variable or use as part of an expression.
For example:

\begin{verbatim}
    double e = Math.exp(1.0);
    double height = radius * Math.sin(angle);
\end{verbatim}
%
But so far all the methods we have written have been {\bf void}
methods; that is, methods that return no value.  When you invoke
a void method, it is typically on a line by itself, with
no assignment:

\begin{verbatim}
    countdown(3);
    nLines(3);
\end{verbatim}
%
In this chapter we write methods that return things, which I call 
{\bf fruitful} methods.  The first example is {\tt area}, which takes a
{\tt double} as a parameter, and returns the area of a circle with the
given radius:

\begin{verbatim}
  public static double area(double radius) {
    double area = Math.PI * radius * radius;
    return area;
  }
\end{verbatim}
%
The first thing you should notice is that the beginning of the
method definition is different.  Instead of {\tt public static
void}, which indicates a void method, we see {\tt public static
double}, which means that the return value from this method
is a {\tt double}.  I still haven't explained what
{\tt public static} means, but be patient.

\index{static}

The last line is a new form of the
{\tt return} statement that includes a return value.  This
statement means, ``return immediately from this method and
use the following expression as a return value.''  The
expression you provide can be arbitrarily complicated,
so we could have written this method more concisely:

\begin{verbatim}
  public static double area(double radius) {
    return Math.PI * radius * radius;
  }
\end{verbatim}
%
On the other hand, {\bf temporary} variables like {\tt area} often
make debugging easier.  In either case, the type of the expression in
the {\tt return} statement must match the return type of the method.
In other words, when you declare that the return type is {\tt double},
you are making a promise that this method will eventually
produce a {\tt double}.  If you try to {\tt return} with no
expression, or an expression with the wrong type, the compiler will
take you to task.

\index{temporary variable}
\index{variable!temporary}

Sometimes it is useful to have multiple return
statements, one in each branch of a conditional:

\begin{verbatim}
  public static double absoluteValue(double x) {
    if (x < 0) {
      return -x;
    } else {
      return x;
    }
  }
\end{verbatim}
%
Since these return statements are in an alternative conditional,
only one will be executed.  Although it is legal to have more than one
return statement in a method, you should keep in mind
that as soon as one is executed, the method
terminates without executing any subsequent statements.

Code that appears after a {\tt return} statement, or any place else
where it can never be executed, is called {\bf dead code}.  Some
compilers warn you if part of your code is dead.

\index{dead code}

If you put return statements inside a conditional, then
you have to guarantee that {\em every possible path} through
the program hits a return statement.  For example:

\begin{verbatim}
  public static double absoluteValue(double x) {
    if (x < 0) {
      return -x;
    } else if (x > 0) {
      return x;
    }                          // WRONG!!
  }
\end{verbatim}
%
This program is not legal because if {\tt x} is 0,
neither condition is true and the method ends without hitting
a return statement.  A typical compiler message would be ``return
statement required in absoluteValue,'' which is a confusing message
since there are already two of them.


\section{Program development}
\label{distance}
\index{program development}

At this point you should be able to look at complete Java methods
and tell what they do.  But it may not be clear yet how to go
about writing them.  I am going to suggest one technique that
I call {\bf incremental development}.

\index{incremental development}

As an example, imagine you want to find the distance between
two points, given by the coordinates $(x_1, y_1)$ and
$(x_2, y_2)$.  By the usual definition,

\begin{equation}
distance = \sqrt{(x_2 - x_1)^2 +(y_2 - y_1)^2}
\end{equation}
%
The first step is to consider what a {\tt distance} method
should look like in Java.  In other words, what are the inputs
(parameters) and what is the output (return value)?

In this case, the two points are the parameters, and it is
natural to represent them using four {\tt double}s, although
we will see later that there is a {\tt Point} object in Java
that we could use.  The return value is the distance, which
will have type {\tt double}.

Already we can write an outline of the method:

\begin{verbatim}
  public static double distance
              (double x1, double y1, double x2, double y2) {
    return 0.0;
  }
\end{verbatim}
%
The statement {\tt return 0.0;} is a place-keeper that is necessary
in order to compile the program.  Obviously, at this stage the
program doesn't do anything useful, but it is worthwhile to
try compiling it so we can identify any syntax errors before
we add more code.

In order to test the new method, we have to invoke it with
sample values.  Somewhere in {\tt main} I would add:

\begin{verbatim}
    double dist = distance(1.0, 2.0, 4.0, 6.0);
\end{verbatim}
%
I chose these values so that the horizontal
distance is 3 and the vertical distance is 4; that way,
the result will be 5 (the hypotenuse of a 3-4-5 triangle).
When you are testing a method, it is useful to know the right
answer.

Once we have checked the syntax of the method definition, we
can start adding lines of code one at a time.  After each
incremental change, we recompile and run the program.  If there is
an error at any point, we have a good idea where to look:
in the last line we added.

The next step is to find the differences
$x_2 - x_1$ and $y_2 - y_1$.  I will store those values in
temporary variables named {\tt dx} and {\tt dy}.

\begin{verbatim}
  public static double distance
              (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    System.out.println("dx is " + dx);
    System.out.println("dy is " + dy);
    return 0.0;
  }
\end{verbatim}
%
I added print statements so we can check the intermediate values
before proceeding.  They should be 3.0 and 4.0.

\index{scaffolding}

When the method is finished I will remove the print statements.  Code
like that is called {\bf scaffolding}, because it is helpful for
building the program, but it is not part of the final product.

The next step is to square {\tt dx} and {\tt dy}.  We could use the
{\tt Math.pow} method, but it is simpler to multiply each term by
itself.

\begin{verbatim}
  public static double distance
              (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx*dx + dy*dy;
    System.out.println("dsquared is " + dsquared);
    return 0.0;
  }
\end{verbatim}
%
Again, I would compile and run the program at this stage
and check the intermediate value (which should be 25.0).

Finally, we can use {\tt Math.sqrt} to compute and
return the result.

\begin{verbatim}
  public static double distance
              (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx*dx + dy*dy;
    double result = Math.sqrt(dsquared);
    return result;
  }
\end{verbatim}
%
In {\tt main}, we can print and check the value of the result.

As you gain more experience programming, you might
write and debug more than one line at a time.  Nevertheless,
this incremental development process can save you a lot of
time.

The key aspects of the process are:

\begin{itemize}

\item Start with a working program and make small, incremental
changes.  At any point, if there is an error, you will know
exactly where it is.

\item Use temporary variables to hold intermediate values so
you can print and check them.

\item Once the program is working, you can remove
scaffolding and consolidate multiple statements into
compound expressions, but only if it does not make the program
difficult to read.

\end{itemize}


\section{Composition}
\index{composition}

Once you define a new method,
you can use it as part of an expression, and you can build
new methods using existing methods.  For example, what if someone
gave you two points, the center of the circle and a point on
the perimeter, and asked for the area of the circle?

Let's say the center point is stored in the variables {\tt xc}
and {\tt yc}, and the perimeter point is in {\tt xp} and
{\tt yp}.  The first step is to find the radius of the circle, which
is the distance between the two points.  Fortunately, we have
a method, {\tt distance} that does that.

\begin{verbatim}
    double radius = distance(xc, yc, xp, yp);
\end{verbatim}
%
The second step is to find the area of a circle with that
radius, and return it.

\begin{verbatim}
    double area = area(radius);
    return area;
\end{verbatim}
%
Wrapping that all up in a method, we get:

\begin{verbatim}
  public static double circleArea
              (double xc, double yc, double xp, double yp) {
    double radius = distance(xc, yc, xp, yp);
    double area = area(radius);
    return area;
  } 
\end{verbatim}
%
The temporary variables {\tt radius} and {\tt area} are
useful for development and debugging, but once the program is
working we can make it more concise by composing
the method invocations:

\begin{verbatim}
  public static double circleArea
              (double xc, double yc, double xp, double yp) {
    return area(distance(xc, yc, xp, yp));
  } 
\end{verbatim}


\section{Overloading}
\label{overloading}
\index{overloading}

You might have noticed that {\tt circleArea}
and {\tt area} perform similar functions---finding
the area of a circle---but take different parameters.  For
{\tt area}, we have to provide the radius; for {\tt circleArea}
we provide two points.

If two methods do the same thing, it is natural to give them
the same name.  
Having more than one method with the same name, which is called {\bf
overloading}, is legal in Java {\em as long as each version takes
different parameters}.  So we could rename {\tt circleArea}:

\begin{verbatim}
  public static double area
              (double x1, double y1, double x2, double y2) {
    return area(distance(xc, yc, xp, yp));
  } 
\end{verbatim}
%
When you invoke an overloaded method, Java knows which version you
want by looking at the arguments that you provide.  If you write:

\begin{verbatim}
    double x = area(3.0);
\end{verbatim}
%
Java goes looking for a method named {\tt area} that
takes one {\tt double} as an argument, and so it uses the
first version, which interprets the argument as a radius.
If you write:

\begin{verbatim}
    double x = area(1.0, 2.0, 4.0, 6.0);
\end{verbatim}
%
Java uses the second version of {\tt area}.  And notice that the
second version of {\tt area} actually invokes the first.

Many Java methods are overloaded, meaning that there
are different versions that accept different numbers or types of
parameters.  For example, there are versions of {\tt print} and {\tt
println} that accept a single parameter of any type.  In the Math
class, there is a version of {\tt abs} that works on {\tt double}s,
and there is also a version for {\tt int}s.

Although overloading is a useful feature, it should be used
with caution.  You might get yourself nicely confused if you
are trying to debug one version of a method while accidently
invoking a different one.

And that reminds me of one of the cardinal rules of
debugging: {\bf make sure that the version of the program
you are looking at is the version of the program that is running!}

Some day you may find yourself making one change after another
in your program, and seeing the same thing every time you run it.
This is a warning sign that you are
not running the version of the program you think you are.  To
check, add a {\tt print} statement (it doesn't matter what
you print) and make sure the behavior of the program changes
accordingly.


\section{Boolean expressions}
\index{boolean}
\index{expression!boolean}

Most of the operations we have seen produce results that are
the same type as their operands.  For example, the {\tt +} operator
takes two {\tt int}s and produces an {\tt int}, or two {\tt double}s
and produces a {\tt double}, etc.

\index{operator!relational}
\index{relational operator}

The exceptions we have seen are the {\bf relational operators}, which
compare {\tt int}s and {\tt float}s and return either {\tt true} or
{\tt false}.  {\tt true} and {\tt false} are special values in Java,
and together they make up a type called {\bf boolean}.  You might
recall that when I defined a type, I said it was a set of values.  In
the case of {\tt int}s, {\tt double}s and {\tt String}s, those sets
are pretty big.  For {\tt boolean}s, not so big.

Boolean expressions and variables work just like other types of
expressions and variables:

\begin{verbatim}
    boolean bob;
    bob = true;
    boolean testResult = false;
\end{verbatim}
%
The first example is a simple variable declaration;
the second example is an assignment, and the third example is an
initialization.

The values {\tt true} and {\tt false}
are keywords in Java, so they may appear in a different color,
depending on your development environment.

\index{initialization}
\index{statement!initialization}

The result of a conditional operator is a boolean,
so you can store the result of a comparison in a variable:

\begin{verbatim}
    boolean evenFlag = (n%2 == 0);     // true if n is even
    boolean positiveFlag = (x > 0);    // true if x is positive
\end{verbatim}
%
and then use it as part of a conditional statement later:

\begin{verbatim}
    if (evenFlag) {
      System.out.println("n was even when I checked it");
    }
\end{verbatim}
%
A variable used in this way is called a {\bf flag}
because it flags the presence or absence of some condition.


\section{Logical operators}
\index{logical operator}
\index{operator!logical}

There are three {\bf logical operators} in Java: AND, OR and NOT,
which are denoted by the symbols {\tt \&\&}, {\tt ||} and
{\tt !}.  The semantics of these operators is similar
to their meaning in English.  For example {\tt x > 0 \&\& x < 10}
is true only if {\tt x} is greater than zero AND less than 10.

\index{semantics}

{\tt evenFlag || n\%3 == 0} is true if {\em either} of
the conditions is true, that is, if {\tt evenFlag} is true OR the
number is divisible by 3.

Finally, the NOT operator inverts a boolean expression, so {\tt
  !evenFlag} is true if {\tt evenFlag} is false---if the number is
odd.

\index{nested structure}

Logical operators can simplify nested
conditional statements.  For example, can you re-write
this code using a single conditional?

\begin{verbatim}
    if (x > 0) {
      if (x < 10) {
        System.out.println("x is a positive single digit.");
      }
    }
\end{verbatim}


\section{Boolean methods}
\label{boolean}
\index{boolean}
\index{method!boolean}

Methods can return boolean values just like any other type,
which is often convenient for hiding tests inside
methods.  For example:

\begin{verbatim}
  public static boolean isSingleDigit(int x) {
    if (x >= 0 && x < 10) {
      return true;
    } else {
      return false;
    }
  }
\end{verbatim}
%
The name of this method is {\tt isSingleDigit}.  It is common
to give boolean methods names that sound like yes/no questions.
The return type is {\tt boolean}, which means that every return
statement has to provide a boolean expression.

The code itself is straightforward, although it is a bit longer than
it needs to be.  Remember that the expression {\tt x >= 0 \&\& x < 10}
has type boolean, so there is nothing wrong with returning it
directly and avoiding the {\tt if} statement altogether:

\begin{verbatim}
  public static boolean isSingleDigit(int x) {
    return (x >= 0 && x < 10);
  }
\end{verbatim}
%
In {\tt main} you can invoke this method in the usual ways:

\begin{verbatim}
  boolean bigFlag = !isSingleDigit(17);
  System.out.println(isSingleDigit(2));
\end{verbatim}
%
The first line sets {\tt bigFlag} to {\tt true}
only if 17 is {\em not} a single-digit number.  The second
line prints {\tt true} because 2 is a single-digit number.

The most common use of boolean methods is inside conditional
statements

\begin{verbatim}
    if (isSingleDigit(x)) {
      System.out.println("x is little");
    } else {
      System.out.println("x is big");
    }
\end{verbatim}


\section {More recursion}
\index{recursion}
\index{language!complete}

Now that we have methods that return values, we have a {\bf Turing
  complete} programming language, which means that we can compute
anything computable, for any reasonable definition of ``computable.''
\index{Turing, Alan}
\index{Church, Alonzo}

This idea was developed by Alonzo Church and Alan Turing, so it is
known as the Church-Turing thesis.  You can read more about it at
\url{http://en.wikipedia.org/wiki/Turing_thesis}.

To give you an idea of what you can do with the tools we have learned
so far, let's look at some methods for evaluating
recursively-defined mathematical functions.  A recursive definition is
similar to a circular definition, in the sense that the definition
contains a reference to the thing being defined.  A truly circular
definition is not very useful:

\begin{description}

\item[recursive:] an adjective used to describe a method that is recursive.

\index{frabjuous}

\end{description}

If you saw that definition in the dictionary, you might be
annoyed.  On the other hand, if you looked up the definition
of the mathematical function {\bf factorial}, you might
get something like:
%
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot(n-1)!
\end{eqnarray*}
%
(Factorial is usually denoted with the symbol $!$, which is
not to be confused with the Java logical operator {\tt !} which
means NOT.)  This definition says that the factorial of 0 is 1,
and the factorial of any other value, $n$, is $n$ multiplied
by the factorial of $n-1$.  So $3!$ is 3 times $2!$, which is 2 times
$1!$, which is 1 times $0!$.  Putting it all together, we get
$3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can usually
write a Java method to evaluate it.  The first step is to decide what
the parameters are and what the return type is.  Since factorial is
defined for integers, the method takes an
integer as a parameter and returns an integer:

\begin{verbatim}
  public static int factorial(int n) {
  }
\end{verbatim}

\noindent If the argument happens to be zero, return 1:

\begin{verbatim}
  public static int factorial(int n) {
    if (n == 0) {
      return 1;
    }
  }
\end{verbatim}
%
That's the base case.

Otherwise, and this is the interesting part, we have to make
a recursive call to find the factorial of $n-1$, and then
multiply it by $n$.

\begin{verbatim}
  public static int factorial(int n) {
    if (n == 0) {
      return 1;
    } else {
      int recurse = factorial(n-1);
      int result = n * recurse;
      return result;
    }
  }
\end{verbatim}
%
The flow of execution for this program is similar to {\tt countdown}
from Section~\ref{recursion}.
If we invoke {\tt factorial} with the value 3:

Since 3 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 2 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 1 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 0 {\em is} zero, we take the first branch and return
the value 1 immediately without making any more recursive
invocations.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 1,
and the result is returned.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 2,
and the result is returned.

\end{quote}

\noindent The return value (2) gets multiplied by {\tt n}, which is 3,
and the result, 6, is returned to {\tt main}, or whoever
invoked {\tt factorial(3)}.

\index{stack}
\index{diagram!state}
\index{diagram!stack}

Here is what the stack diagram looks like for this sequence of
method invocations:


\myfig{figure=figs/stack3.eps}

%
The return values are shown being passed back up the stack.

Notice that in the last frame {\tt recurse} and {\tt result} do not
exist because when {\tt n=0} the branch that creates them does not
execute.


\section{Leap of faith}
\index{leap of faith}

Following the flow of execution is one way to read programs it can
quickly become labarynthine.  An alternative is what I call the ``leap
of faith.''  When you come to a method invocation, instead of
following the flow of execution, you {\em assume} that the method
works correctly and returns the appropriate value.

In fact, you are already practicing this leap of faith
when you use Java methods.  When you invoke {\tt Math.cos}
or {\tt System.out.println}, you don't examine the implementations of 
those methods.  You just assume that they work.

You can apply the same logic to your own methods.
For example, in Section~\ref{boolean} we wrote a method called
{\tt isSingleDigit} that determines whether a number is between
0 and 9.  Once we convince ourselves that this method
is correct---by testing and examination of the code---we can
use the method without ever looking at the code again.

The same is true of recursive programs.  When you get to
the recursive invocation, instead of following the flow of
execution, you should {\em assume} that the recursive invocation
works, and then ask yourself,
``Assuming that I can find the factorial of $n-1$, can I
compute the factorial of $n$?''  Yes, you can, by multiplying by $n$.

Of course, it is strange to assume that the method
works correctly when you have not even finished writing it,
but that's why it's called a leap of faith!


\section{One more example}
\index{factorial}
\label{factorial}

The second most common example of a recursively-defined
mathematical function is {\tt fibonacci}, which has the
following definition:
%
\begin{eqnarray*}
&& fibonacci(0) = 1 \\
&& fibonacci(1) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
%
Translated into Java, this is

\begin{verbatim}
  public static int fibonacci(int n) {
    if (n == 0 || n == 1) {
      return 1;
    } else {
      return fibonacci(n-1) + fibonacci(n-2);
    }
  }
\end{verbatim}
% If you try to follow the flow of execution here, even for small
values of {\tt n}, your head explodes.  But according to the leap of
faith, if we assume that the two recursive invocations work correctly, then
it is clear that we get the right result by adding them together.


\section{Glossary}

\begin{description}

\item[return type:]  The part of a method declaration that indicates
what type of value the method returns.

\item[return value:]  The value provided as the result of a method
invocation.

\item[dead code:]  Part of a program that can never be executed,
often because it appears after a {\tt return} statement.

\item[scaffolding:]  Code that is used during program development
but is not part of the final version.

\item[void:]  A special return type that indicates a void method;
that is, one that does not return a value.

\item[overloading:]  Having more than one method with the same name
but different parameters.  When you invoke an overloaded method,
Java knows which version to use by looking at the arguments you
provide.

\item[boolean:]  A type of variable that can contain only the two
values {\tt true} and {\tt false}.

\item[flag:]  A variable(usually {\tt boolean}) that records
a condition or status information.

\item[conditional operator:]  An operator that compares two values
and produces a boolean that indicates the relationship between the
operands.

\item[logical operator:]  An operator that combines boolean values
and produces boolean values.

\index{return type}
\index{return value}
\index{dead code}
\index{scaffolding}
\index{void}
\index{overloading}
\index{boolean}
\index{operator!conditional}
\index{operator!logical}


\end{description}


\section{Exercises}

\begin{exercise}
\label{ex.isdiv}
Write a class method named {\tt isDivisible} that takes
two integers, {\tt n} and {\tt m} and that returns {\tt true}
if {\tt n} is divisible by {\tt m} and {\tt false} otherwise.
\end{exercise}


\begin{exercise}
\label{ex.multadd}

Many computations can be expressed concisely using the ``multadd''
operation, which takes three operands and computes {\tt a*b + c}.  Some
processors even provide a hardware implementation of this operation for
floating-point numbers.

\begin{enumerate}

\item Create a new program called {\tt Multadd.java}.

\item Write a method called {\tt multadd} that takes three {\tt doubles}
as parameters and that returns their multadditionization.

\item Write a {\tt main} method that tests {\tt multadd} by invoking it with a
few simple parameters, like {\tt 1.0, 2.0, 3.0}.

\item Also in {\tt main}, use {\tt multadd} to compute the
following values:
%
\begin{eqnarray*}
& \sin \frac{\pi}{4} + \frac{\cos \frac{\pi}{4}}{2} & \\
& \log 10 + \log 20 &
\end{eqnarray*}
%
\item Write a method called {\tt yikes} that takes a
double as a parameter and that uses {\tt multadd} to calculate
%
\begin{eqnarray*}
x e^{-x} + \sqrt{1 - e^{-x}}
\end{eqnarray*}
%
HINT: the Math method for raising $e$ to a power is {\tt Math.exp}.

\end{enumerate}

In the last part, you get a chance to write a method that invokes
a method you wrote.  Whenever you do that, it is a good idea to
test the first method carefully before you start working on the
second.  Otherwise, you might find yourself debugging two methods
at the same time, which can be difficult.

One of the purposes of this exercise is to practice pattern-matching:
the ability to recognize a specific problem as an instance of a
general category of problems.
\end{exercise}


\begin{exercise}
If you are given three sticks, you may or may not be able to arrange
them in a triangle.  For example, if one of the sticks is 12 inches
long and the other two are one inch long, you will
not be able to get the short sticks to meet in the middle.  For any
three lengths, there is a simple test to see if it is possible to form
a triangle:

\begin{quotation}
``If any of the three lengths is greater than the sum of the other two,
then you cannot form a triangle.  Otherwise, you can.''
\end{quotation}

Write a method named {\tt isTriangle} that it takes three integers as
arguments, and that returns either {\tt true} or {\tt false},
depending on whether you can or cannot form a triangle from sticks
with the given lengths.

The point of this exercise is to use conditional statements to
write a fruitful method.
\end{exercise}


\begin{exercise}
What is the output of the following program?  The purpose of
this exercise is to make sure you understand logical operators
and the flow of execution through fruitful methods.

\begin{verbatim}
  public static void main(String[] args) {
      boolean flag1 = isHoopy(202);
      boolean flag2 = isFrabjuous(202);
      System.out.println(flag1);
      System.out.println(flag2);
      if (flag1 && flag2) {
          System.out.println("ping!");
      }
      if (flag1 || flag2) {
          System.out.println("pong!");
      }
  }

  public static boolean isHoopy(int x) {
      boolean hoopyFlag;
      if (x%2 == 0) {
          hoopyFlag = true;
      } else {
          hoopyFlag = false;
      }
      return hoopyFlag;
  }

  public static boolean isFrabjuous(int x) {
      boolean frabjuousFlag;
      if (x > 0) {
          frabjuousFlag = true;
      } else {
          frabjuousFlag = false;
      }
      return frabjuousFlag;
  }
\end{verbatim}
\end{exercise}



\begin{exercise}
The distance between two points $(x_1, y_1)$ and $(x_2, y_2)$
is

\[Distance = \sqrt{(x_2 - x_1)^2 +(y_2 - y_1)^2} \]

Write a method named {\tt distance} that takes four
doubles as parameters---{\tt x1}, {\tt y1}, {\tt x2} and {\tt
y2}---and that prints the distance between the points.

You should assume that there is a method named {\tt sumSquares}
that calculates and returns the sum of the squares of its arguments.
For example:

\begin{verbatim}
    double x = sumSquares(3.0, 4.0);
\end{verbatim}
%
would assign the value {\tt 25.0} to {\tt x}.

The point of this exercise is to write a new method that uses an
existing one.  You should write only one method: {\tt distance}.  You
should not write {\tt sumSquares} or {\tt main} and you should not
invoke {\tt distance}.
\end{exercise}


\begin{exercise}
The point of this exercise is to use a stack diagram to understand
the execution of a recursive program.

\begin{verbatim}
public class Prod {

    public static void main(String[] args) {
        System.out.println(prod(1, 4));
    }

    public static int prod(int m, int n) {
        if (m == n) {
            return n;
        } else {
            int recurse = prod(m, n-1);
            int result = n * recurse;
            return result;
        }
    }
}
\end{verbatim}
%
\begin{enumerate}

\item Draw a stack diagram showing the state of the program just
before the last instance of {\tt prod} completes.
What is the output of this program?

\item Explain in a few words what {\tt prod} does.

\item Rewrite {\tt prod} without using the temporary variables
{\tt recurse} and {\tt result}.

\end{enumerate}
\end{exercise}


\begin{exercise}
The purpose of this exercise is to translate a recursive definition
into a Java method.  The Ackerman function is defined for non-negative
integers as follows:
%
\begin{eqnarray*}
A(m,n) = \left\{
\begin{array}{l@{\quad \mathbf{if} \quad }l}
n+1 & m=0 \\
A(m-1, 1) & m>0, n=0 \\
A(m-1, A(m, n-1)) & m>0, n>0 \\
\end{array} \right.
\end{eqnarray*}
%
Write a method called {\tt ack} that takes two {\tt int}s as
parameters and that computes and returns the value
of the Ackerman function.

Test your implementation of Ackerman by invoking it
from {\tt main} and printing the return value.  

WARNING: the return value gets very big very quickly.  You should try it
only for small values of $m$ and $n$ (not bigger than 2).

\end{exercise}


\begin{exercise}
\begin{enumerate}

\item Create a program called {\tt Recurse.java} and
type in the following methods:

\begin{verbatim}
    // first: returns the first character of the given String
    public static char first(String s) {
        return s.charAt(0);
    }

    // last: returns a new String that contains all but the
    // first letter of the given String
    public static String rest(String s) {
        return s.substring(1, s.length());
    }

    // length: returns the length of the given String
    public static int length(String s) {
        return s.length();
    }
\end{verbatim}

\item Write some code in {\tt main} that tests each of these
methods.  Make sure they work, and make sure you understand
what they do.

\item Write a method called {\tt printString} that takes a
String as a parameter and that prints the letters of the
String, one on each line.  It should be a {\tt void} method.

\item Write a method called {\tt printBackward} that does
the same thing as {\tt printString} but that prints the String
backward (one character per line).

\item Write a method called {\tt reverseString} that takes
a String as a parameter and that returns a new String as a
return value.  The new String should contain the same letters
as the parameter, but in reverse order.  For example, the
output of the following code

\begin{verbatim}
	String backwards = reverseString("Allen Downey");
	System.out.println(backwards);
\end{verbatim}
%
should be

\begin{verbatim}
yenwoD nellA
\end{verbatim}

\end{enumerate}
\end{exercise}


\begin{exercise}
\label{ex.power}
Write a recursive method called {\tt power} that
takes a double {\tt x} and an integer {\tt n} and that
returns $x^n$.

Hint: a recursive definition of this
operation is $x^n = x \cdot x^{n-1}$.
Also, remember that anything raised to the zeroeth power
is 1.

Optional challenge: you can make this method more efficient, when {\tt
  n} is even, using $x^n = \left( x^{n/2} \right)^2$.

\end{exercise}


\begin{exercise}
\label{gcd}
(This exercise is based on page 44 of Ableson and Sussman's
{\em Structure and Interpretation of Computer Programs}.)

The following technique is known as Euclid's Algorithm because
it appears in Euclid's {\em Elements}(Book 7, ca. 300 B.C.).
It may be the oldest nontrivial algorithm\footnote{For a definition
of ``algorithm'', jump ahead to Section~\ref{algorithm}.}.

The process is based on the observation that, if $r$ is the
remainder when $a$ is divided by $b$, then the common divisors
of $a$ and $b$ are the same as the common divisors of $b$ and $r$.
Thus we can use the equation
%
\[ gcd(a, b) = gcd(b, r) \]
%
to successively reduce the problem of computing a GCD to the
problem of computing the GCD of smaller and smaller pairs of integers.
For example,
%
\[ gcd(36, 20) = gcd(20, 16) = gcd(16, 4) = gcd(4, 0) = 4\]
%
implies that the GCD of 36 and 20 is 4.  It can be shown
that for any two starting numbers, this repeated reduction eventually
produces a pair where the second number is 0.  Then the GCD is the
other number in the pair.

Write a method called {\tt gcd} that takes two integer parameters and
that uses Euclid's algorithm to compute and return the greatest
common divisor of the two numbers.
\end{exercise}


\beforechapter
\chapter{Iteration}
\label{chap06}

\section{Multiple assignment}
\index{assignment}
\index{statement!assignment}
\index{multiple assignment}

I haven't said much about it, but it is legal in Java to
make more than one assignment to the same variable.  The
effect of the second assignment is to replace the old value
with the new.

\begin{verbatim}
    int bob = 5;
    System.out.print(bob);
    bob = 7;
    System.out.println(bob);
\end{verbatim}
%
The output of this program is {\tt 57}, because the first
time we print {\tt bob} his value is 5, and the second time
his value is 7.

This kind of {\bf multiple assignment} is the reason I
described variables as a {\em container} for values.  When
you assign a value to a variable, you change the contents of
the container, as shown in the figure:


\myfig{figure=figs/assign2.eps}


When there are multiple assignments to a variable, it is especially
important to distinguish between an assignment statement and a
statement of equality.  Because Java uses the {\tt =} symbol for
assignment, it is tempting to interpret a statement like {\tt a = b}
as a statement of equality.  It is not!

First of all, equality is commutative, and assignment is not.
For example, in mathematics if $a = 7$ then $7 = a$.  But in
Java {\tt a = 7;} is a legal assignment statement, and {\tt 7 = a;}
is not.

Furthermore, in mathematics, a statement of equality is true
for all time.  If $a = b$ now, then $a$ will always equal $b$.
In Java, an assignment statement can make two variables equal,
but they don't have to stay that way!

\begin{verbatim}
    int a = 5;
    int b = a;     // a and b are now equal
    a = 3;         // a and b are no longer equal
\end{verbatim}
%
The third line changes the value of {\tt a} but it does not
change the value of {\tt b}, so they are no longer equal.
In some programming languages a different symbol is used
for assignment, such as {\tt <-} or {\tt :=}, in order to
avoid this confusion.

Although multiple assignment is frequently useful, you should use it
with caution.  If the values of variables change often, it can make
the code difficult to read and debug.


\section{Iteration}
\index{iteration}

Computers are often used to automate repetitive tasks.  Repeating
tasks without making errors is something that
computers do well and people do poorly.

We have already seen methods, like {\tt countdown} and {\tt factorial},
 that use recursion to perform repetition, also called
{\bf iteration}.  Java provides language features that make
it easier to write these methods.

The two features we are going to look at are the {\tt while}
statement and the {\tt for} statement.

\section{The {\tt while} statement}
\index{statement!while}
\index{while statement}

Using a {\tt while} statement, we can rewrite {\tt countdown}:

\begin{verbatim}
  public static void countdown(int n) {
    while (n > 0) {
      System.out.println(n);
      n = n-1;
    }
    System.out.println("Blastoff!");
  }
\end{verbatim}
%
You can almost read a {\tt while} statement like
English.  What this means is, ``While {\tt n} is greater than
zero, print the value of {\tt n} and then reduce
the value of {\tt n} by 1.  When you get to zero, print the
word `Blastoff!'''

More formally, the flow of execution for a {\tt while} statement
is as follows:

\begin{enumerate}

\item Evaluate the condition in parentheses, yielding {\tt true}
or {\tt false}.

\item If the condition is false, exit the {\tt while} statement
and continue execution at the next statement.

\item If the condition is true, execute the statements
between the squiggly-brackets, and then go back to step 1.

\end{enumerate}

This type of flow is called a {\bf loop} because the third step loops
back around to the top.  The statements inside the loop are called
the {\bf body} of the loop.

If the condition is false the
first time through the loop, the statements inside the loop are
never executed.  

\index{loop}
\index{loop!body}
\index{loop!infinite}
\index{body!loop}
\index{infinite loop}

The body of the loop should change the value of
one or more variables so that, eventually, the condition becomes
false and the loop terminates.  Otherwise the loop will repeat
forever, which is called an {\bf infinite} loop.  An endless
source of amusement for computer scientists is the observation
that the directions on shampoo, ``Lather, rinse, repeat,'' are
an infinite loop.

In the case of {\tt countdown}, we can prove that the loop
terminates if {\tt n} is positive.

In other cases it is not so easy to tell:

\begin{verbatim}
  public static void sequence(int n) {
    while (n != 1) {
      System.out.println(n);
      if (n%2 == 0) {           // n is even
        n = n / 2;
      } else {                  // n is odd
        n = n*3 + 1;
      }
    }
  }
\end{verbatim}
%
The condition for this loop is {\tt n != 1}, so the loop
will continue until {\tt n} is 1, which will make the condition
false.

At each iteration, the program prints the value of {\tt n} and then
checks whether it is even or odd.  If it is even, the value of
{\tt n} is divided by two.  If it is odd, the value is replaced
by $3n+1$.  For example, if the starting value (the argument passed
to {\tt sequence}) is 3, the resulting sequence is
3, 10, 5, 16, 8, 4, 2, 1.

Since {\tt n} sometimes increases and sometimes decreases, there is no
obvious proof that {\tt n} will ever reach 1, or that the program will
terminate.  For some particular values of {\tt n}, we can prove
termination.  For example, if the starting value is a power of two, then
the value of {\tt n} will be even every time through the loop, until
we get to 1.  The previous example ends with such a sequence,
starting with 16.

Particular values aside, the interesting question is whether
we can prove that this program terminates for {\em all} values of n.
So far, no one has been able to prove it {\em or} disprove it!
For more information, see \url{http://en.wikipedia.org/wiki/Collatz_conjecture}.


\section{Tables}
\index{table}
\index{logarithm}

One of the things loops are good for is generating and printing
tabular data.  For example, before computers were readily
available, people had to calculate logarithms,
sines and cosines, and other common mathematical functions
by hand.

To make that easier, there were books containing long tables
where you could find the values of various functions.
Creating these tables was slow and boring, and the results
were full of errors.

When computers appeared on the scene, one of the initial reactions
was, ``This is great!  We can use the computers to generate the
tables, so there will be no errors.''  That turned out to be true
(mostly), but shortsighted.  Soon thereafter computers were so
pervasive that the tables became obsolete.

Well, almost.  For some operations, computers use tables of values to
get an approximate answer, and then perform computations to improve
the approximation.  In some cases, there have been errors in the
underlying tables, most famously in the table the original Intel
Pentium used to perform floating-point division\footnote{See
  \url{http://en.wikipedia.org/wiki/Pentium_FDIV_bug}.}.

\index{division!floating-point}

Although a ``log table'' is not as useful as it once was, it still
makes a good example of iteration.  The following program prints a
sequence of values in the left column and their logarithms in the
right column:

\begin{verbatim}
    double x = 1.0;
    while (x < 10.0) {
      System.out.println(x + "   " + Math.log(x));
      x = x + 1.0;
    }
\end{verbatim}
%
The output of this program is

\begin{verbatim}
1.0   0.0
2.0   0.6931471805599453
3.0   1.0986122886681098
4.0   1.3862943611198906
5.0   1.6094379124341003
6.0   1.791759469228055
7.0   1.9459101490553132
8.0   2.0794415416798357
9.0   2.1972245773362196
\end{verbatim}
%
Looking at these values, can you tell what base the {\tt log}
method uses?

Since powers of two are important
in computer science, we often want logarithms with
respect to base 2.  To compute them, we can use the following
formula:

\begin{equation}
\log_2 x = log_e x / log_e 2
\end{equation}
%
Changing the {\tt print} statement to

\begin{verbatim}
      System.out.println(x + "   " + Math.log(x) / Math.log(2.0));
\end{verbatim}
%
yields

\begin{verbatim}
1.0   0.0
2.0   1.0
3.0   1.5849625007211563
4.0   2.0
5.0   2.321928094887362
6.0   2.584962500721156
7.0   2.807354922057604
8.0   3.0
9.0   3.1699250014423126
\end{verbatim}
%
We can see that 1, 2, 4 and 8 are powers of two, because
their logarithms base 2 are round numbers.  If we wanted to find
the logarithms of other powers of two, we could modify the
program like this:

\begin{verbatim}
    double x = 1.0;
    while (x < 100.0) {
      System.out.println(x + "   " + Math.log(x) / Math.log(2.0));
      x = x * 2.0;
    }
\end{verbatim}
%
Now instead of adding something to {\tt x} each time through
the loop, which yields an arithmetic sequence, we multiply
{\tt x} by something, yielding a {\bf geometric} sequence.
The result is:

\begin{verbatim}
1.0   0.0
2.0   1.0
4.0   2.0
8.0   3.0
16.0   4.0
32.0   5.0
64.0   6.0
\end{verbatim}
%
Log tables may not be useful any more, but for computer scientists,
knowing the powers of two is!  When you have an idle
moment, you should memorize the powers of two up to 65536
(that's $2^{16}$).


\section{Two-dimensional tables}
\index{table!two-dimensional}

A two-dimensional table is a table where you choose a row and
a column and read the value at the intersection.  A multiplication
table is a good example.  Let's say you wanted to print a
multiplication table for the values from 1 to 6.

A good way to start is to write a simple loop that prints
the multiples of 2, all on one line.

\begin{verbatim}
    int i = 1;
    while (i <= 6) {
      System.out.print(2*i + "   ");
      i = i + 1;
    }
    System.out.println("");
\end{verbatim}
%
The first line initializes a variable named {\tt i}, which is going
to act as a counter, or {\bf loop variable}.  As the loop executes,
the value of {\tt i} increases from 1 to 6; when {\tt i} is 7, the
loop terminates.  Each time through the loop, we print the value {\tt
  2*i} and three spaces.  Since we use {\tt System.out.print}, 
the output appears on a single line.

\index{loop variable}
\index{variable!loop}

In some environments the
output from {\tt print} gets stored without being displayed until {\tt
println} is invoked.  If the program terminates, and you forget to
invoke {\tt println}, you may never see the stored output.

The output of this program is:

\begin{verbatim}
2   4   6   8   10   12
\end{verbatim}
%
So far, so good.  The next step is to {\bf encapsulate} and {\bf
generalize}.


\section {Encapsulation and generalization}
\label{encapsulation}

Encapsulation means taking a piece of code and wrapping it up
in a method, allowing you to take advantage of all the things methods
are good for.  We have seen two examples of encapsulation, when we
wrote {\tt printParity} in Section~\ref{alternative} and {\tt
isSingleDigit} in Section~\ref{boolean}.

Generalization means taking something specific, like printing
multiples of 2, and making it more general, like printing the
multiples of any integer.

\index{encapsulation}
\index{generalization}

Here's a method that encapsulates the loop from the previous
section and generalizes it to print multiples of {\tt n}.

\begin{verbatim}
  public static void printMultiples(int n) {
    int i = 1;
    while (i <= 6) {
      System.out.print(n*i + "   ");
      i = i + 1;
    }    
    System.out.println("");
  }
\end{verbatim}
%
To encapsulate, all I had to do was add the first line,
which declares the name, parameter,
and return type.  To generalize, all I had to do was replace
the value 2 with the parameter {\tt n}.

If I invoke this method with the argument 2, I get the same
output as before.  With argument 3, the output is:

\begin{verbatim}
3   6   9   12   15   18
\end{verbatim}
%
and with argument 4, the output is

\begin{verbatim}
4   8   12   16   20   24 
\end{verbatim}
%
By now you can probably guess how we are going to print a
multiplication table: we'll invoke {\tt printMultiples} repeatedly with
different arguments.  In fact, we are going to use another loop to
iterate through the rows.

\begin{verbatim}
    int i = 1;
    while (i <= 6) {
      printMultiples(i);
      i = i + 1;
    }    
\end{verbatim}
%
First of all, notice how similar this loop is to the one inside {\tt
printMultiples}.  All I did was replace the print statement with a
method invocation.

The output of this program is

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
\end{verbatim}
%
which is a (slightly sloppy) multiplication table.  If the
sloppiness bothers you, Java provides methods that give you
more control over the format of the output, but I'm not
going to get into that here.


\section{Methods}
\label{methods}
\index{method}

In the Section~\ref{adding_methods} I listed some of the
reasons methods are useful.  Here are more:

\begin{itemize}

\item By giving a name to a sequence of statements, you make
your program easier to read and debug.

\item Dividing a long program into methods allows you to
separate parts of the program, debug them in isolation, and
then compose them into a whole.

\item Methods facilitate both recursion and iteration.

\item Well-designed methods are often useful for many programs.
Once you write and debug one, you can reuse it.

\end{itemize}


\section{More encapsulation}
\index{encapsulation}

To demonstrate encapsulation again, I'll take the code
from the previous section and wrap it up in a method:

\begin{verbatim}
  public static void printMultTable() {
    int i = 1;
    while (i <= 6) {
      printMultiples(i);
      i = i + 1;
    }
  }
\end{verbatim}
%
The process I am demonstrating is a common 
development plan.  You develop code gradually by adding
lines to {\tt main} or another method.  When you get
it working, you extract it and wrap it up in a method.

This process is useful because sometimes you don't know
when you start writing exactly how to divide the program into
methods.  This approach lets you design as you go along.


\section{Local variables}
\index{local variable}
\index{variable!local}

You might wonder how we can use the same
variable {\tt i} in both {\tt printMultiples} and {\tt
printMultTable}.  Didn't I say that you can only declare a variable
once?  And doesn't it cause problems when one of the methods changes
the value of the variable?

The answer to both questions is ``no,'' because the {\tt i} in {\tt
printMultiples} and the {\tt i} in {\tt printMultTable} are
{\em not the same variable}.  They have the same name, but
they do not refer to the same storage location, and changing
the value of one has no effect on the other.

Variables declared inside a method definition are
called {\bf local variables} because they only exist inside
the method.  You cannot access a local variable from outside
its ``home'' method, and you are free to have multiple
variables with the same name, as long as they are not in
the same method.

Although it can be confusing, there are good
reasons to reuse names.  For example, it is common to
use the names {\tt i}, {\tt j} and {\tt k} as loop variables.
If you avoid using them in one method just because you
used them somewhere else, you make the program
harder to read.

\index{loop variable}
\index{variable!loop}

\section{More generalization}
\index{generalization}

As another example of generalization, imagine you wanted
a program that would print a multiplication table of any
size, not just the 6x6 table.  You could add a parameter to
{\tt printMultTable}:

\begin{verbatim}
  public static void printMultTable(int high) {
    int i = 1;
    while (i <= high) {
      printMultiples(i);
      i = i + 1;
    }
  }
\end{verbatim}
%
I replaced the value 6 with the parameter {\tt high}.  If I
invoke {\tt printMultTable} with the argument 7, I get

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
7   14   21   28   35   42   
\end{verbatim}
%
which is fine, except that I probably want the table to
be square (same number of rows and columns), which means
I have to add another parameter to {\tt printMultiples},
to specify how many columns the table should have.

I also call this parameter {\tt high},
demonstrating that different methods can have parameters
with the same name (just like local variables):

\begin{verbatim}
  public static void printMultiples(int n, int high) {
    int i = 1;
    while (i <= high) {
      System.out.print(n*i + "   ");
      i = i + 1;
    }    
    newLine();
  }

  public static void printMultTable(int high) {
    int i = 1;
    while (i <= high) {
      printMultiples(i, high);
      i = i + 1;
    }
  }
\end{verbatim}
%
Notice that when I added a new parameter, I had to change the first
line of the method (the interface or prototype), and I also had to
change the place where the method is invoked in {\tt printMultTable}.
As expected, this program generates a square 7x7 table:

\begin{verbatim}
1   2   3   4   5   6   7   
2   4   6   8   10   12   14   
3   6   9   12   15   18   21   
4   8   12   16   20   24   28   
5   10   15   20   25   30   35   
6   12   18   24   30   36   42   
7   14   21   28   35   42   49
\end{verbatim}
%
When you generalize a method appropriately, you often find
that it has capabilities you did not plan.
For example, you might notice that the multiplication table
is symmetric, because $ab = ba$, so all the entries in the
table appear twice.  You could save ink by printing only
half the table.  To do that, you only have to change one
line of {\tt printMultTable}.  Change

\begin{verbatim}
      printMultiples(i, high);
\end{verbatim}
%
to

\begin{verbatim}
      printMultiples(i, i);
\end{verbatim}
%
and you get

\begin{verbatim}
1   
2   4   
3   6   9   
4   8   12   16   
5   10   15   20   25   
6   12   18   24   30   36   
7   14   21   28   35   42   49  
\end{verbatim}
%
I'll leave it up to you to figure out how it works.


\section{Glossary}

\begin{description}

\item[loop:]  A statement that executes repeatedly while
some condition is satisfied.

\item[infinite loop:]  A loop whose condition is always true.

\item[body:]  The statements inside the loop.

\item[iteration:]  One pass through (execution of) the body
of the loop, including the evaluation of the condition.

\item[encapsulate:]  To divide a large complex program into
components (like methods) and isolate the components from
each other (for example, by using local variables).

\item[local variable:]  A variable that is declared inside
a method and that exists only within that method.  Local variables
cannot be accessed from outside their home method, and do not
interfere with any other methods.

\item[generalize:]  To replace something unnecessarily specific
(like a constant value) with something appropriately general
(like a variable or parameter).  Generalization makes code more
versatile, more likely to be reused, and sometimes even easier
to write.

\item[development plan:] A process for developing a program.  In this
  chapter, I demonstrated a style of development based on developing
  code to do simple, specific things, and then encapsulating and
  generalizing.  In Section~\ref{distance} I demonstrated incremental
  development.  In later chapters I will suggest other styles of
  development.

\index{loop}
\index{infinite loop}
\index{loop!infinite}
\index{iteration}
\index{encapsulation}
\index{generalization}
\index{local variable}
\index{variable!local}
\index{program development}

\end{description}


\section{Exercises}

\begin{exercise}\label{infloop}

\begin{verbatim}
public static void main(String[] args) {
    loop(10);
}

public static void loop(int n) {
    int i = n;
    while (i > 0) {
        System.out.println(i);
        if (i%2 == 0) {
            i = i/2;
        } else {
            i = i+1;
        }
    }
}
\end{verbatim}
%
\begin{enumerate}

\item Draw a table that shows the value of the variables {\tt i}
and {\tt n} during the execution of {\tt loop}.  The table should
contain one column for each variable and one line for each
iteration.

\item What is the output of this program?  

\end{enumerate}
\end{exercise}


\begin{exercise}
Let's say you are given a number, $a$, and you want to find
its square root.  One way to do that is to start with a very
rough guess about the answer, $x_0$, and then improve
the guess using the following formula:

\begin{equation}
x_1 =(x_0 + a/x_0) / 2
\end{equation}

For example, if we want to find the square root of 9, and
we start with $x_0 = 6$, then $x_1 =(6 + 9/6) /2 = 15/4 = 3.75$,
which is closer.

We can repeat the procedure, using $x_1$ to calculate $x_2$,
and so on.  In this case, $x_2 = 3.075$ and $x_3 = 3.00091$.
So that is converging very quickly on the right answer(which
is 3).

Write a method called {\tt squareRoot} that takes a {\tt double}
as a parameter and that returns an approximation of the square
root of the parameter, using this technique.  You may not use
{\tt Math.sqrt}.

As your initial guess, you should use $a/2$.  Your method should
iterate until it gets two consecutive estimates that differ by less
than 0.0001; in other words, until the absolute value of $x_n -
x_{n-1}$ is less than 0.0001.  You can use {\tt Math.abs} to calculate
the absolute value.
\end{exercise}


\begin{exercise}
In Exercise~\ref{ex.power} we wrote a recursive version of {\tt
power}, which takes a double {\tt x} and an integer {\tt n} and
returns $x^n$.  Now write an iterative method to perform the same
calculation.
\end{exercise}

\begin{exercise}
Section~\ref{factorial} presents a recursive method
that computes the factorial function.
Write an iterative version of {\tt factorial}.
\end{exercise}

\begin{exercise}
One way to calculate $e^x$ is to use the infinite series expansion

\begin{equation}
e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + ...
\end{equation}

If the loop variable is named {\tt i}, then the $i$th term is
$x^i / i!$.

\begin{enumerate}

\item Write a method called {\tt myexp} that adds up the first {\tt n}
terms of this series.  You can use the {\tt factorial}
method from Section~\ref{factorial} or your iterative version from the
previous exercise.

\item You can make this method much more efficient if you realize that
in each iteration the numerator of the term is the same as its
predecessor multiplied by {\tt x} and the denominator is the same as
its predecessor multiplied by {\tt i}.  Use this observation to
eliminate the use of {\tt Math.pow} and {\tt factorial}, and check
that you still get the same result.

\item Write a method called {\tt check} that takes a single parameter,
{\tt x}, and that prints the values of {\tt x}, {\tt Math.exp(x)} and
{\tt myexp(x)} for various values of {\tt x}.  The output should look
something like:

\begin{verbatim}
1.0     2.708333333333333       2.718281828459045
\end{verbatim}

%the next line used to use \\ in an attempt to escape the backslash character
%but this doesn't work: \\ produces a newline
%according to the LaTeX symbol list
%http://www.tex.ac.uk/tex-archive/info/symbols/comprehensive/symbols-letter.pdf
%\textbackslash is the actual way to escape a backslash
%(but it seems not to respect the \tt font)
HINT: you can use the String {\tt "\textbackslash t"} to print a tab character
between columns of a table.

\item Vary the number of terms in the series(the second argument
that {\tt check} sends to {\tt myexp}) and see the effect on
the accuracy of the result.  Adjust this value until the estimated
value agrees with the ``correct'' answer when {\tt x} is 1.

\item Write a loop in {\tt main} that invokes {\tt check} with the
values 0.1, 1.0, 10.0, and 100.0.  How does the accuracy of the
result vary as {\tt x} varies?  Compare the number of digits of
agreement rather than the difference between the actual and
estimated values.

\item Add a loop in {\tt main} that checks {\tt myexp} with the values
-0.1, -1.0, -10.0, and -100.0.  Comment on the accuracy.

\end{enumerate}
\end{exercise}


\begin{exercise}
One way to evaluate $e^{-x^2}$ is to use the infinite series expansion

\begin{equation}
e^{-x^2} = 1 - x^2 + x^4/6 - x^6/24 + ...
\end{equation}

In other words, we need to add up a series of terms where the $i$th
term is equal to $(-1)^i x^{2i} / i!$.  Write a method named {\tt gauss}
that takes {\tt x} and {\tt n} as arguments and that returns the sum
of the first {\tt n} terms of the series.  You should not use {\tt
factorial} or {\tt pow}.
\end{exercise}


\beforechapter
\chapter{Strings and things}
\label{chap07}
\label{strings}

\section{Invoking methods on objects}
\index{method!string}
\index{String method}
\index{method!object}
\index{object method}
\index{class!String}

In Java and other object-oriented languages, objects are collections
of related data that come with a set of methods.  These methods
operate on the objects, performing computations and sometimes
modifying the object's data.

{\tt Strings} are objects,
so you might ask ``What is the data
contained in a {\tt String} object?'' and ``What are the methods we
can invoke on {\tt String} objects?''

\index{documentation}
\index{Sun}

The data in a {\tt String} object are letters or, more generally,
characters.  Not all characters are letters; some are numbers,
symbols, and other things altogether.  But for simplicity I
call them letters.

There are many methods, but I use only a few in this
book.  The rest are documented at
\url{http://download.oracle.com/javase/6/docs/api/java/lang/String.html}.

The first method we will look at is {\tt charAt}, which allows you to
extract letters from a {\tt String}.  In order to store the result, we
need a new type: {\tt char} is the variable type that can store
individual characters (as opposed to strings).

\index{char}
\index{type!char}
\index{charAt}

{\tt char}s work just like the other types we have seen:

\begin{verbatim}
    char bob = 'c';
    if (bob == 'c') {
      System.out.println(bob);
    }
\end{verbatim}
%
Character values appear in single quotes, like {\tt 'c'}.  Unlike
string values (which appear in double quotes), character values
can contain only a single letter or symbol.

\index{quote}
\index{double-quote}
\index{value!char}

Here's how the {\tt charAt} method is used:

\begin{verbatim}
    String fruit = "banana";
    char letter = fruit.charAt(1);
    System.out.println(letter);
\end{verbatim}
%
{\tt fruit.charAt()} means that I am 
invoking the {\tt charAt} method on the object named
{\tt fruit}.
I am passing the argument {\tt 1} to this method,
which means that I want to know the first letter of
the string.  The result is a character, which is stored in a
{\tt char} named {\tt letter}.  When I print the value of
{\tt letter}, I get a surprise:

\begin{verbatim}
a
\end{verbatim}
%
{\tt a} is not the first letter of {\tt "banana"}.  Unless you are a
computer scientist.  For perverse reasons, computer scientists
start counting from zero.  The 0th letter (``zeroeth'') of {\tt
"banana"} is {\tt b}.  The 1th letter (``oneth'') is {\tt a} and the
2th (``twooth'') letter is {\tt n}.

If you want the zereoth letter of a string, you have to pass
0 as an argument:

\begin{verbatim}
    char letter = fruit.charAt(0);
\end{verbatim}


\section{Length}
\index{String!length}
\index{length!String}

The next {\tt String} method we'll look at is {\tt length}, which
returns the number of characters in the string.  For example:

\begin{verbatim}
    int length = fruit.length();
\end{verbatim}
%
{\tt length} takes no arguments
and returns an integer, in this case 6.  Notice that it is
legal to have a variable with the same name as a method (although
it can be confusing for human readers).

To find the last letter of a string, you might be tempted to
try something like

\begin{verbatim}
    int length = fruit.length();
    char last = fruit.charAt(length);       // WRONG!!
\end{verbatim}
%
That won't work.  The reason is that there is no 6th letter
in {\tt "banana"}.  Since we started counting at 0, the 6
letters are numbered from 0 to 5.  To get the last character,
you have to subtract 1 from {\tt length}.

\begin{verbatim}
    int length = fruit.length();
    char last = fruit.charAt(length-1);
\end{verbatim}


\section{Traversal}
\label{traverse}
\index{traverse}

A common thing to do with a string is
start at the beginning, select each character in turn, do
some computation with it, and continue until the end.  This pattern
of processing is called a {\bf traversal}.  A natural
way to encode a traversal is with a {\tt while} statement:

\begin{verbatim}
    int index = 0;
    while (index < fruit.length()) {
      char letter = fruit.charAt(index);
      System.out.println(letter);
      index = index + 1;
    }
\end{verbatim}
%
This loop traverses the string and prints each letter on
a line by itself.  Notice that the condition is
{\tt index < fruit.length()}, which means that when
{\tt index} is equal to the length of the string, the
condition is false and the body of the loop is not executed.
The last character we access is the one with the
index {\tt fruit.length()-1}.

\index{loop variable}
\index{variable!loop}
\index{index}

The name of the loop variable is {\tt index}.  An {\bf
index} is a variable or value used to specify a member of an ordered
set, in this case the string of characters.  The index
indicates (hence the name) which one you want.

As an exercise, write a method that takes a {\tt String}
as an argument and that prints the letters backwards, all on
one line.


\section{Run-time errors}
\index{error!run-time}
\index{run-time error}
\index{exception!StringIndexOutOfBounds}

Way back in Section~\ref{run-time} I talked about run-time errors,
which are errors that don't appear until a program has started
running.  In Java run-time errors are called {\bf exceptions}.

You probably haven't seen many run-time errors, because we
haven't been doing many things that can cause one.  Well, now we are.
If you use the {\tt charAt} method and provide an index that is
negative or greater than {\tt length-1}, you will get an exception:
specifically, a {\tt StringIndexOutOfBoundsException}.  Try it
and see how it looks.

If your program causes an exception, it prints an error message
indicating the type of exception and where in the program it
occurred.  Then the program terminates.


\section{Reading documentation}
\index{documentation}

If you go to
\url{http://download.oracle.com/javase/6/docs/api/java/lang/String.html}.
and click on {\tt charAt}, you get the following documentation
(or something like it):

\begin{verbatim}
public char charAt(int index)

Returns the char value at the specified index. An index ranges from 0
to length() - 1. The first char value of the sequence is at index 0,
the next at index 1, and so on, as for array indexing.

Parameters: index - the index of the char value.

Returns: the char value at the specified index of this string. The
  first char value is at index 0.

Throws: IndexOutOfBoundsException - if the index argument is negative
  or not less than the length of this string.
\end{verbatim}
%
The first line is the method's {\bf prototype}, which indicates the
name of the method, the type of the parameters, and the return type.

The next line describes what the method does.  The following
lines explain the parameters and return values.  In this case
the explanations are a bit redundant, but the documentation is
supposed to fit a standard format.  The last line explains what
exceptions, if any, can be caused by this method.

It might take some time to get 
comfortable with this kind of documentation, but it is worth the effort.


\section{The {\tt indexOf} method}
\index{indexOf}

{\tt indexOf} is the inverse of {\tt charAt}:
{\tt charAt} takes an index and returns the character at that
index;  {\tt indexOf} takes a character and finds the index
where that character appears.

{\tt charAt} fails if the index is out of range, and causes an
exception.  {\tt indexOf} fails if the character does not appear in
the string, and returns the value {\tt -1}.

\begin{verbatim}
    String fruit = "banana";
    int index = fruit.indexOf('a');
\end{verbatim}
%
This finds the index of the letter {\tt 'a'} in the string.
In this case, the letter appears three times, so it is not
obvious what {\tt indexOf} should do.  According to the
documentation, it returns the index of the {\em first} appearance.

In order to find subsequent appearances, there is another
version of {\tt indexOf}.  It takes a
second argument that indicates where in the string to start
looking.  For an explanation of this kind
of overloading, see Section~\ref{overloading}.

If we invoke:

\begin{verbatim}
    int index = fruit.indexOf('a', 2);
\end{verbatim}
%
it starts at the twoeth letter (the first {\tt n}) and finds
the second {\tt a}, which is at index 3.  If the letter happens
to appear at the starting index, the starting index is the
answer.  So

\begin{verbatim}
    int index = fruit.indexOf('a', 5);
\end{verbatim}
%
returns 5.  


\section{Looping and counting}
\label{loopcount}
\index{traverse!counting}
\index{loop!counting}

The following program counts the
number of times the letter {\tt 'a'} appears in a string:

\begin{verbatim}
    String fruit = "banana";
    int length = fruit.length();
    int count = 0;

    int index = 0;
    while (index < length) {
      if (fruit.charAt(index) == 'a') {
        count = count + 1;
      }
      index = index + 1;
    }
    System.out.println(count);
\end{verbatim}
%
This program demonstrates a common idiom, called a {\bf counter}.  The
variable {\tt count} is initialized to zero and then incremented each
time we find an {\tt 'a'} (to {\bf increment} is to increase by one;
it is the opposite of {\bf decrement}, and unrelated to {\bf
excrement}, which is a noun).  When we exit the loop, {\tt count}
contains the result: the total number of a's.

\index{counter}
\index{increment}
\index{decrement}

As an exercise, encapsulate this code in a method named
{\tt countLetters}, and generalize it so that it accepts the
string and the letter as arguments.

\index{encapsulation}
\index{generalization}

As a second exercise, rewrite the method so that it uses
{\tt indexOf} to locate the a's, rather than checking
the characters one by one.


\section{Increment and decrement operators}
\index{operator!increment}
\index{operator!decrement}

Incrementing and decrementing are such common operations that
Java provides special operators for them.  The {\tt ++}
operator adds one to the current value of an {\tt int} or
{\tt char}.  {\tt --} subtracts one.  Neither operator works
on {\tt double}s, {\tt boolean}s or {\tt String}s.

Technically, it is legal to increment a variable and use it
in an expression at the same time.  For example, you might see
something like:

\begin{verbatim}
    System.out.println(i++);
\end{verbatim}
%
Looking at this, it is not clear whether the increment will
take effect before or after the value is printed.  Because
expressions like this tend to be confusing, I discourage
you from using them.  In fact, to discourage you even more,
I'm not going to tell you what the result is.  If you really
want to know, you can try it.

Using the increment operators, we can rewrite the letter-counter:

\begin{verbatim}
    int index = 0;
    while (index < length) {
      if (fruit.charAt(index) == 'a') {
        count++;
      }
      index++;
    }
\end{verbatim}
%
It is a common error to write something like

\begin{verbatim}
    index = index++;             // WRONG!!
\end{verbatim}
%
Unfortunately, this is syntactically legal, so the compiler
will not warn you.  The effect of this statement is to leave
the value of {\tt index} unchanged.  This is often a difficult
bug to track down.

Remember, you can write {\tt index = index+1}, or you
can write {\tt index++}, but you shouldn't mix them.

% \section{Character arithmetic}
% \index{char}
% \index{type!char}
% \index{operator!char}
% \index{arithmetic!char}

% It may seem odd, but you can do arithmetic with characters.
% If you have a variable named {\tt letter} that contains a character,
% then {\tt letter - 'a'} will tell you where in the alphabet it appears
%(keeping in mind that 'a' is the zeroeth letter of the alphabet and
% 'z' is the 25th).

% This sort of thing is useful for converting between the characters
% that contain numbers, like '0', '1' and '2', and the corresponding
% integers.  They are not the same thing.  For example, if you try this

% \begin{verbatim}
%     char letter = '3';
%     int x =(int) letter;
%     System.out.println(x);
% \end{verbatim}
% %
% you might expect the value 3, but depending on your environment,
% you might get 51, which is the ASCII code that is used to
% represent the character '3', or you might get something else
% altogether.  To convert '3' to the corresponding integer value
% you can subtract '0':

% \begin{verbatim}
%     int x =(int)(letter - '0');
% \end{verbatim}
% %
% Technically, in both of these examples the typecast({\tt(int)}) is
% unnecessary, since Java will convert type {\tt char} to type {\tt int}
% automatically.  I included the typecasts to emphasize the difference
% between the types, and because I'm a stickler about that sort of
% thing.

% Since this conversion can be a little ugly, it is preferable to use
% the {\tt digit} method in the {\tt Character} class.  For example:

% \begin{verbatim}
%     int x = Character.digit(letter, 10);
% \end{verbatim}
% %
% converts {\tt letter} to the corresponding digit, interpreting
% it as a base 10 number.

% Another use for character arithmetic is to loop through the letters of
% the alphabet in order.  For example, in Robert McCloskey's book {\em
% Make Way for Ducklings}, the names of the ducklings form an
% abecedarian series: Jack, Kack, Lack, Mack, Nack, Ouack, Pack and
% Quack.  Here is a loop that prints these names in order:

% \begin{verbatim}
%     char letter = 'J';
%     while (letter <= 'Q') {
 %      System.out.println(letter + "ack");
 %      letter++;
%     }
% \end{verbatim}
%
% Notice that in addition to the arithmetic operators, we can also
% use the conditional operators on characters.  The output of this
% program is:

% \begin{verbatim}
% Jack
% Kack
% Lack
% Mack
% Nack
% Oack
% Pack
% Qack
% \end{verbatim}
% %
% Of course, that's not quite right because I've misspelled ``Ouack''
% and ``Quack.''  As an exercise, modify the program to correct
% this error.


\section{{\tt String}s are immutable}
\label{immutable}
\index{class!String}
\index{immutable}
\index{String}
\index{toUpperCase}
\index{toLowerCase}

As you read the documentation of the {\tt String} methods, you
might notice {\tt toUpperCase} and {\tt toLowerCase}.  These
methods are often a source of confusion, because it sounds
like they have the effect of changing (or mutating) an
existing string.  Actually, neither these methods nor any
others can change a string, because strings are {\bf immutable}.

When you invoke {\tt toUpperCase} on a {\tt String}, you get a
{\em new} {\tt String} as a return value.  For example:

\begin{verbatim}
    String name = "Alan Turing";
    String upperName = name.toUpperCase();
\end{verbatim}
%
After the second line is executed, {\tt upperName} contains
the value {\tt "ALAN TURING"}, but {\tt name} still contains
{\tt "Alan Turing"}.
\index{Turing, Alan}


\section{{\tt String}s are incomparable}
\label{incomparable}
\index{class!String}
\index{comparison!String}
\index{String}
\index{equals}
\index{compareTo}

It is often necessary to compare strings to see if they are the same,
or to see which comes first in alphabetical order.  It would be
nice if we could use the comparison operators, like {\tt ==} and
{\tt >}, but we can't.

In order to compare {\tt String}s, we have to use the {\tt equals}
and {\tt compareTo} methods.  For example:

\begin{verbatim}
    String name1 = "Alan Turing";
    String name2 = "Ada Lovelace";

    if (name1.equals (name2)) {
      System.out.println("The names are the same.");
    }

    int flag = name1.compareTo (name2);
    if (flag == 0) {
      System.out.println("The names are the same.");
    } else if (flag < 0) {
      System.out.println("name1 comes before name2.");
    } else if (flag > 0) {
      System.out.println("name2 comes before name1.");
    }
\end{verbatim}
%
The syntax here is a little weird.  To compare two things, you
have to invoke a method on one of them and pass the other
as an argument.

The return value from {\tt equals} is straightforward enough;
{\tt true} if the strings contain the same characters, and
{\tt false} otherwise.

The return value from {\tt compareTo} is a weird, too.  It is
the difference between the first characters in the strings
that differ.  If the strings are equal, it is 0.  If the
first string (the one on which the method is invoked) comes
first in the alphabet, the difference is negative.  Otherwise,
the difference is positive.  In this case the return value
is positive 8, because the second letter of ``Ada'' comes
before the second letter of ``Alan'' by 8 letters.

Using {\tt compareTo} is often tricky, and I never remember
which way is which without looking it up, but the good news
is that the interface is pretty standard for comparing many
types of objects, so once you get it you are all set.

Just for completeness, I should admit that it is
{\em legal}, but very seldom {\em correct}, to use the {\tt ==}
operator with {\tt String}s.  But what that means will not make
sense until later, so for now, don't do it.


\section{Glossary}

\begin{description}

\item[object:] A collection of related data that comes with a set of
methods that operate on it.  The objects we have used so far are
{\tt String}s, Bugs, Rocks, and the other GridWorld objects.

\item[index:]  A variable or value used to select one of the
members of an ordered set, like a character from a string.

\item[traverse:]  To iterate through all the elements of a set
performing a similar operation on each.

\item[counter:]  A variable used to count something, usually
initialized to zero and then incremented.

\item[increment:]  Increase the value of a variable by one.
The increment operator in Java is {\tt ++}.

\item[decrement:]  Decrease the value of a variable by one.
The decrement operator in Java is {\tt --}.

\item[exception:]  A run time error.  Exceptions cause the execution
of a program to terminate.

\index{object}
\index{index}
\index{traverse}
\index{counter}
\index{increment}
\index{decrement}
\index{exception}
\index{run-time error}

\end{description}


\section{Exercises}

\begin{exercise}
The purpose of this exercise is to review encapsulation
and generalization.

\begin{enumerate}

\item Encapsulate the following code fragment, transforming it
into a method that takes a String as an argument and that
returns the final value of {\tt count}.

\item In a sentence or two, describe what the resulting method does
(without getting into the details of how).

\item Now that you have generalized the code
so that it works on any String, what could you do to
generalize it more?

\end{enumerate}

\begin{verbatim}
    String s = "((3 + 7) * 2)";
    int len = s.length();

    int i = 0;
    int count = 0;

    while (i < len) {
        char c = s.charAt(i);

        if (c == '(') {
           count = count + 1;
        } else if (c == ')') {
           count = count - 1;
        }
        i = i + 1;
    }

    System.out.println(count);
\end{verbatim}
\end{exercise}


\begin{exercise}

The point of this exercise is to explore Java types
and fill in some of the details that aren't covered
in the chapter.

\begin{enumerate}

\item Create a new program named {\tt Test.java} and write
a {\tt main} method that contains
expressions that combine
various types using the {\tt +} operator.  For example, what
happens when you ``add'' a {\tt String} and a {\tt char}?
Does it perform addition or concatenation?   What is the type
of the result? (How can you determine the type of the result?)

\item Make a bigger copy of the following table and fill it in.  At the
intersection of each pair of types, you should indicate whether it is
legal to use the {\tt +} operator with these types, what operation is
performed (addition or concatenation), and what the type of the result
is.

\begin{tabular}{|l|l|l|l|l|} \hline
        &  boolean  &  char  &  int  &  String \\ \hline
boolean &           &        &       &         \\ \hline
char    &           &        &       &         \\ \hline
int     &           &        &       &         \\ \hline
String  &           &        &       &         \\ \hline
\end{tabular}

\item Think about some of the choices the designers of Java
made when they filled in this table.  How many of the entries
seem unavoidable, as if there were no other choice?
How many seem like arbitrary choices from several equally
reasonable possibilities?  How many seem stupid?

\item Here's a puzzler: normally, the statement {\tt x++} is exactly
  equivalent to {\tt x = x + 1}.  But if {\tt x} is a {\tt char}, it's
  not!  In that case, {\tt x++} is legal, but {\tt x = x + 1} causes
  an error.  Try it out and see what the error message is, then see if
  you can figure out what is going on.

\end{enumerate}
\end{exercise}


\begin{exercise}

What is the output of this program?  Describe in a sentence
what {\tt mystery} does (not how it works).

\begin{verbatim}
public class Mystery {

    public static String mystery(String s) {
        int i = s.length() - 1;
        String total = "";

        while (i >= 0 ) {
            char ch = s.charAt(i);
            System.out.println(i + "     " + ch);

            total = total + ch;
            i--;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(mystery("Allen"));
    }
}
\end{verbatim}

\end{exercise}


\begin{exercise}
A friend of yours shows you the following method and
explains that if {\tt number} is any two-digit number, the program
will output the number backwards.  He claims that if {\tt number} is
17, the method will output {\tt 71}.

Is he right?  If not, explain what the program actually does and
modify it so that it does the right thing.

\begin{verbatim}
     int number = 17;
     int lastDigit = number%10;
     int firstDigit = number/10;
     System.out.println(lastDigit + firstDigit);
\end{verbatim}

\end{exercise}

\begin{exercise}
What is the output of the following program?

\begin{verbatim}
public class Enigma {

    public static void enigma(int x) {
        if (x == 0) {
            return;
        } else {
            enigma(x/2);
        } 

        System.out.print(x%2);
    }

    public static void main(String[] args) {
        enigma(5);
        System.out.println("");
    }
}
\end{verbatim}

Explain in 4-5 words what the method {\tt enigma} really does.
\end{exercise}


\begin{exercise}
\begin{enumerate}

\item Create a new program named {\tt Palindrome.java}.

\item Write a method named {\tt first}
that takes a String and returns the first letter, and one named
{\tt last} that returns the last letter.

\item Write a method named {\tt middle} that takes a String and
returns a substring that contains everything {\em except} the
first and last characters.

Hint: read the documentation of the {\tt substring} method in
the {\tt String} class.
Run a few tests to make sure you understand how {\tt substring} works
before you try to write {\tt middle}.

What happens if you invoke {\tt middle} on a string that has only
two letters?  One letter?  No letters?

\item The usual definition of a palindrome is a word that reads the
same both forward and backward, like ``otto'' and
``palindromeemordnilap.''  An alternative way to define a property
like this is to specify a way of testing for the property.  For
example, we might say, ``a single letter is a palindrome, and a
two-letter word is a palindrome if the letters are the same, and
any other word is a palindrome if
the first letter is the same as the
last and the middle is a palindrome.''

Write a recursive method named {\tt isPalindrome} that takes
a {\tt String} and that returns a boolean indicating whether the
word is a palindrome or not.

\item Once you have a working palindrome checker, look for ways
to simplify it by reducing the number of conditions you check.
Hint: it might be useful to adopt the definition that the empty
string is a palindrome.

\item On a piece of paper, figure out a strategy for checking
palindromes iteratively.  There are several possible approaches,
so make sure you have a solid plan before you start writing code.

\item Implement your strategy in a method called {\tt isPalindromeIter}.

\item Optional: Appendix~\ref{javaio} provides code for reading a list
of words from a file.  Read a list of words and print the palindromes.

\end{enumerate}
\end{exercise}


\begin{exercise}
A word is said to be ``abecedarian'' if the letters in the
word appear in alphabetical order.  For example, the following
are all 6-letter English abecedarian words.

\begin {quote}
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint,
beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort,
deinos, diluvy, dimpsy
\end{quote}

\begin{enumerate}

\item Describe a process for checking whether a given word (String)
is abecedarian, assuming that the word contains only lower-case
letters.  Your process can be iterative or recursive.

\item Implement your process in a method called {\tt isAbecedarian}.

\end{enumerate}
\end{exercise}


\begin{exercise}
A dupledrome is a word that contains only double letters,
like ``llaammaa'' or ``ssaabb''.  I conjecture that there
are no dupledromes in common English use.  To test that
conjecture, I would like a program that reads
words from the dictionary one at a time and checks them for
dupledromity.

Write a method called {\tt isDupledrome} that takes a String
and returns a boolean indicating whether the word is a dupledrome.
\end{exercise}



\begin{exercise}
\begin{enumerate}

\item The Captain Crunch decoder ring works by taking each letter in a
string and adding 13 to it.  For example, 'a' becomes 'n' and 'b'
becomes 'o'.  The letters ``wrap around'' at the end, so 'z' becomes
'm'.

Write a method that takes a String and that returns a new String
containing the encoded version.  You should assume that the String
contains upper and lower case letters, and spaces, but no other
punctuation.  Lower case letters should be tranformed into other lower
case letters; upper into upper.  You should not encode the spaces.

\item Generalize the Captain Crunch method so that instead of adding
13 to the letters, it adds any given amount.  Now you should be able
to encode things by adding 13 and decode them by adding -13.  Try it.

\end{enumerate}
\end{exercise}


\begin{exercise}

If you did the GridWorld exercises in Chapter~\ref{gridworld}, you
might enjoy this exercise.  The goal is to use trigonometry to get the
Bugs to chase each other.

Make a copy of {\tt BugRunner.java} named {\tt ChaseRunner.java} and
import it into your development environment.  Before you change
anything, check that you can compile and run it.

\begin{itemize}

\item Create two Bugs, one red and one blue.

\item Write a method called {\tt distance} that takes two Bugs
and computes the distance between them.  Remember that you can
get the x-coordinate of a Bug like this:

\begin{verbatim}
    int x = bug.getLocation().getCol();
\end{verbatim}

\item Write a method called {\tt turnToward} that takes two
Bugs and turns one to face the other.  HINT: use {\tt Math.atan2},
but remember that the result is in radians, so you have to
convert to degrees.  Also, for Bugs, 0 degress is North, not East.

\item Write a method called {\tt moveToward} that takes two
Bugs, turns the first to face the second, and then moves the
first one, if it can.

\item Write a method called {\tt moveBugs} that takes two Bugs
and an integer {\tt n}, and moves each Bug toward the other {\tt n}
times.  You can write this method recursively, or use a while loop.

\item Test each of your methods as you develop them.  When they are
  all working, look for opportunities to improve them.  For example,
  if you have redundant code in {\tt distance} and {\tt turnToward},
  you could encapsulate the repeated code in a method.

\end{itemize}

\end{exercise}




\beforechapter
\chapter{Mutable objects}
\label{chap08}
\label{objects}
\index{object}


\section{{\tt Point}s and {\tt Rectangle}s}
\index{String}
\index{type!String}

Although {\tt String}s are objects, they are not very interesting,
because

\begin{itemize}

\item They are immutable.

\item They have no attributes.

\item You don't have to use {\tt new} to create one.

\end{itemize}

In this chapter, we use two objects from the Java libraries,
 {\tt Point} and {\tt Rectangle}.
But first, I want to make it clear that these points
and rectangles are not graphical objects that appear on the
screen.  They are values that contain data, just like {\tt int}s
and {\tt double}s.  Like other values, they are used internally
to perform computations.


\section{Packages}
\index{package}
\index{AWT}
\index{Abstract Window Toolkit|see {AWT}}
\index{import}
\index{statement!import}

The Java libraries are divided into a number of {\bf
packages}, including {\tt java.lang}, which contains almost all of the
classes we have seen so far, and {\tt java.awt}, which contains
classes that pertain to the Java {\bf Abstract Window Toolkit} (AWT),
which contains classes for windows, buttons, graphics, etc.

In order to use a class defined in another package, you have to {\bf
  import} it.  {\tt Point} and {\tt Rectangle} are in the
{\tt java.awt} package, so to import them we need:

\begin{verbatim}
    import java.awt.Point;
    import java.awt.Rectangle;
\end{verbatim}

All {\tt import} statements appear at the beginning of the program,
outside the class definition.

The classes in {\tt java.lang}, like {\tt Math} and {\tt String} are
imported automatically, which is why most of our programs haven't
required an {\tt import} statement.


\section{{\tt Point} objects}
\index{Point}
\index{class!Point}

A point is two numbers (coordinates)
that we treat collectively as a single object.  In mathematical
notation, points are often written in parentheses, with a comma
separating the coordinates.  For example, $(0, 0)$ indicates
the origin, and $(x, y)$ indicates the point $x$ units to the
right and $y$ units up from the origin.

\index{new}
\index{statement!new}

In Java, a point is represented by a {\tt Point} object.  To
create a new point, you have to use {\tt new}:

\begin{verbatim}
    Point blank;
    blank = new Point(3, 4);
\end{verbatim}
% 
The first line is a conventional variable declaration: {\tt blank}
has type {\tt Point}.  The second line invokes {\tt new}, specifies
the type of the new object, and provides arguments.  The arguments are
the coordinates of the new point, $(3, 4)$.

\index{declaration}
\index{statement!declaration}
\index{reference}
\index{state diagram}
\index{state}

The result of {\tt new} is a {\bf reference} to the new
point, so {\tt blank} contains a reference to the
newly-created object.  There is a standard way to diagram this
assignment, shown in the figure.


\myfig{figure=figs/reference.eps}


As usual, the name of the variable {\tt blank} appears outside the box
and its value appears inside the box.  In this case, that value is a
reference, which is shown graphically with an arrow.  The
arrow points to the object we're referring to.

The big box shows the newly-created object with the two values
in it.  The names {\tt x} and {\tt y} are the names of the {\bf
instance variables}.

Taken together, all the variables, values, and objects in a
program are called the {\bf state}.  Diagrams like this that
show the state of the program are called {\bf state diagrams}.
As the program runs, the state changes, so you should think
of a state diagram as a snapshot of a particular point in the
execution.


\section{Instance variables}
\index{variable!instance}
\index{instance variable}

The pieces of data that make up an object are called instance
variables because each object, which is an {\bf instance} of its
type, has its own copy of the instance variables.

It's like the glove compartment of a car.  Each car is an instance
of the type ``car,'' and each car has its own glove compartment.  If
you ask me to get something from the glove compartment of your car,
you have to tell me which car is yours.

\index{dot notation}

Similarly, if you want to read a value from an instance variable, you
have to specify the object you want to get it from.  In Java this is
done using ``dot notation.''

\begin{verbatim}
    int x = blank.x;
\end{verbatim}
%
The expression {\tt blank.x} means ``go to the object {\tt blank}
refers to, and get the value of {\tt x}.''  In this case we assign
that value to a local variable named {\tt x}.  There is no
conflict between the local variable named {\tt x} and the instance
variable named {\tt x}.  The purpose of dot notation is to identify
{\em which} variable you are referring to unambiguously.

You can use dot notation as part of any Java expression, so the
following are legal.

\begin{verbatim}
    System.out.println(blank.x + ", " + blank.y);
    int distance = blank.x * blank.x + blank.y * blank.y;
\end{verbatim}
%
The first line prints {\tt 3, 4}; the second line calculates
the value 25.

\section{Objects as parameters}
\index{parameter}
\index{object!as parameter}

You can pass objects as parameters in the usual way.  For
example:

\begin{verbatim}
  public static void printPoint(Point p) {
    System.out.println("(" + p.x + ", " + p.y + ")");
  }
\end{verbatim}
%
This method takes a point as an argument and prints it in
the standard format.  If you invoke {\tt printPoint(blank)},
it prints {\tt(3, 4)}.  Actually, Java already has a
method for printing {\tt Points}.  If you invoke
{\tt System.out.println(blank)}, you get

\begin{verbatim}
java.awt.Point[x=3,y=4]
\end{verbatim}
% 
This is a standard format Java uses for printing objects.  It prints
the name of the type, followed by the names and values of the instance
variables.

As a second example, we can rewrite the {\tt distance} method from
Section~\ref{distance} so that it takes two {\tt Point}s as parameters
instead of four {\tt double}s.

\begin{verbatim}
  public static double distance(Point p1, Point p2) {
    double dx = (double)(p2.x - p1.x);
    double dy = (double)(p2.y - p1.y);
    return Math.sqrt(dx*dx + dy*dy);
  }
\end{verbatim}
%
The typecasts are not really necessary; I added them as a
reminder that the instance variables in a {\tt Point} are integers.


\section{Rectangles}
\index{Rectangle}
\index{class!Rectangle}

{\tt Rectangle}s are similar to points, except that they have four
instance variables: {\tt x}, {\tt y}, {\tt width} and {\tt
height}.  Other than that, everything is pretty much the same.

This example
creates a {\tt Rectangle} object and makes {\tt box} refer to it.

\begin{verbatim}
    Rectangle box = new Rectangle(0, 0, 100, 200);
\end{verbatim}
%
This figure shows the effect of this assignment.


\myfig{figure=figs/rectangle.eps}

%
If you print {\tt box}, you get

\begin{verbatim}
java.awt.Rectangle[x=0,y=0,width=100,height=200]
\end{verbatim}
%
Again, this is the result of a Java method that knows how
to print {\tt Rectangle} objects.


\section{Objects as return types}
\index{object!as return type}
\index{return}
\index{statement!return}

You can write methods that return objects.  For example,
{\tt findCenter} takes a {\tt Rectangle} as an argument and
returns a {\tt Point} that contains the coordinates of the
center of the {\tt Rectangle}:

\begin{verbatim}
  public static Point findCenter(Rectangle box) {
    int x = box.x + box.width/2;
    int y = box.y + box.height/2;
    return new Point(x, y);
  }
\end{verbatim}
%
Notice that you can use {\tt new} to create a new object,
and then immediately use the result as a return value.


\section{Objects are mutable}
\index{object!mutable}
\index{mutable}

You can change the contents of an object by making an assignment
to one of its instance variables.  For example, to ``move''
a rectangle without changing its size, you can modify the
{\tt x} and {\tt y} values:

\begin{verbatim}
    box.x = box.x + 50;
    box.y = box.y + 100;
\end{verbatim}
%
The result is shown in the figure:


\myfig{figure=figs/rectangle2.eps}


\index{encapsulation}
\index{generalization}

We can encapsulate this code in a method and
generalize it to move the rectangle by any amount:

\begin{verbatim}
  public static void moveRect(Rectangle box, int dx, int dy) {
    box.x = box.x + dx;
    box.y = box.y + dy;
  }
\end{verbatim}
%
The variables {\tt dx} and {\tt dy} indicate how far to move the
rectangle in each direction.  Invoking this method has the effect of
modifying the {\tt Rectangle} that is passed as an argument.

\begin{verbatim}
    Rectangle box = new Rectangle(0, 0, 100, 200);
    moveRect(box, 50, 100);
    System.out.println(box);
\end{verbatim}
%
prints {\tt java.awt.Rectangle[x=50,y=100,width=100,height=200]}.

Modifying objects by passing them as arguments to methods can be
useful, but it can also make debugging more difficult because it is
not always clear which method invocations do or do not modify their
arguments.  Later, I will discuss some pros and cons of this
programming style.

Java provides methods that operate on Points and Rectangles.  You can
read the documentation at
\url{http://download.oracle.com/javase/6/docs/api/java/awt/Point.html}
and
\url{http://download.oracle.com/javase/6/docs/api/java/awt/Rectangle.html}.

For example, {\tt translate} has the same effect as {\tt moveRect},
but instead of passing the Rectangle as an argument, you use dot
notation:

\begin{verbatim}
    box.translate(50, 100);
\end{verbatim}
%
The effect is the same.


\section{Aliasing}
\label{aliasing}
\index{aliasing}
\index{reference}

Remember that when you assign an object to a variable, you
are assigning a {\em reference} to an object.  It is possible to have
multiple variables that refer to the same object.  For example,
this code:

\begin{verbatim}
    Rectangle box1 = new Rectangle(0, 0, 100, 200);
    Rectangle box2 = box1;
\end{verbatim}
%
generates a state diagram that looks like this:


\myfig{figure=figs/aliasing.eps}


{\tt box1} and {\tt box2} refer to the same object.
In other words, this object has two names, {\tt box1} and {\tt box2}.
When a person uses two names, it's called {\bf aliasing}.  Same thing
with objects.

When two variables are aliased, any changes that affect one
variable also affect the other.  For example:

\begin{verbatim}
    System.out.println(box2.width);
    box1.grow(50, 50);
    System.out.println(box2.width);
\end{verbatim}
%
The first line prints {\tt 100}, which is the width of the
{\tt Rectangle} referred to by {\tt box2}.  The second
line invokes the {\tt grow} method on {\tt box1}, which
expands the {\tt Rectangle} by 50 pixels in every direction
(see the documentation for more details).  The effect
is shown in the figure:


\myfig{figure=figs/aliasing2.eps}


Whatever changes are
made to {\tt box1} also apply to {\tt box2}.  Thus, the
value printed by the third line is {\tt 200}, the width of
the expanded rectangle. (As an aside, it is perfectly legal
for the coordinates of a {\tt Rectangle} to be negative.)

As you can tell even from this simple example, code that
involves aliasing can get confusing fast, and can be
difficult to debug.  In general, aliasing should be avoided
or used with care.


\section {{\tt null}}
\index{null}

When you create an object variable, remember that you are
creating a {\em reference} to an object.  Until you make
the variable point to an object, the value of the variable
is {\tt null}.  {\tt null} is a special value (and
a Java keyword) that means ``no object.''

The declaration {\tt Point blank;} is equivalent to this
initialization

\begin{verbatim}
    Point blank = null;
\end{verbatim}
%
and is shown in the following state diagram:


\myfig{figure=figs/reference2.eps}


The value {\tt null} is represented by a small square with no arrow.

\index{exception!NullPointer}
\index{run-time error}

If you try to use a null object, either by accessing an instance
variable or invoking a method, you will get a {\tt
NullPointerException}.  The system will print an error message
and terminate the program.

\begin{verbatim}
    Point blank = null;
    int x = blank.x;              // NullPointerException
    blank.translate(50, 50);      // NullPointerException
\end{verbatim}
%
On the other hand, it is legal to pass a null object as an argument or
receive one as a return value.  In fact, it is common to do so, for
example to represent an empty set or indicate an error condition.


\section {Garbage collection}
\index{garbage collection}

In Section~\ref{aliasing} we talked about what happens when
more than one variable refers to the same object.  What happens
when {\em no} variable refers to an object?  For example:

\begin{verbatim}
    Point blank = new Point(3, 4);
    blank = null;
\end{verbatim}
%
The first line creates a new {\tt Point} object and makes
{\tt blank} refer to it.  The second line changes {\tt blank}
so that instead of referring to the object, it refers to
nothing (the null object).


\myfig{figure=figs/reference3.eps}


If no one refers to an object, then no one can read or write any of
its values, or invoke a method on it.  In effect, it ceases to exist.
We could keep the object in memory, but it would only waste space, so
periodically as your program runs, the system looks for stranded
objects and reclaims them, in a process called {\bf garbage
collection}.  Later, the memory space occupied by the object will
be available to be used as part of a new object.

You don't have to do anything to make garbage collection work,
and in general you will not be aware of it.  But I thought you
should know.


\section {Objects and primitives}
\index{type!object}
\index{type!primitive}
\index{object type}
\index{primitive type}

There are two kinds of types in Java, primitive types and
object types.  Primitives, like {\tt int} and {\tt boolean}
begin with lower-case letters; object types begin with
upper-case letters.  This distinction is useful because it
reminds us of some of the differences between them:

\begin{itemize}

\item When you declare a primitive variable, you get storage
space for a primitive value.  When you declare an object variable, you
get a space for a reference to an object.  In order to get space for
the object itself, you have to use {\tt new}.

\item If you don't initialize a primitive type, it is given
a default value that depends on the type.  For example,
{\tt 0} for {\tt int}s and {\tt true} for {\tt boolean}s.
The default value for object types is {\tt null}, which indicates
no object.

\item Primitive variables are well isolated in the sense that there is
nothing you can do in one method that will affect a variable in
another method.  Object variables can be tricky to work with because
they are not as well isolated.  If you pass a reference to an object
as an argument, the method you invoke might modify the object, in which
case you will see the effect.  Of course, that can be a good thing, but you
have to be aware of it.

\end{itemize}

There is one other difference between primitives and object
types.  You cannot add new primitives to the Java language
(unless you get yourself on the standards committee), but
you can create new object types!  We'll see how in the next
chapter.

\section{Glossary}

\begin{description}

\item[package:]  A collection of classes.  The Java
classes are organized in packages.

\item[AWT:]  The Abstract Window Toolkit, one of the biggest
and most commonly-used Java packages.

\item[instance:]  An example from a category.  My cat is an
instance of the category ``feline things.''  Every object is
an instance of some class.

\item[instance variable:]  One of the named data items that make
up an object.  Each object (instance) has its own copy of
the instance variables for its class.

\item[reference:]  A value that indicates an object.  In a
state diagram, a reference appears as an arrow.

\item[aliasing:] The condition when two or more variables refer
to the same object.

\item[garbage collection:]  The process of finding objects that
have no references and reclaiming their storage space.

\item[state:] A complete description of all the variables and
objects and their values, at a given point during the execution
of a program.

\item[state diagram:] A snapshot of the state of a program, shown
graphically.

\index{package}
\index{AWT}
\index{instance}
\index{instance variable}
\index{reference}
\index{aliasing}
\index{garbage collection}
\index{state}
\index{state diagram}

\end{description}


\section{Exercises}

\begin{exercise}
\begin{enumerate}

\item For the following program, draw a stack diagram showing the
local variables and parameters of {\tt main} and {\tt riddle}, and show
any objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{verbatim}
public static void main(String[] args)
{
    int x = 5;
    Point blank = new Point(1, 2);

    System.out.println(riddle(x, blank));
    System.out.println(x);
    System.out.println(blank.x);
    System.out.println(blank.y);
}

public static int riddle(int x, Point p)
{
    x = x + 7;
    return x + p.x + p.y;
}
\end{verbatim}

The point of this exercise is to make sure you understand the
mechanism for passing Objects as parameters.
\end{exercise}


\begin{exercise}
\begin{enumerate}

\item For the following program, draw a stack diagram showing the
state of the program just before {\tt distance} returns.  Include all
variables and parameters and the objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{verbatim}
public static double distance(Point p1, Point p2) {
    int dx = p1.x - p2.x;
    int dy = p1.y - p2.y;
    return Math.sqrt(dx*dx + dy*dy);
}

public static Point findCenter(Rectangle box) {
    int x = box.x + box.width/2;
    int y = box.y + box.height/2;
    return new Point(x, y);
}  

public static void main(String[] args) {
    Point blank = new Point(5, 8);

    Rectangle rect = new Rectangle(0, 2, 4, 4);
    Point center = findCenter(rect);

    double dist = distance(center, blank);

    System.out.println(dist);
}
\end{verbatim}
%
\end{exercise}



\begin{exercise}
The method {\tt grow} is part of the {\tt Rectangle} class.  Read the
documentation at
\url{http://download.oracle.com/javase/6/docs/api/java/awt/Rectangle.html#grow(int,int)}.

\begin{enumerate}

\item What is the output of the following program?

\item Draw a state diagram that shows the state of the
program just before the end of {\tt main}.
Include all local variables and the objects
they refer to.

\item At the end of {\tt main}, are {\tt p1} and
{\tt p2} aliased?  Why or why not?

\end{enumerate}

\begin{verbatim}
public static void printPoint(Point p) {
    System.out.println("(" + p.x + ", " + p.y + ")");
}

public static Point findCenter(Rectangle box) {
    int x = box.x + box.width/2;
    int y = box.y + box.height/2;
    return new Point(x, y);
}  

public static void main(String[] args) {

    Rectangle box1 = new Rectangle(2, 4, 7, 9);
    Point p1 = findCenter(box1);
    printPoint(p1);

    box1.grow(1, 1);
    Point p2 = findCenter(box1);
    printPoint(p2);
}
\end{verbatim}

\end{exercise}


\begin{exercise}
You might be sick of the factorial
method by now, but we're going to do one more version.

\begin{enumerate}

\item Create a new program called {\tt Big.java} and
write an iterative version of {\tt factorial}.

\item Print a table of the integers from 0 to 30 along with their
factorials.  At some point around 15, you will probably see
that the answers are not right any more.  Why not?

\item BigIntegers are Java objects that can represent arbitrarily big
  integers.  There is no upper bound except the limitations of memory
  size and processing speed.  Read the documentation of BigIntegers at
  \url{http://download.oracle.com/javase/6/docs/api/java/math/BigInteger.html}.

\item To use BigIntegers, you have to add {\tt import
java.math.BigInteger} to the beginning of your program.

\item There are several ways to create a
BigInteger, but the one I recommend uses {\tt valueOf}.
The following code converts an integer to a {\tt BigInteger}:

\begin{verbatim}
    int x = 17;
    BigInteger big = BigInteger.valueOf(x);
\end{verbatim}

Type in this code and try it out.  Try printing a BigInteger.

\item Because BigIntegers are not primitive types,
the usual math operators don't work.  Instead we
have to use methods like {\tt add}.  To
add two BigIntegers, invoke {\tt add} on one
and pass the other as an argument.  For example:

\begin{verbatim}
    BigInteger small = BigInteger.valueOf(17); 
    BigInteger big = BigInteger.valueOf(1700000000); 
    BigInteger total = small.add(big);
\end{verbatim}

Try out some of the other methods, like {\tt multiply} and
{\tt pow}.

\item Convert {\tt factorial} so that it performs its calculation
using BigIntegers and returns a BigInteger as a result.
You can leave the parameter alone---it will still be an integer.

\item Try printing the table again with your modified factorial
method.  Is it correct up to 30?  How high can you make it go?  I
calculated the factorial of all the numbers from 0 to 999, but my
machine is pretty slow, so it took a while.  The last number, 999!,
has 2565 digits.

\end{enumerate}
\end{exercise}

\begin{exercise}
Many encryption techniques depend on the
ability to raise large integers to an integer power.  Here is a
method that implements a (reasonably) fast technique for integer
exponentiation:

\begin{verbatim}
public static int pow(int x, int n) {
    if (n==0) return 1;

    // find x to the n/2 recursively
    int t = pow(x, n/2);

    // if n is even, the result is t squared
    // if n is odd, the result is t squared times x

    if (n%2 == 0) {
      return t*t;
    } else {
      return t*t*x;
    }
}
\end{verbatim}

The problem with this method is that it only works if the result
is smaller than 2 billion.  Rewrite it so that the result is
a {\tt BigInteger}.  The parameters should still be integers, though.

You can use the BigInteger methods {\tt add} and {\tt multiply}, but
don't use {\tt pow}, which would spoil the fun.
\end{exercise}



\beforechapter
\chapter{Create your own objects}
\label{chap09}

\section{Class definitions and object types}
\label{classes}
\index{type!object}
\index{type!user-defined}
\index{object type}
\index{class definition}
\index{user-defined type}

Every time you write a class definition, you create a new
object type, with the same name as the class.  Way back in
Section~\ref{hello}, when we defined the class named {\tt Hello},
we also created an object type named {\tt Hello}.  We
didn't create any variables with type {\tt Hello}, and we
didn't use {\tt new} to create any {\tt Hello}
objects, but we could have!

That example doesn't make much sense, since there is no
reason to create a {\tt Hello} object, and it is not clear
what it would be good for if we did.  In this chapter, we
will look at some examples of class definitions that create
{\em useful} new object types.

Here are the most important ideas in this chapter:

\begin{itemize}

\item Defining a new class also creates a new object type
with the same name.

\item A class definition is like a template for objects:
it determines what instance variables the objects have and
what methods can operate on them.

\item Every object belongs to some object type; hence, it
is an instance of some class.

\item When you invoke {\tt new} to create an object, Java
invokes a special method called a {\bf constructor} to initialize the
instance variables.  You provide one or more constructors as part of
the class definition.

\item Typically all the methods that operate on a type go in the
class definition for that type.

\end{itemize}

Here are some syntax issues about class definitions:

\begin{itemize}

\item Class names(and hence object types) always begin with a capital
letter, which helps distinguish them from primitive types and variable
names.

\item You usually put one class definition in each file, and the name
of the file must be the same as the name of the class, with the suffix
{\tt .java}.  For example, the {\tt Time} class is defined in the file
named {\tt Time.java}.

\item In any program, one class is designated as the {\bf startup
class}.  The startup class must contain a method named {\tt main}, which
is where the execution of the program begins.  Other classes {\em may}
have a method named {\tt main}, but it will not be executed.

\end{itemize}

With those issues out of the way, let's look at an example of
a user-defined type, {\tt Time}.

\section{Time}
\index{class!Time}
\index{Time}

A common motivation for creating a new Object type is to take several
related pieces of data and encapsulate them into an object that can be
manipulated (passed as an argument, operated on) as a single unit.  We
have already seen two types like this, {\tt Point} and {\tt
Rectangle}.

Another example, which we will implement ourselves, is {\tt Time},
which is used to record the time of day.  The various pieces of
information that form a time are the hour, minute and second.  Because
every {\tt Time} object will contain these data, we need to create
instance variables to hold them.

The first step is to decide what type each variable should be.  It
seems clear that {\tt hour} and {\tt minute} should be integers.  Just
to keep things interesting, let's make {\tt second} a {\tt double}, so
we can record fractions of a second.

\index{instance variable}
\index{variable!instance}

Instance variables are declared at the beginning of the class
definition, outside of any method definition, like this:

\begin{verbatim}
class Time {
  int hour, minute;
  double second;
}
\end{verbatim}
%
All by itself, this code fragment is a legal class definition.  The
state diagram for a {\tt Time} object would look like this:


\myfig{figure=figs/time.eps}


After declaring the instance variables, the next step is usually
to define a constructor for the new class.

\section{Constructors}
\index{constructor}
\index{method!constructor}
\index{static}

The usual role of a constructor is to initialize the instance
variables.  The syntax for constructors is similar to that
of other methods, with three exceptions:

\begin{itemize}

\item The name of the constructor is the same as the name of
the class.

\item Constructors have no return type and no return value.

\item The keyword {\tt static} is omitted.

\end{itemize}

Here is an example for the {\tt Time} class:

\begin{verbatim}
  public Time() {
    this.hour = 0;
    this.minute = 0;
    this.second = 0.0;
  }
\end{verbatim}
%
Notice that where you would expect to see a return type,
between {\tt public} and {\tt Time}, there is nothing.  That's
how we(and the compiler) can tell that this is a constructor.

This constructor does not take any arguments, as indicated by the
empty parentheses {\tt()}.  Each line of the constructor initializes
an instance variable to an arbitrary default value(in this case,
midnight).  The name {\tt this} is a special
keyword that is the name of the object we are creating.  You can use
{\tt this} the same way you use the name of any other object.  For
example, you can read and write the instance variables of {\tt this},
and you can pass {\tt this} as an argument to other methods.

\index{this}

But you do not declare {\tt this} and you do not use {\tt new}
to create it.  In fact, you are not even allowed to make an
assignment to it!  {\tt this} is created by the system; all you
have to do is store values in its instance variables.

A common error when writing constructors is to put a {\tt return}
statement at the end.  Resist the temptation.

\section{More constructors}
\index{overloading}

Constructors can be overloaded, just like other methods,
which means that you can provide multiple constructors
with different parameters.  Java knows which constructor
to invoke by matching the arguments of {\tt new}
with the parameters of the constructors.

It is very common to have one constructor that takes no
arguments(shown above), and one constructor that takes
a parameter list that is identical to the list of instance
variables.  For example:

\begin{verbatim}
  public Time(int hour, int minute, double second) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
  }
\end{verbatim}
%
The names and types of the parameters are exactly the same as
the names and types of the instance variables.  All the
constructor does is copy the information from the parameters
to the instance variables.

If you go back and look at the documentation for {\tt Point}s
and {\tt Rectangle}s, you will see that both classes provide
constructors like this.  Overloading constructors provides the
flexibility to create an object first and then fill in the
blanks, or to collect all the information before creating
the object.

So far this might not seem very interesting, and in fact it
is not.  Writing constructors is a boring, mechanical process.
Once you have written two, you will find that you can churn them
out in your sleep, just by looking at the list of instance
variables.

\section{Creating a new object}
\index{new}
\index{statement!new}

Although constructors look like methods, you never invoke them
directly.  Instead, when you invoke {\tt new}, the system
allocates space for the new object and then 
invokes your constructor to initialize the instance variables.

The following program demonstrates two ways to create and
initialize {\tt Time} objects:

\begin{verbatim}
class Time {
  int hour, minute;
  double second;

  public Time() {
    this.hour = 0;
    this.minute = 0;
    this.second = 0.0;
  }

  public Time(int hour, int minute, double second) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
  }

  public static void main(String[] args) {

    // one way to create and initialize a Time object
    Time t1 = new Time();
    t1.hour = 11;
    t1.minute = 8;
    t1.second = 3.14159;
    System.out.println(t1);

    // another way to do the same thing
    Time t2 = new Time(11, 8, 3.14159);
    System.out.println(t2);
  }
}
\end{verbatim}
%
As an exercise, figure out the flow of execution through this
program.

In {\tt main}, the first time we invoke {\tt new},
we provide no arguments, so Java invokes the first constructor.
The next few lines assign values to each of the instance
variables.

The second time we invoke {\tt new}, we provide
arguments that match the parameters of the second constructor.
This way of initializing the instance variables is more concise
(and slightly more efficient), but it can be harder to read, since
it is not as clear which values are assigned to which instance
variables.

\section{Printing an object}
\label{printobject}
\index{print}
\index{statement!print}
\index{object!printing}

The output of this program is:

\begin{verbatim}
Time@80cc7c0
Time@80cc807
\end{verbatim}
%
When Java prints the value of a user-defined object type, it prints
the name of the type and a special hexadecimal(base 16) code that is
unique for each object.  This code is not meaningful in itself; in
fact, it can vary from machine to machine and even from run to run.
But it can be useful for debugging, in case you want to keep track of
individual objects.

In order to print objects in a way that is more meaningful to users
(as opposed to programmers), you usually want to write a method
called something like {\tt printTime}:

\begin{verbatim}
  public static void printTime(Time t) {
    System.out.println(t.hour + ":" + t.minute + ":" + t.second);
  }
\end{verbatim}
%
Compare this method to the version of {\tt printTime} in
Section~\ref{time}.

The output of this method, if we pass either {\tt t1} or {\tt t2} as
an argument, is {\tt 11:8:3.14159}.  Although this is recognizable
as a time, it is not quite in the standard format.  For example, if
the number of minutes or seconds is less than 10, we expect a leading
{\tt 0} as a place-keeper.  Also, we might want to drop the decimal
part of the seconds.  In other words, we want something like
{\tt 11:08:03}.

In most languages, there are simple ways to control the output format
for numbers.  In Java there are no simple ways.

Java provides very powerful tools for printing formatted things
like times and dates, and also for interpreting formatted input.
Unfortunately, these tools are not very easy to use, so I am going to
leave them out of this book.  If you want, though, you can take a look
at the documentation for the {\tt Date} class in the {\tt
java.util} package.

\index{Date}
\index{class!Date}

\section{Operations on objects}
\label{objectops}
\index{object}
\index{operator!object}

Even though we can't print times in an optimal format, we can still
write methods that manipulate {\tt Time} objects.  In the next few
sections, I will demonstrate several of the possible interfaces for
methods that operate on objects.  For some operations, you will have a
choice of several possible interfaces, so you should consider the pros
and cons of each of these:

\begin{description}

\item[pure function:]  Takes objects and/or primitives as
arguments but does not modify the objects.  The return value is
either a primitive or a new object created inside the method.

\item[modifier:]  Takes objects as arguments and modifies some
or all of them.  Often returns void. \index{void}

\item[fill-in method:]  One of the arguments is an ``empty''
object that gets filled in by the method.  Technically, this is
a type of modifier.

\end{description}

\section{Pure functions}
\index{pure function}
\index{function}
\index{method!pure function}

A method is considered a pure function if the result depends only on
the arguments, and it has no side effects like modifying an argument
or printing something.  The only result of invoking a pure function is
the return value.

One example is {\tt after}, which compares two {\tt Time}s and
returns a {\tt boolean} that indicates whether the first operand
comes after the second:

\begin{verbatim}
  public static boolean after(Time time1, Time time2) {
    if (time1.hour > time2.hour) return true;
    if (time1.hour < time2.hour) return false;

    if (time1.minute > time2.minute) return true;
    if (time1.minute < time2.minute) return false;

    if (time1.second > time2.second) return true;
    return false;
  }
\end{verbatim}
%
What is the result of this method if the two times are equal?  Does
that seem like the appropriate result for this method?  If you were
writing the documentation for this method, would you mention that case
specifically?

A second example is {\tt addTime}, which calculates the sum of two
times.  For example, if it is {\tt 9:14:30}, and your breadmaker takes
3 hours and 35 minutes, you could use {\tt addTime} to figure out when
the bread will be done.

Here is a rough draft of this method that is not quite right:

\begin{verbatim}
  public static Time addTime(Time t1, Time t2) {
    Time sum = new Time();
    sum.hour = t1.hour + t2.hour;
    sum.minute = t1.minute + t2.minute;
    sum.second = t1.second + t2.second;
    return sum;
  }
\end{verbatim}
%
Although this method returns a {\tt Time} object, it is not
a constructor.  You should go back and compare the syntax of
a method like this with the syntax of a constructor, because
it is easy to get confused.

Here is an example of how to use this method.  If {\tt currentTime}
contains the current time and {\tt breadTime} contains the amount
of time it takes for your breadmaker to make bread, then you
could use {\tt addTime} to figure out when the bread will be
done.

\begin{verbatim}
    Time currentTime = new Time(9, 14, 30.0);
    Time breadTime = new Time(3, 35, 0.0);
    Time doneTime = addTime(currentTime, breadTime);
    printTime(doneTime);
\end{verbatim}
%
The output of this program is {\tt 12:49:30.0}, which is
correct.  On the other hand, there are cases where the result
is not correct.  Can you think of one?

The problem is that this method does not deal with cases
where the number of seconds or minutes adds up to more than
60.  In that case, we have to ``carry'' the extra seconds
into the minutes column, or extra minutes into the hours
column.

Here's a second, corrected version of this method.

\begin{verbatim}
  public static Time addTime(Time t1, Time t2) {
    Time sum = new Time();
    sum.hour = t1.hour + t2.hour;
    sum.minute = t1.minute + t2.minute;
    sum.second = t1.second + t2.second;

    if (sum.second >= 60.0) {
      sum.second -= 60.0;
      sum.minute += 1;
    }
    if (sum.minute >= 60) {
      sum.minute -= 60;
      sum.hour += 1;
    }
    return sum;
  }
\end{verbatim}
%
Although it's correct, it's starting to get big.  Later,
I will suggest an alternative approach to this problem that
will be much shorter.

\index{increment}
\index{decrement}
\index{operator!increment}
\index{operator!decrement}

This code demonstrates two operators we have not seen before,
{\tt +=} and {\tt -=}.  These operators provide a concise
way to increment and decrement variables.  They are similar
to {\tt ++} and {\tt --}, except(1) they work on {\tt double}s
as well as {\tt int}s, and(2) the amount of the increment
does not have to be 1.  The statement {\tt sum.second -= 60.0;}
is equivalent to {\tt sum.second = sum.second - 60;}

\section{Modifiers}
\index{modifier}
\index{method!modifier}

As an example of a modifier, consider {\tt increment},
which adds a given number of seconds to a {\tt Time} object.
Again, a rough draft of this method looks like:

\begin{verbatim}
  public static void increment(Time time, double secs) {
    time.second += secs;

    if (time.second >= 60.0) {
      time.second -= 60.0;
      time.minute += 1;
    }
    if (time.minute >= 60) {
      time.minute -= 60;
      time.hour += 1;
    }
  }
\end{verbatim}
%
The first line performs the basic operation; the remainder
deals with the same cases we saw before.

Is this method correct?  What happens if the argument {\tt secs}
is much greater than 60?  In that case, it is not enough to
subtract 60 once; we have to keep doing it until {\tt second}
is below 60.  We can do that by simply replacing the {\tt if}
statements with {\tt while} statements:

\begin{verbatim}
  public static void increment(Time time, double secs) {
    time.second += secs;

    while (time.second >= 60.0) {
      time.second -= 60.0;
      time.minute += 1;
    }
    while (time.minute >= 60) {
      time.minute -= 60;
      time.hour += 1;
    }
  }
\end{verbatim}
%
This solution is correct, but not very efficient.
Can you think of a solution that does not require iteration?

\section{Fill-in methods}
\index{fill-in method}
\index{method!fill-in}

Occasionally you will see methods like {\tt addTime} written
with a different interface(different arguments and return values).
Instead of creating a new object every time {\tt addTime} is
invoked, we could require the caller to provide an ``empty''
object where {\tt addTime} should store the result.  Compare
the following with the previous version:

\begin{verbatim}
  public static void addTimeFill(Time t1, Time t2, Time sum) {
    sum.hour = t1.hour + t2.hour;
    sum.minute = t1.minute + t2.minute;
    sum.second = t1.second + t2.second;

    if (sum.second >= 60.0) {
      sum.second -= 60.0;
      sum.minute += 1;
    }
    if (sum.minute >= 60) {
      sum.minute -= 60;
      sum.hour += 1;
    }
  }
\end{verbatim}
%
One advantage of this approach is that the caller has the option
of reusing the same object repeatedly to perform a series
of additions.  This can be slightly more efficient, although
it can be confusing enough to cause subtle errors.
For the vast majority of programming, it is worth
spending a little run time to avoid a lot of debugging time.

\section{Which is best?}
\index{programming style}

Anything that can be done with modifiers and fill-in methods can also
be done with pure functions.  In fact, there are programming
languages, called {\bf functional} programming languages, that only
allow pure functions.  Some programmers believe that programs that use
pure functions are faster to develop and less error-prone than
programs that use modifiers.  Nevertheless, there are times when
modifiers are convenient, and some cases where functional programs
are less efficient.

In general, I recommend that you write pure functions whenever
it is reasonable to do so, and resort to modifiers only if there
is a compelling advantage.  This approach might be called a
functional programming style.

\section{Incremental development vs. planning}
\index{incremental development}
\index{prototyping}
\index{program development!incremental}
\index{program development!planning}

In this chapter I have demonstrated an approach to program
development I refer to as {\bf rapid prototyping with iterative
improvement}.  In each case, I wrote a rough draft(or prototype)
that performed the basic calculation, and then tested it on
a few cases, correcting flaws as I found them.

Although this approach can be effective, it can lead to code
that is unnecessarily complicated---since it deals with many
special cases---and unreliable---since it is hard to convince
yourself that you have found {\em all} the errors.

An alternative is high-level planning, in which a little insight
into the problem can make the programming much easier.  In
this case the insight is that a {\tt Time} is really a three-digit
number in base 60!  The {\tt second} is the ``ones column,''
the {\tt minute} is the ``60's column'', and the {\tt hour}
is the ``3600's column.''

When we wrote {\tt addTime} and {\tt increment}, we were effectively
doing addition in base 60, which is why we had to ``carry'' from one
column to the next.

\index{arithmetic!floating-point}

Thus an alternative approach to the whole problem is to convert
{\tt Time}s into {\tt double}s and take advantage of the fact that
the computer already knows how to do arithmetic with {\tt double}s.
Here is a method that converts a {\tt Time} into a {\tt double}:

\begin{verbatim}
  public static double convertToSeconds(Time t) {
    int minutes = t.hour * 60 + t.minute;
    double seconds = minutes * 60 + t.second;
    return seconds;
  }
\end{verbatim}
%
Now all we need is a way to convert from a {\tt double}
to a {\tt Time} object.  We could write a method to
do it, but it might make more sense to write it as a third
constructor:

\begin{verbatim}
  public Time(double secs) {
    this.hour =(int)(secs / 3600.0);
    secs -= this.hour * 3600.0;
    this.minute =(int)(secs / 60.0);
    secs -= this.minute * 60;
    this.second = secs;
  }
\end{verbatim}
%
This constructor is a little different from the others, since
it involves some calculation along with assignments to the
instance variables.

You might have to think a bit to convince yourself that the technique
I am using to convert from one base to another is correct.  Assuming
you are convinced, we can use these methods to rewrite {\tt addTime}:

\begin{verbatim}
  public static Time addTime(Time t1, Time t2) {
    double seconds = convertToSeconds(t1) + convertToSeconds(t2);
    return new Time(seconds);
  }
\end{verbatim}
%
This is much shorter than the original version, and it is much easier
to demonstrate that it is correct(assuming, as usual, that the
methods it invokes are correct).  As an exercise, rewrite {\tt
increment} the same way.


\section{Generalization}
\index{generalization}

In some ways converting from base 60 to base 10 and back is
harder than just dealing with times.  Base conversion is more
abstract; our intuition for dealing with times is better.

But if we have the insight to treat times as base 60 numbers,
and make the investment of writing the conversion methods
({\tt convertToSeconds} and the third constructor), we get
a program that is shorter, easier to read and debug, and more
reliable.

It is also easier to add more features later.  For example, imagine
subtracting two {\tt Time}s to find the duration between them.  The
naive approach would be to implement subtraction complete with
``borrowing.''  Using the conversion methods would be much easier.

Ironically, sometimes making a problem harder(more general)
makes it easier(fewer special cases, fewer opportunities for error).

\section{Algorithms}
\label{algorithm}
\index{algorithm}

When you write a general solution for a class of problems, as
opposed to a specific solution to a single problem, you have
written an {\bf algorithm}.  I mentioned this word in 
Chapter 1, but did not define it carefully.  It is
not easy to define, so I will try a couple of approaches.

First, consider some things that are not algorithms.  For example,
when you learned to multiply single-digit numbers, you probably
memorized the multiplication table.  In effect, you memorized 100
specific solutions, so that knowledge is not really algorithmic.

But if you were ``lazy,'' you probably cheated by learning a few
tricks.  For example, to find the product of $n$ and 9, you can
write $n-1$ as the first digit and $10-n$ as the second digit.  This
trick is a general solution for multiplying any single-digit number by 9.
That's an algorithm!

Similarly, the techniques you learned for addition with carrying,
subtraction with borrowing, and long division are all algorithms.  One
of the characteristics of algorithms is that they do not require any
intelligence to carry out.  They are mechanical processes in which
each step follows from the last according to a simple set of rules.

In my opinion, it is embarrassing that humans spend so much
time in school learning to execute algorithms that,
quite literally, require no intelligence.

On the other hand, the process of designing algorithms is
interesting, intellectually challenging, and a central part
of what we call programming.

Some of the things that people do naturally, without difficulty
or conscious thought, are the most difficult to express
algorithmically.  Understanding natural language is a good
example.  We all do it, but so far no one has been able to
explain {\em how} we do it, at least not in the form of an
algorithm.

Later you will have the opportunity to design
simple algorithms for a variety of problems.


\section{Glossary}

\begin{description}

\item[class:]  Previously, I defined a class as a collection
of related methods.  In this chapter we learned that a class
definition is also a template for a new type of object.

\item[instance:]  A member of a class.  Every object is an
instance of some class.

\item[constructor:]  A special method that initializes the instance
variables of a newly-constructed object.

\item[project:]  A collection of one or more class definitions
(one per file) that make up a program.

\item[startup class:]  The class that contains the {\tt main}
method where execution of the program begins.

\item[function:]  A method whose result depends only on its
parameters, and that has no side-effects other than returning
a value.

\item[functional programming style:]  A style of program design
in which the majority of methods are functions.  

\item[modifier:]  A method that changes one or more of the objects
it receives as parameters, and usually returns {\tt void}.

\item[fill-in method:]  A type of method that takes an ``empty''
object as a parameter and fills in its instance variables instead
of generating a return value.  This type of method is usually
not the best choice.

\item[algorithm:]  A set of instructions for solving a class of
problems by a mechanical process.

\index{class}
\index{instance}
\index{constructor}
\index{project}
\index{startup class}
\index{function}
\index{functional programming}
\index{modifier}
\index{algorithm}

\end{description}


\section{Exercises}

\begin{exercise}
In the board game Scrabble\footnote{Scrabble is a registered trademark
owned in the U.S.A and Canada by Hasbro Inc., and in the rest of the world
by J.W. Spear \& Sons Limited of Maidenhead, Berkshire, England, a subsidiary 
of Mattel Inc.}, each tile contains a letter, which is used to spell
words, and a score, which is used to determine the value of a word.

\begin{enumerate}

\item Write a definition for a class named {\tt Tile}
that represents Scrabble tiles.  The instance variables should
be a character named {\tt letter} and an integer named {\tt value}.

\item Write a constructor that takes parameters named {\tt letter}
and {\tt value} and initializes the instance variables.

\item Write a method named {\tt printTile} that takes a {\tt Tile}
object as a parameter and prints the instance variables in
some reader-friendly format.

\item Write a method named {\tt testTile} that creates a
Tile object with the letter {\tt Z} and the value 10, and
then uses {\tt printTile} to print the state of the object.

\end{enumerate}

The point of this exercise is to practice the mechanical part
of creating a new class definition and code that tests it.
\end{exercise}

\begin{exercise}
Write a class definition for {\tt Date}, an object type that
contains three integers, {\tt year}, {\tt month} and {\tt day}.
This class should provide two constructors.  The first should
take no parameters.  The second should take parameters named
{\tt year}, {\tt month} and {\tt day}, and use them to initialize
the instance variables.

Add code to {\tt main} that creates a new {\tt Date} object
named {\tt birthday}.  The new object should contain your birthdate.
You can use either constructor.
\end{exercise}


\begin{exercise}
\label{ex.rational}

A rational number is a number that can be represented as the ratio of
two integers.  For example, $2/3$ is a rational number, and you can
think of 7 as a rational number with an implicit 1 in the denominator.
For this assignment, you are going to write a class definition for
rational numbers.

\begin{enumerate}

\item Examine the following program and make sure
you understand what it does:

\begin{verbatim}
public class Complex
{
    double real, imag;

    // simple constructor
    public Complex() {
        this.real = 0.0;  this.imag = 0.0;
    }
        
    // constructor that takes arguments
    public Complex(double real, double imag) {
        this.real = real;  this.imag = imag;
    }

    public static void printComplex(Complex c) {
        System.out.println(c.real + " + " + c.imag + "i");
    }

    // conjugate is a modifier
    public static void conjugate(Complex c) {
        c.imag = -c.imag;
    }

    // abs is a function that returns a primitive
    public static double abs(Complex c) {
        return Math.sqrt(c.real * c.real + c.imag * c.imag);
    }

    // add is a function that returns a new Complex object
    public static Complex add(Complex a, Complex b) {
        return new Complex(a.real + b.real, a.imag + b.imag);
    }

    public static void main(String args[]) {

        // use the first constructor
        Complex x = new Complex();
        x.real = 1.0;
        x.imag = 2.0;

        // use the second constructor
        Complex y = new Complex(3.0, 4.0);

        System.out.println(Complex.abs(y));
    
        Complex.conjugate(x);
        Complex.printComplex(x);
        Complex.printComplex(y);
    
        Complex s = Complex.add(x, y);
        Complex.printComplex(s);
    }
}
\end{verbatim}

\item Create a new program called {\tt Rational.java} that defines a
class named {\tt Rational}.  A {\tt Rational} object should have two
integer instance variables to store the numerator and denominator of a
rational number.

\item Write a constructor that takes no arguments and that sets the
two instance variables to zero.

\item Write a method called {\tt printRational} that takes
a Rational object as an argument and prints it in some
reasonable format.

\item Write a {\tt main} method that creates a new object with
type Rational, sets its instance variables to some values, and prints
the object.

\item At this stage, you have a minimal testable(debuggable)
program.  Test it and, if necessary, debug it.

\item Write a second constructor for your class that takes two
arguments and that uses them to initalize the instance
variables.

\item Write a method called {\tt negate} that reverses the sign of
a rational number.  This method should be a modifier, so it should
return {\tt void}.  Add lines to {\tt main} to test the new method.

\item Write a method called {\tt invert} that inverts the number by
swapping the numerator and denominator.  Remember the swap pattern we
have seen before.  Add lines to {\tt main} to test the new method.
%I don't think we've seen any swap pattern before
%since this is the first instance of the word ``swap'' in the text
%(but I may be wrong)

\item Write a method called {\tt toDouble} that converts the rational
number to a double(floating-point number) and returns the result.
This method is a pure function; it does not modify the object.
As always, test the new method.

\item Write a modifier named {\tt reduce} that reduces a rational number
to its lowest terms by finding the GCD of the numerator and denominator
and then dividing top and bottom by the GCD.
This method should be a pure function; it should not modify
the instance variables of the object on which it is invoked.

You may want to write a method called {\tt gcd} that finds
the greatest common divisor of the numerator and the denominator
(See Exercise~\ref{gcd}).

\item Write a method called {\tt add} that takes two Rational
numbers as arguments and returns a new Rational object.  The return
object, not surprisingly, should contain the sum of the arguments.

There are several ways to add fractions.  You can use any one you
want, but you should make sure that the result of the operation is
reduced so that the numerator and denominator have no common divisor
(other than 1).
\end{enumerate}

The purpose of this exercise is to write a class definition that
includes a variety of methods, including constructors, modifiers and
pure functions.
\end{exercise}




\beforechapter
\chapter{Arrays}
\label{chap10}
\label{arrays}
\index{array}
\index{type!array}

An {\bf array} is a set of values where each value is identified by an
index.  You can make an array of {\tt int}s, {\tt double}s, or any
other type, but all the values in an array have to have the same type.

Syntactically, array types look like other Java types except they are
followed by {\tt []}.  For example, {\tt int[]} is the type ``array of
integers'' and {\tt double[]} is the type ``array of doubles.''

You can declare variables with these types in the usual ways:

\begin{verbatim}
    int[] count;
    double[] values;
\end{verbatim}
%
Until you initialize these variables, they are set to {\tt null}.
To create the array itself, use {\tt new}.

\begin{verbatim}
    count = new int[4];
    values = new double[size];
\end{verbatim}
%
The first assignment makes {\tt count} refer to an array of 4
integers; the second makes {\tt values} refer to an array of {\tt
double}s.  The number of elements in {\tt values} depends on {\tt
size}.  You can use any integer expression as an array
size.

\index{null}
\index{state diagram}

The following figure shows how arrays are represented in state
diagrams:


\myfig{figure=figs/array.eps}


The large numbers inside the boxes are the {\bf elements} of
the array.  The small numbers outside the boxes are the
indices used to identify each box.  When you allocate a new
array, the elements are initialized to zero.

\section{Accessing elements}
\index{element}
\index{array!element}

To store values in the array, use the
{\tt []} operator.  For example {\tt count[0]} refers to the
``zeroeth'' element of the array, and {\tt count[1]} refers to the
``oneth'' element.  You can use the {\tt []} operator anywhere in an
expression:

\begin{verbatim}
    count[0] = 7;
    count[1] = count[0] * 2;
    count[2]++;
    count[3] -= 60;
\end{verbatim}
%
All of these are legal assignment statements.  Here is the
effect of this code fragment:


\myfig{figure=figs/array2.eps}


By now you should have noticed that the four elements of this array
are numbered from 0 to 3, which means that there is no element with
the index 4.  This should sound familiar, since we saw the same thing
with {\tt String} indices.  Nevertheless, it is a common error to go
beyond the bounds of an array, which will cause an {\tt
ArrayOutOfBoundsException}.  As with all exceptions, you get an error
message and the program quits.

\index{exception!ArrayOutOfBounds}
\index{run-time error}
\index{index}
\index{expression}

You can use any expression as an index, as long as it has type {\tt
int}.  One of the most common ways to index an array is with a loop
variable.  For example:

\begin{verbatim}
    int i = 0;
    while (i < 4) {
      System.out.println(count[i]);
      i++;
    }
\end{verbatim}
%
This is a standard {\tt while} loop that counts from 0
up to 4, and when the loop variable {\tt i} is 4, the
condition fails and the loop terminates.  Thus, the body
of the loop is only executed when {\tt i} is 0, 1, 2 and 3.

\index{loop}
\index{loop variable}
\index{variable!loop}

Each time through the loop we use {\tt i} as an index into
the array, printing the {\tt i}th element.  This type of
array traversal is very common.  Arrays and loops go together
like fava beans and a nice Chianti.

\index{fava beans}
\index{Chianti}

\section{Copying arrays}
\index{array!copying}

When you copy an array variable, remember that you are
copying a reference to the array.  For example:

\begin{verbatim}
    double[] a = new double [3];
    double[] b = a;
\end{verbatim}
%
This code creates one array of three {\tt double}s, and
sets two different variables to refer to it.
This situation is a form of aliasing.


\myfig{figure=figs/array3.eps}


Any changes in either array
will be reflected in the other.  This is not usually the
behavior you want; instead, you should make a copy of the
array, by allocating a new array and copying each element from
one to the other.

\begin{verbatim}
    double[] b = new double [3];

    int i = 0;
    while (i < 4) {
      b[i] = a[i];
      i++;
    }
\end{verbatim}

\section{{\tt for} loops}

The loops we have written so far have a number of elements
in common.  All of them start by initializing a variable;
they have a test, or condition, that depends on that variable;
and inside the loop they do something to that variable,
like increment it.

\index{loop!for}
\index{for}
\index{statement!for}

This type of loop is so common that there is an alternative
loop statement, called {\tt for}, that expresses it more
concisely.  The general syntax looks like this:

\begin{verbatim}
    for(INITIALIZER; CONDITION; INCREMENTOR) {
      BODY
    }
\end{verbatim}
%
This statement is exactly equivalent to

\begin{verbatim}
    INITIALIZER;
    while (CONDITION) {
      BODY
      INCREMENTOR
    }
\end{verbatim}
%
except that it is more concise and, since it puts all the
loop-related statements in one place, it is easier to read.
For example:

\begin{verbatim}
    for(int i = 0; i < 4; i++) {
      System.out.println(count[i]);
    }
\end{verbatim}
%
is equivalent to 

\begin{verbatim}
    int i = 0;
    while (i < 4) {
      System.out.println(count[i]);
      i++;
    }
\end{verbatim}
%
As an exercise, write a {\tt for} loop to copy the elements
of an array.

\section{Arrays and objects}
\index{object!compared to array}
\index{array!compared to object}

In many ways, arrays behave like objects:

\begin{itemize}

\item When you declare an array variable, you get a reference
to an array.

\item You have to use {\tt new} to create the array
itself.

\item When you pass an array as an argument, you pass a reference,
which means that the invoked method can change the contents
of the array.

\end{itemize}

Some of the objects we have looked at, like {\tt Rectangles}, are
similar to arrays, in the sense that they are named collection of
values.  This raises the question, ``How is an array of 4 integers
different from a Rectangle object?''

\index{collection}

If you go back to the definition of ``array'' at the beginning
of the chapter, you will see one difference, which is that the
elements of an array are identified by indices, whereas the
elements(instance variables) of an object have names
(like {\tt x}, {\tt width}, etc.).

Another difference between arrays and objects is that all the
elements of an array have to be the same type.  Although that
is also true of {\tt Rectangle}s, we have seen other objects
that have instance variables with different types(like
{\tt Time}).

\section{Array length}
\index{length!array}
\index{array!length}

Actually, arrays do have one named instance variable: {\tt length}.
Not surprisingly, it contains the length of the array(number
of elements).  It is a good idea to use this value as the upper
bound of a loop, rather than a constant value.  That way, if
the size of the array changes, you won't have to go through the
program changing all the loops; they will work correctly for any
size array.

\begin{verbatim}
    for(int i = 0; i < a.length; i++) {
      b[i] = a[i];
    }
\end{verbatim}
%
The last time the body of the loop gets executed, {\tt i}
is {\tt a.length - 1}, which is the index of the last element.  When
{\tt i} is equal to {\tt a.length}, the condition fails and the body
is not executed, which is a good thing, since it would cause an
exception.  This code assumes that the array {\tt b} contains at least
as many elements as {\tt a}.

As an exercise, write a method called {\tt cloneArray} that takes an
array of integers as a parameter, creates a new array that is the same
size, copies the elements from the first array into the new one, and
then returns a reference to the new array.

\section{Random numbers}
\label{random}
\label{pseudorandom}
\index{random number}
\index{deterministic}
\index{nondeterministic}

Most computer programs do the same thing every time they are executed,
so they are said to be {\bf deterministic}.  Usually, determinism is a
good thing, since we expect the same calculation to yield the same
result.  For some applications, though, we would like the
computer to be unpredictable.  Games are an obvious example, but
there are many more.

Making a program truly {\bf nondeterministic} turns out to be not
so easy, but there are ways to make it at least seem
nondeterministic.  One of them is to generate random numbers and
use them to determine the outcome of the program.  Java provides
a method that generates {\bf pseudorandom} numbers, which
are not truly random in the mathematical sense, but 
for our purposes, they will do.

Check out the documentation of the {\tt random} method in the {\tt
Math} class.  The return value is a {\tt double} between 0.0 and 1.0.
To be precise, it is greater than or equal to 0.0 and strictly less
than 1.0.  Each time you invoke {\tt random} you get the next
number in a pseudorandom sequence.
To see a sample, run this loop:

\begin{verbatim}
    for(int i = 0; i < 10; i++) {
      double x = Math.random();
      System.out.println(x);
    }
\end{verbatim}
%
To generate a random {\tt double} between 0.0 and an upper bound like
{\tt high}, you can multiply {\tt x} by {\tt high}.  How would you
generate a random number between {\tt low} and {\tt high}?  How would
you generate a random integer?


\begin{exercise}
Write a method called {\tt randomDouble} that takes two doubles,
{\tt low} and {\tt high}, and that returns a random double $x$
so that $low \le x < high$.
\end{exercise}


\begin{exercise}
\label{ex.randomint}
Write a method called {\tt randomInt} that takes two arguments,
{\tt low} and {\tt high}, and that returns a random integer between
{\tt low} and {\tt high}(including both).
\end{exercise}


\section{Array of random numbers}
\label{randarray}

If your implementation of {\tt randomInt} is correct, then
every value in the range from {\tt low} to {\tt high} should
have the same probability.  If you generate a long series
of numbers, every value should appear, at least approximately,
the same number of times.

One way to test your method is to 
generate a large number of random values,
store them in an array, and count the number of times each
value occurs.

The following method takes a single argument, the size of
the array.  It allocates a new array of integers, fills
it with random values, and returns a reference to the new
array.

\begin{verbatim}
  public static int[] randomArray(int n) {
    int[] a = new int[n];
    for(int i = 0; i<a.length; i++) {
      a[i] = randomInt(0, 100);
    }
    return a;
  }
\end{verbatim}
%
The return type is {\tt int[]}, which means that
this method returns an array of integers.
To test this method, it is convenient to have a method that
prints the contents of an array.

\begin{verbatim}
  public static void printArray(int[] a) {
    for(int i = 0; i<a.length; i++) {
      System.out.println(a[i]);
    }
  }
\end{verbatim}
%
The following code generates an array and prints it:

\begin{verbatim}
    int numValues = 8;
    int[] array = randomArray(numValues);
    printArray(array);
\end{verbatim}
%
On my machine the output is

\begin{verbatim}
27
6
54
62
54
2
44
81
\end{verbatim}
%
which is pretty random-looking.  Your results may differ.

If these were exam scores, and they would be pretty bad exam
scores, the teacher might present the results to the class
in the form of a {\bf histogram}, which is a set of counters
that keeps track of the number of times each value appear.

\index{histogram}

For exam scores, we might have ten counters to keep track of
how many students scored in the 90s, the 80s, etc.  The next
few sections develop code to generate a histogram.


\section{Counting}
\index{traverse!array}
\index{array!traverse}
\index{looping and counting}
\index{counter}

A good approach to problems like this is to think of simple methods
that are easy to write, and that might turn out to be useful.  Then
you can combine them into a solution.  Of course, it is not easy to
know ahead of time which methods are likely to be useful, but as you
gain experience you will have a better idea.

Also, it is not always obvious what sort of things are easy to write,
but a good approach is to look for subproblems that fit a pattern you
have seen before.

Back in Section~\ref{loopcount} we looked at a loop that traversed a
string and counted the number of times a given letter appeared.  You
can think of this program as an example of a pattern called ``traverse
and count.''  The elements of this pattern are:

\begin{itemize}

\item A set or container that can be traversed, like an array
or a string.

\item A test that you can apply to each element in the container.

\item A counter that keeps track of how many elements pass
the test.

\end{itemize}

In this case, the container is an array of integers.  The
test is whether or not a given score falls in a given range of
values.

Here is a method called {\tt inRange}
that counts the number of elements in an array that fall
in a given range.  The parameters are the array and two
integers that specify the lower and upper bounds of
the range.

\begin{verbatim}
public static int inRange(int[] a, int low, int high) {
    int count = 0;
    for(int i=0; i<a.length; i++) {
        if (a[i] >= low && a[i] < high) count++;
    }
    return count;
}
\end{verbatim}
%
In my description of the method,
I wasn't very careful about whether something equal
to {\tt low} or {\tt high} falls in the range, but you can
see from the code that {\tt low} is in and {\tt high} is out.
That should keep us from counting any elements twice.

Now we can count the number of scores in the ranges we are
interested in:

\begin{verbatim}
int[] scores = randomArray(30);
int a = inRange(scores, 90, 100);
int b = inRange(scores, 80, 90);
int c = inRange(scores, 70, 80);
int d = inRange(scores, 60, 70);
int f = inRange(scores, 0, 60);
\end{verbatim}


\section{The histogram}
\index{range}
\index{histogram}

The code we have so far is a bit repetitious, but it is acceptable as
long as the number of ranges want is small.  But now imagine that
we want to keep track of the number of times each score appears,
all 100 possible values.  Would you want to write:

\begin{verbatim}
int count0 = inRange(scores, 0, 1);
int count1 = inRange(scores, 1, 2);
int count2 = inRange(scores, 2, 3);
...
int count3 = inRange(scores, 99, 100);
\end{verbatim}

I don't think so.  What we really want is a
way to store 100 integers, preferably
so we can use an index to access each one.  Immediately,
you should be thinking ``array!''

The counting pattern is the same whether we use a single counter or an
array of counters.  In this case, we initialize the array outside the
loop; then, inside the loop, we invoke {\tt inRange} and store the
result:

\begin{verbatim}
    int[] counts = new int [100];

    for(int i = 0; i<100; i++) {
        counts[i] = inRange(scores, i, i+1);
    }
\end{verbatim}
%
The only tricky thing here is that we are using the loop variable
in two roles: as in index into the array, and as the parameter to
{\tt inRange}.


\section{A single-pass solution}

Although this code works, it is not as efficient as it could
be.  Every time it invokes {\tt inRange}, it traverses the
entire array.  As the number of ranges increases, that gets
to be a lot of traversals.

It would be better to make a single pass through the array,
and for each value, compute which range it falls in.  Then
we could increment the appropriate counter.
In this example, that computation is trivial, because we
can use the value itself as an index into the array of counters.

Here is code that traverses an array of scores, once, and generates
a histogram.

\begin{verbatim}
    int[] counts = new int [100];

    for(int i = 0; i < scores.length; i++) {
        int index = scores[i];
        counts[index]++;
    }
\end{verbatim}

\begin{exercise}
Encapsulate this code in a method called {\tt scoreHist} that
takes an array of scores and returns a histogram of the values
in the array.

Modify the method so that the histogram has only 10 counters,
and count the number of scores in each range of 10 values; that
is, the 90s, the 80s, etc.
\end{exercise}


\section{Glossary}

\begin{description}

\item[array:]  A named collection of values, where all the
values have the same type, and each value is identified by
an index.

\item[collection:]  Any data structure that contains a set
of items or elements.

\item[element:]  One of the values in an array.  The {\tt []}
operator selects elements of an array.

\item[index:]  An integer variable or value used to indicate
an element of an array.

\item[deterministic:]  A program that does the same thing every
time it is invoked.

\item[pseudorandom:]  A sequence of numbers that appear to be
random, but which are actually the product of a deterministic
computation.

\item[histogram:]  An array of integers where each integer
counts the number of values that fall into a certain range.

\index{array}
\index{collection}
\index{element}
\index{index}
\index{deterministic}
\index{pseudorandom}

\end{description}


\section{Exercises}

\begin{exercise}
Write a class method named {\tt areFactors} that takes
an integer {\tt n} and an array of integers, and that returns
{\tt true} if the numbers in the array are all factors of {\tt n}
(which is to say that {\tt n} is divisible by all of them).
HINT: See Exercise~\ref{ex.isdiv}.
\end{exercise}


\begin{exercise}
Write a method that takes an array of integers and an integer named
{\tt target} as arguments, and that returns the first index where
{\tt target} appears in the array, if it does, and -1 otherwise.
\end{exercise}


\begin{exercise}
Write a method called {\tt arrayHist} that takes an array of
integers and that returns a new histogram array.  The histogram should
contain 11 elements with the following contents:

\begin{verbatim}
element 0 -- number of elements in the array that are <= 0
        1 -- number of elements in the array that are == 1
        2 -- number of elements in the array that are == 2
        ...
        9 -- number of elements in the array that are == 9
       10 -- number of elements in the array that are >= 10
\end{verbatim}
\end{exercise}


\begin{exercise}
Some programmers disagree with the general rule that variables
and methods should be given meaningful names.  Instead, they
think variables and methods should be named after fruit.

For each of the following methods, write one sentence that
describes abstractly what the method does.  For each variable,
identify the role it plays.

\begin{verbatim}
public static int banana(int[] a) {
    int grape = 0;
    int i = 0;
    while (i < a.length) {
        grape = grape + a[i];
        i++;
    }
    return grape;
}
	
public static int apple(int[] a, int p) {
    int i = 0;
    int pear = 0;
    while (i < a.length) {
        if (a[i] == p) pear++;
        i++;
    }
    return pear;
}

public static int grapefruit(int[] a, int p) {
    for(int i = 0; i<a.length; i++) {
        if (a[i] == p) return i;
    }
    return -1;
}		
\end{verbatim}

The purpose of this exercise is to practice reading code and
recognizing the solution patterns we have seen.
\end{exercise}


\begin{exercise}
\begin{enumerate}

\item What is the output of the following program?

\item Draw a stack diagram that shows the state of the
program just before {\tt mus} returns.

\item Describe in a few words what {\tt mus} does.
\end{enumerate}

\begin{verbatim}
public static int[] make(int n) {
    int[] a = new int[n];

    for(int i=0; i<n; i++) {
        a[i] = i+1;
    }
    return a;
}

public static void dub(int[] jub) {
    for(int i=0; i<jub.length; i++) {
        jub[i] *= 2;
    }
}

public static int mus(int[] zoo) {
    int fus = 0;
    for(int i=0; i<zoo.length; i++) {
        fus = fus + zoo[i];
    }
    return fus;
}

public static void main(String[] args) {
    int[] bob = make(5);
    dub(bob);

    System.out.println(mus(bob));
}
\end{verbatim}
\end{exercise}


\begin{exercise}
Many of the patterns we have seen for traversing arrays can
also be written recursively.  It is not common to do so, but
it is a useful exercise.

\begin{enumerate}

\item Write a method called {\tt maxInRange} that takes an array of
integers and a range of indices({\tt lowIndex} and {\tt highIndex}),
and that finds the maximum value in the array, considering only the
elements between {\tt lowIndex} and {\tt highIndex}, including both
ends.

This method should be recursive.  If the length of the range is 1,
that is, if {\tt lowIndex == highIndex}, we know immediately that the
sole element in the range must be the maximum.  So that's the base
case.

If there is more than one element in the range, we can break the array
into two pieces, find the maximum in each of the pieces, and then find
the maximum of each of the piece-maxima.

\item Methods like {\tt maxInRange} can be awkward to use.  To
find the largest element in an array, we have to provide a range
that includes the entire array.

\begin{verbatim}
    double max = maxInRange(array, 0, a.length-1);
\end{verbatim}

Write a method called {\tt max} that takes an array as a parameter
and that uses {\tt maxInRange} to find and return the largest value.
Methods like {\tt max} are sometimes called {\bf wrapper methods}
because they provide a layer of abstraction around an awkward method
and provide an interface to
the outside world that is easier to use.  The method that actually
performs the computation is called the {\bf helper method}.  We will
see this pattern again in Section~\ref{wrapper}.

\item Write a recursive version of {\tt find} using the
wrapper-helper pattern.  {\tt find} should take an array of
integers and a target integer.  It should return the index
of the first location where the target integer appears in the
array, or -1 if it does not appear.

\end{enumerate}
\end{exercise}

\begin{exercise}
One not-very-efficient way to sort the elements of an array
is to find the largest element and swap it with the first
element, then find the second-largest element and swap it with
the second, and so on.

\begin{enumerate}

\item Write a method called {\tt indexOfMaxInRange} that 
takes an array of integers, finds the
largest element in the given range, and returns {\em its index}.
You can modify your recursive version of {\tt maxInRange} or
you can write an iterative version from scratch.

\item Write a method called {\tt swapElement} that takes an
array of integers and two indices, and that swaps the elements
at the given indices.

\item Write a method called {\tt sortArray} that takes an array of
integers and that uses {\tt indexOfMaxInRange} and {\tt swapElement}
to sort the array from largest to smallest.

\end{enumerate}
\end{exercise}


\begin{exercise}
Write a method called {\tt letterHist} that takes a String as a
parameter and that returns a histogram of the letters in the String.
The zeroeth element of the histogram should contain the number of a's
in the String(upper and lower case); the 25th element should contain
the number of z's.
Your solution should only traverse the String once.
\end{exercise}


\begin{exercise}
A word is said to be a ``doubloon'' if every letter that appears in the
word appears exactly twice.  For example, the following are all the
doubloons I found in my dictionary.

\begin {quote}
Abba, Anna, appall, appearer, appeases, arraigning, beriberi,
bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah,
horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa,
peep, reappear, redder, sees, Shanghaiings, Toto
\end{quote}

Write a method called {\tt isDoubloon} that returns {\tt true}
if the given word is a doubloon and {\tt false} otherwise.
\end{exercise}


\begin{exercise}
In Scrabble each player has a set of tiles with letters on them, and
the object of the game is to use those letters to spell words.  The
scoring system is complicated, but as a rough guide longer words are
often worth more than shorter words.

Imagine you are given your set of tiles as a String, like {\tt
"qijibo"} and you are given another String to test, like {\tt "jib"}.
Write a method called {\tt testWord} that takes these two Strings and
returns true if the set of tiles can be used to spell the word.  You
might have more than one tile with the same letter, but you can only
use each tile once.
\end{exercise}


\begin{exercise}
In real Scrabble, there are some blank tiles that can be used
as wild cards; that is, a blank tile can be used to represent
any letter.

Think of an algorithm for {\tt testWord} that deals with wild
cards.  Don't get bogged down in details of implementation like
how to represent wild cards.  Just describe the algorithm, using
English, pseudocode, or Java.
\end{exercise}



\beforechapter
\chapter{Arrays of Objects}
\label{chap11}


\section{Composition}
\index{composition}
\index{nested structure}

By now we have seen several examples of composition(the ability to
combine language features in a variety of arrangements).  One of the
first examples we saw was using a method invocation as part of an
expression.  Another example is the nested structure of statements:
you can put an {\tt if} statement within a {\tt while} loop, or within
another {\tt if} statement, etc.

Having seen this pattern, and having learned about arrays and objects,
you should not be surprised to learn that you can have arrays of
objects.  In fact, you can also have objects that contain arrays(as
instance variables); you can have arrays that contain arrays; you can
have objects that contain objects, and so on.

In the next two chapters we will look at some examples of these
combinations, using {\tt Card} objects as an example.


\section{{\tt Card} objects}
\label{card}
\index{Card}
\index{class!Card}

If you are not familiar with common playing cards, now would be a good
time to get a deck, or else this chapter might not make much sense.
There are 52 cards in a deck, each of which belongs to one of four
suits and one of 13 ranks.  The suits are Spades, Hearts, Diamonds and
Clubs(in descending order in Bridge).  The ranks are Ace, 2, 3, 4, 5,
6, 7, 8, 9, 10, Jack, Queen and King.  Depending on what game you are
playing, the rank of the Ace may be higher than King or lower than 2.

\index{rank}
\index{suit}

If we want to define a new object to represent a playing card, it is
pretty obvious what the instance variables should be: {\tt rank} and
{\tt suit}.  It is not as obvious what type the instance variables
should be.  One possibility is {\tt String}s, containing things like
{\tt "Spade"} for suits and {\tt "Queen"} for ranks.  One problem with
this implementation is that it would not be easy to compare cards to
see which had higher rank or suit.

\index{encode}
\index{encrypt}
\index{map to}

An alternative is to use integers to {\bf encode} the ranks and
suits.  By ``encode,'' I do not mean what some people think, which
is to encrypt, or translate into a secret code.  What a computer
scientist means by ``encode'' is something like ``define a mapping
between a sequence of numbers and the things I want to represent.''
For example,

\begin{tabular}{l c l}
Spades & $\mapsto$ & 3 \\
Hearts & $\mapsto$ & 2 \\
Diamonds & $\mapsto$ & 1 \\
Clubs & $\mapsto$ & 0
\end{tabular}

The obvious feature of this mapping is that the suits map to
integers in order, so we can compare suits by comparing integers.
The mapping for ranks is fairly obvious; each of the numerical
ranks maps to the corresponding integer, and for face cards:

\begin{tabular}{l c l}
Jack & $\mapsto$ & 11 \\
Queen & $\mapsto$ & 12 \\
King & $\mapsto$ & 13 \\
\end{tabular}

The reason I am using mathematical notation for these mappings is
that they are not part of the Java program.  They are part of the
program design, but they never appear explicitly in the code.
The class definition for the {\tt Card} type looks like this:

\begin{verbatim}
class Card
{
    int suit, rank;

    public Card() { 
        this.suit = 0;  this.rank = 0;
    }

    public Card(int suit, int rank) { 
        this.suit = suit;  this.rank = rank;
    }
}
\end{verbatim}

As usual, I am providing two constructors, one of which takes
a parameter for each instance variable and the other of which
takes no parameters.

\index{constructor}

To create an object that represents the 3 of Clubs, we would
use {\tt new}:

\begin{verbatim}
    Card threeOfClubs = new Card(0, 3);
\end{verbatim}
%
The first argument, {\tt 0} represents the suit Clubs.

\section{The {\tt printCard} method}
\label{printcard}
\index{print!Card}

When you create a new class, the first step is usually to declare the
instance variables and write constructors.  The second step is often
to write the standard methods that every object should have, including
one that prints the object, and one or two that compare objects.  I
will start with {\tt printCard}.

\index{String!array of}
\index{array!of String}

In order to print {\tt Card} objects in a way that humans
can read easily, we want to map the integer codes onto words.
A natural way to do that is with an array of {\tt String}s.  You
can create an array of {\tt String}s the same way you create an
array of primitive types:

\begin{verbatim}
    String[] suits = new String [4];
\end{verbatim}
%
Then we can set the values of the elements of the array.

\begin{verbatim}
    suits[0] = "Clubs";
    suits[1] = "Diamonds";
    suits[2] = "Hearts";
    suits[3] = "Spades";
\end{verbatim}
%
Creating an array and initializing the elements is such a common
operation that Java provides a special syntax for it:

\begin{verbatim}
    String[] suits = { "Clubs", "Diamonds", "Hearts", "Spades" };
\end{verbatim}
%
The effect of this statement is identical to that of the
separate declaration, allocation, and assignment.  A state
diagram of this array might look like:

\myfig{figure=figs/stringarray.eps}

\index{state diagram}
\index{reference}
\index{String!reference to}

The elements of the array are {\em references} to the {\tt String}s,
rather than {\tt String}s themselves.  This is true of all arrays of
objects, as I will discuss in more detail later.  For now, all we need
is another array of {\tt String}s to decode the ranks:

\begin{verbatim}
    String[] ranks = { "narf", "Ace", "2", "3", "4", "5", "6",
               "7", "8", "9", "10", "Jack", "Queen", "King" };
\end{verbatim}
%
The reason for the {\tt "narf"} is to act as a place-keeper
for the zeroeth element of the array, which will never be
used.  The only valid ranks are 1--13.  This wasted element is not
necessary, of course.  We could have started at 0, as usual, but
it is best to encode 2 as 2, and 3 as 3, etc.

Using these arrays, we can select the appropriate {\tt String}s by
using the {\tt suit} and {\tt rank} as indices.  In the method
{\tt printCard},

\begin{verbatim}
public static void printCard(Card c) {
    String[] suits = { "Clubs", "Diamonds", "Hearts", "Spades" };
    String[] ranks = { "narf", "Ace", "2", "3", "4", "5", "6",
                 "7", "8", "9", "10", "Jack", "Queen", "King" };

    System.out.println(ranks[c.rank] + " of " + suits[c.suit]);
}
\end{verbatim}

the expression {\tt suits[c.suit]} means ``use the instance variable
{\tt suit} from the object {\tt c} as an index into the array named
{\tt suits}, and select the appropriate string.''  The output of this
code

\begin{verbatim}
    Card card = new Card(1, 11);
    printCard(card);
\end{verbatim}
%
is {\tt Jack of Diamonds}.

\section{The {\tt sameCard} method}
\index{sameCard}

The word ``same'' is one of those things that occur in natural
language that seem perfectly clear until you give it some thought,
and then you realize there is more to it than you expected.

\index{ambiguity}
\index{natural language}
\index{language!}

For example, if I say ``Chris and I have the same car,'' I
mean that his car and mine are the same make and model, but they are
two different cars.  If I say ``Chris and I have the same mother,'' I
mean that his mother and mine are one and the same.  So the
idea of ``sameness'' is different depending on the context.

When you talk about objects, there is a similar ambiguity.  For
example, if two {\tt Card}s are the same, does that mean they
contain the same data(rank and suit), or they are actually
the same {\tt Card} object?

To see if two references refer to the same object, we can use
the {\tt ==} operator.  For example:

\begin{verbatim}
    Card card1 = new Card(1, 11);
    Card card2 = card1;

    if (card1 == card2) {
        System.out.println("card1 and card2 are the same object.");
    }
\end{verbatim}
%
This type of equality is called {\bf shallow equality} because
it only compares the references, not the contents of the objects.

\index{equality}
\index{identity}
\index{shallow equality}
\index{deep equality}

To compare the contents of the objects---{\bf deep equality}---it
is common to write a method with a name like {\tt sameCard}.

\begin{verbatim}
public static boolean sameCard(Card c1, Card c2) {
    return(c1.suit == c2.suit && c1.rank == c2.rank);
}
\end{verbatim}
%
Now if we create two different objects that contain the same
data, we can use {\tt sameCard} to see if they represent the
same card:

\begin{verbatim}
    Card card1 = new Card(1, 11);
    Card card2 = new Card(1, 11);

    if (sameCard(card1, card2)) {
        System.out.println("card1 and card2 are the same card.");
    }
\end{verbatim}
%
In this case, {\tt card1} and {\tt card2}
are two different objects that contain the same data

\myfig{figure=figs/card.eps}

so the condition is true.  What does the state diagram look like when
{\tt card1 == card2} is true?

\index{aliasing}

In Section~\ref{incomparable} I said that you should never use the
{\tt ==} operator on {\tt String}s because it does not do what you
expect.  Instead of comparing the contents of the {\tt String}
(deep equality), it checks whether the two {\tt String}s are the
same object(shallow equality).


\section{The {\tt compareCard} method}
\index{compareCard}
\index{operator!conditional}
\index{conditional operator}

For primitive types, there are conditional operators that
compare values and determine when one is greater or less
than another.  These operators({\tt <} and {\tt >} and the others)
don't work for object types.  For {\tt String}s Java provides
a {\tt compareTo} method.  For {\tt Card}s we have
to write our own, which we will call {\tt compareCard}.
Later, we will use this method to sort a deck of cards.

\index{ordering}
\index{complete ordering}
\index{partial ordering}

Some sets are completely ordered, which means that you can
compare any two elements and tell which is bigger.  For
example, the integers and the floating-point numbers are
totally ordered.  Some sets are unordered, which means that
there is no meaningful way to say that one element is bigger
than another.  For example, the fruits are unordered, which
is why we cannot compare apples and oranges.  In Java,
the {\tt boolean} type is unordered; we cannot say that
{\tt true} is greater than {\tt false}.

The set of playing cards is partially ordered, which means that
sometimes we can compare cards and sometimes not.  For example, I know
that the 3 of Clubs is higher than the 2 of Clubs, and the 3 of
Diamonds is higher than the 3 of Clubs.  But which is better, the 3 of
Clubs or the 2 of Diamonds?  One has a higher rank, but the other has
a higher suit.

\index{comparable}

In order to make cards comparable, we have to decide which is more
important, rank or suit.  To be honest, the choice is completely
arbitrary.  For the sake of choosing, I will say that suit is more
important, because when you buy a new deck of cards, it comes sorted
with all the Clubs together, followed by all the Diamonds, and so on.

With that decided, we can write {\tt compareCard}.  It
will take two {\tt Card}s as parameters and return 1 if
the first card wins, -1 if the second card wins, and 0 if
they tie(indicating deep equality).  It is sometimes confusing
to keep those return values straight, but they are pretty
standard for comparison methods.

First we compare the suits:

\begin{verbatim}
    if (c1.suit > c2.suit) return 1;
    if (c1.suit < c2.suit) return -1;
\end{verbatim}
%
If neither statement is true, then the suits must be equal,
and we have to compare ranks:

\begin{verbatim}
    if (c1.rank > c2.rank) return 1;
    if (c1.rank < c2.rank) return -1;
\end{verbatim}
%
If neither of these is true, the ranks must be equal,
so we return {\tt 0}.  In this ordering, aces will appear
lower than deuces(2s).

As an exercise, fix it so that aces are ranked higher than Kings, and
encapsulate this code in a method.


\section{Arrays of cards}
\label{cardarray}
\index{array!of object}
\index{object!array of}
\index{deck}

The reason I chose {\tt Cards} as the objects for this chapter is that
there is an obvious use for an array of cards---a deck.  Here is some
code that creates a new deck of 52 cards:

\begin{verbatim}
    Card[] deck = new Card [52];
\end{verbatim}

Here is the state diagram for this object:

\index{state diagram}

\myfig{figure=figs/cardarray.eps}

The important thing to see here is that the array contains
only {\em references} to objects; it does not contain any
{\tt Card} objects.  The values of the array elements are
initialized to {\tt null}.  You can access the elements of
the array in the usual way:

\begin{verbatim}
    if (deck[3] == null) {
        System.out.println("No cards yet!");
    }
\end{verbatim}
%
But if you try to access the instance variables of the
non-existent {\tt Card}s, you will get a {\tt NullPointerException}.

\index{exception!NullPointer}
\index{run-time error}
\index{null}

\begin{verbatim}
    deck[2].rank;             // NullPointerException
\end{verbatim}
%
Nevertheless, that is the correct syntax for accessing the {\tt rank}
of the ``twoeth'' card in the deck(really the third---we started
at zero, remember?).  This is another example of composition, the
combination of the syntax for accessing an element of an array
and an instance variable of an object.

\index{composition}
\index{loop!nested}

The easiest way to populate the deck with {\tt Card} objects
is to write a nested loop:

\begin{verbatim}
    int index = 0;
    for(int suit = 0; suit <= 3; suit++) {
        for(int rank = 1; rank <= 13; rank++) {
            deck[index] = new Card(suit, rank);
            index++;
        }
    }
\end{verbatim}
%
The outer loop enumerates the suits, from 0 to 3.  For
each suit, the inner loop enumerates the ranks, from 1
to 13.  Since the outer loop iterates 4 times, and
the inner loop iterates 13 times, the total number of times
the body is executed is 52(13 times 4).

\index{index}

I used the variable {\tt index} to keep track of where in the
deck the next card should go.  The following state diagram
shows what the deck looks like after the first two cards
have been allocated:

\myfig{figure=figs/cardarray2.eps}

\begin{exercise}
Encapsulate this deck-building code in a method called
{\tt buildDeck} that takes no parameters and that returns a
fully-populated array of {\tt Card}s.
\end{exercise}

\index{encapsulation}



\section{The {\tt printDeck} method}
\label{printdeck}
\index{printDeck}
\index{print!array of Cards}

Whenever you are working with arrays, it is convenient to have
a method that will print the contents of the array.  We have
seen the pattern for traversing an array several times, so the
following method should be familiar:

\begin{verbatim}
public static void printDeck(Card[] deck) {
    for(int i=0; i<deck.length; i++) {
        printCard(deck[i]);
    }
}
\end{verbatim}

Since {\tt deck} has type {\tt Card[]}, an element of {\tt deck}
has type {\tt Card}.  Therefore, {\tt deck[i]} is a legal argument
for {\tt printCard}.



\section{Searching}
\label{findcard}
\index{searching}
\index{linear search}
\index{findCard}

The next method I want to write is {\tt findCard}, which searches
through an array of {\tt Card}s to see whether it contains a certain
card.  It may not be obvious why this method would be useful, but it
gives me a chance to demonstrate two ways to go searching for things,
a {\tt linear} search and a {\tt bisection} search.

\index{traverse}
\index{loop!search}

Linear search is the more obvious of the two; it involves traversing
the deck and comparing each card to the one we are looking for.  If we
find it we return the index where the card appears.  If it is not in
the deck, we return -1.

\begin{verbatim}
public static int findCard(Card[] deck, Card card) {
    for(int i = 0; i< deck.length; i++) {
        if (sameCard(deck[i], card)) return i;
    }
    return -1;
}
\end{verbatim}
%
The arguments of {\tt findCard} are named {\tt card} and {\tt deck}.
It might seem odd to have a variable with the same name as a type(the
{\tt card} variable has type {\tt Card}).  This is legal and common,
although it can sometimes make code hard to read.  In this case,
though, I think it works.

\index{statement!return}
\index{return!inside loop}

The method returns as soon as it discovers
the card, which means that we do not have to traverse the entire
deck if we find the card we are looking for.  If the loop terminates
without finding the card, we know the card is not in the deck
and return {\tt -1}.

If the cards in the deck are not in order, there is no way to search
that is faster than this.  We have to look at every card, since
otherwise there is no way to be certain the card we want is not
there.

\index{bisection search}

But when you look for a word in a dictionary, you don't search
linearly through every word.  The reason is that the words are in
alphabetical order.  As a result, you probably use an algorithm that
is similar to a bisection search:

\begin {enumerate}

\item Start in the middle somewhere.

\item Choose a word on the page and compare it to the word you
are looking for.

\item If you found the word you are looking for, stop.

\item If the word you are looking for comes after the word on
the page, flip to somewhere later in the dictionary and go to
step 2.

\item If the word you are looking for comes before the word on
the page, flip to somewhere earlier in the dictionary and go to
step 2.

\end {enumerate}

If you ever get to the point where there are two adjacent words on the
page and your word comes between them, you can conclude that your word
is not in the dictionary.  The only alternative is that your word has
been misfiled somewhere, but that contradicts our assumption that the
words are in alphabetical order.

In the case of a deck of cards, if we know that the cards are in
order, we can write a version of {\tt findCard} that is much faster.
The best way to write a bisection search is with a recursive method.
That's because bisection is naturally recursive.

\index{findBisect}

The trick is to write a method called {\tt findBisect} that takes
two indices as parameters, {\tt low} and {\tt high}, indicating the
segment of the array that should be searched(including both
{\tt low} and {\tt high}).

\begin{enumerate}

\item To search the array, choose an index between {\tt low} and {\tt
high}(call it {\tt mid}) and compare it to the card you are looking
for.

\item If you found it, stop.

\item If the card at {\tt mid} is higher than your card, search
in the range from {\tt low} to {\tt mid-1}.

\item If the card at {\tt mid} is lower than your card, search
in the range from {\tt mid+1} to {\tt high}.

\end{enumerate}

Steps 3 and 4 look suspiciously like recursive invocations.  Here's
what this all looks like translated into Java code:

\begin{verbatim}
public static int findBisect(Card[] deck, Card card, int low, int high) {
    int mid =(high + low) / 2;
    int comp = compareCard(deck[mid], card);

    if (comp == 0) {
        return mid;
    } else if (comp > 0) {
        return findBisect(deck, card, low, mid-1);
    } else {
        return findBisect(deck, card, mid+1, high);
    }
}
\end{verbatim}

Rather than call {\tt compareCard} three times, I called it once
and stored the result.

Although this code contains the kernel of a bisection search, it
is still missing a piece.  As it is currently written,
if the card is not in the deck, it will recurse forever.  We
need a way to detect this condition and deal with it properly
(by returning {\tt -1}).

\index{recursion}

The easiest way to tell that your card is not in the deck
is if there are {\em no} cards in the deck, which is the
case if {\tt high} is less than {\tt low}.  Well, there are
still cards in the deck, of course, but what I mean is that
there are no cards in the segment of the deck indicated by
{\tt low} and {\tt high}.

With that line added, the method works correctly:

\begin{verbatim}
public static int findBisect(Card[] deck, Card card, int low, int high) {
    System.out.println(low + ", " + high);

    if (high < low) return -1;

    int mid =(high + low) / 2;
    int comp = deck[mid].compareCard(card);

    if (comp == 0) {
        return mid;
    } else if (comp > 0) {
        return findBisect(deck, card, low, mid-1);
    } else {
        return findBisect(deck, card, mid+1, high);
    }
}
\end{verbatim}

I added a print statement at the beginning so I could watch
the sequence of recursive invocations and convince myself
that it would eventually reach the base case.  I tried out the
following code:

\begin{verbatim}
    Card card1 = new Card(1, 11);
    System.out.println(findBisect(deck, card1, 0, 51));
\end{verbatim}
%
And got the following output:

\begin{verbatim}
0, 51
0, 24
13, 24
19, 24
22, 24
23
\end{verbatim}
%
Then I made up a card that is not in the deck(the 15 of Diamonds),
and tried to find it.  I got the following:

\begin{verbatim}
0, 51
0, 24
13, 24
13, 17
13, 14
13, 12
-1
\end{verbatim}
%
These tests don't prove that this program is correct.  In fact, no
amount of testing can prove that a program is correct.  On the other
hand, by looking at a few cases and examining the code, you might be
able to convince yourself.

\index{testing}
\index{correctness}

The number of recursive invocations is fairly small, typically 6 or 7.
That means we only had to invoke {\tt compareCard} 6 or 7 times,
compared to up to 52 times if we did a linear search.  In general,
bisection is much faster than a linear search, and even more so for
large arrays.

Two common errors in recusive programs are forgetting to include a
base case and writing the recursive call so that the base case is never
reached.  Either error will cause an infinite recursion, in which case
Java will(eventually) throw a {\tt StackOverflowException}.

\index{recursion!infinite}
\index{infinite recursion}
\index{exception!StackOverflow}


\section{Decks and subdecks}
\index{deck}
\index{subdeck}

Looking at the interface to {\tt findBisect}

\begin{verbatim}
public static int findBisect(Card[] deck, Card card, int low, int high)
\end{verbatim}

\index{parameter!abstract}
\index{abstract parameter}

it might make sense to think of three of the parameters, {\tt deck},
{\tt low} and {\tt high}, as a single parameter that specifies a {\bf
subdeck}.  This way of thinking is quite common, and I sometimes think
of it as an {\bf abstract parameter}.  What I mean by ``abstract,'' is
something that is not literally part of the program text, but which
describes the function of the program at a higher level.

For example, when you invoke a method and pass an array and the bounds
{\tt low} and {\tt high}, there is nothing that prevents the invoked
method from accessing parts of the array that are out of bounds.  So
you are not literally sending a subset of the deck; you are really
sending the whole deck.  But as long as the recipient plays by the
rules, it makes sense to think of it, abstractly, as a subdeck.

There is one other example of this kind of abstraction that you might
have noticed in Section~\ref{objectops}, when I referred to an
``empty'' data structure.  The reason I put ``empty'' in quotation
marks was to suggest that it is not literally accurate.  All variables
have values all the time.  When you create them, they are given
default values.  So there is no such thing as an empty object.

But if the program guarantees that the current value of a variable is
never read before it is written, then the current value is irrelevant.
Abstractly, it makes sense to think of such a variable as ``empty.''

This kind of thinking, in which a program comes to take on meaning
beyond what is literally encoded, is a very important part of thinking
like a computer scientist.  Sometimes, the word ``abstract'' gets used
so often and in so many contexts that it comes to lose its meaning.
Nevertheless, abstraction is a central idea in computer science(as
well as many other fields).

\index{abstraction}

A more general definition of ``abstraction'' is ``The process of
modeling a complex system with a simplified description in order to
suppress unnecessary details while capturing relevant behavior.''


\section{Glossary}

\begin{description}

\item[encode:]  To represent one set of values using another
set of values, by constructing a mapping between them.

\item[shallow equality:]  Equality of references.  Two
references that point to the same object.

\item[deep equality:]  Equality of values.  Two references
that point to objects that have the same value.

\item[abstract parameter:]  A set of parameters that act together
as a single parameter.

\item[abstraction:]  The process of interpreting a program
(or anything else) at a higher level than what is literally
represented by the code.

\index{encode}
\index{shallow equality}
\index{deep equality}
\index{abstract parameter}
\index{abstraction}

\end{description}



\section{Exercises}

\begin{exercise}
Imagine a card game in which the objective is to get a collection of
cards with a total score of 21.  The total score for a hand is the
total of the scores for all the cards.  The score for each card is as
follows: aces count as 1, all face cards count as ten; for all other
cards the score is the same as the rank.  Example: the hand(Ace, 10,
Jack, 3) has a total score of 1 + 10 + 10 + 3 = 24.

Write a method called {\tt handScore} that takes an array of cards as
an argument and that adds up(and returns) the total score.
You should assume that the ranks of the cards are encoded according
to the mapping in Section~\ref{card}, with Aces encoded as 1.
\end{exercise}


\begin{exercise}
The {\tt printCard} method in Section~\ref{printcard} takes a
Card object and returns a string representation of the
card.

Write a class method for the {\tt Card} class called {\tt parseCard} that
takes a String and returns the corresponding card.  You can assume
that the String contains the name of a card in a valid format, as if
it had been produced by {\tt printCard}.

In other words, the string will contain a single space between the
rank and the word ``of,'' and between the word ``of'' and the suit.
If the string does not contain a legal card name, the method should
return a null object.

The purpose of this problem is to review the concept of parsing and
implement a method that parses a specific set of strings.
\end{exercise}


\begin{exercise}
Write a method called {\tt suitHist} that takes an array of Cards as a
parameter and that returns a histogram of the suits in the hand.
Your solution should only traverse the array once.
\end{exercise}


\begin{exercise}
Write a method called {\tt isFlush} that takes an array of Cards as a
parameter and that returns {\tt true} if the hand contains a flush,
and {\tt false} otherwise.  A flush is a poker hand that contains five
or more cards of the same suit.
\end{exercise}




\beforechapter
\chapter{Objects of Arrays}
\label{chap12}
\index{deck}
\index{array!of Cards}

\section{The {\tt Deck} class}
\label{deck}

In the previous chapter, we worked with an array of objects,
but I also mentioned that it is possible to have an object
that contains an array as an instance variable.  In this
chapter we are going to create a new object, called a {\tt Deck},
that contains an array of {\tt Card}s as an instance variable.

\index{instance variable}
\index{variable!instance}

The class definition looks like this

\begin{verbatim}
class Deck {
    Card[] cards;

    public Deck(int n) {
        cards = new Card[n];
    }
}
\end{verbatim}
%
The name of the instance variable is {\tt cards} to help
distinguish the {\tt Deck} object from the array of {\tt Card}s
that it contains.  Here is a state diagram showing what a
{\tt Deck} object looks like with no cards allocated:

\index{state diagram}
\index{constructor}

\myfig{figure=figs/deckobject.eps}

As usual, the constructor initializes the instance variable, but in
this case it uses {\tt new} to create the array of cards.
It doesn't create any cards to go in it, though.  For that we could
write another constructor that creates a standard 52-card deck and
populates it with {\tt Card} objects:

\begin{verbatim}
public Deck() {
    cards = new Card[52];
    int index = 0;
    for(int suit = 0; suit <= 3; suit++) {
        for(int rank = 1; rank <= 13; rank++) {
            cards[index] = new Card(suit, rank);
            index++;
        }
    }
}
\end{verbatim}

Notice how similar this method is to {\tt buildDeck}, except
that we had to change the syntax to make it a constructor.
To invoke it, we use {\tt new}:

\index{new}
\index{statement!new}

\begin{verbatim}
    Deck deck = new Deck();
\end{verbatim}
%
Now that we have a {\tt Deck} class, it makes sense to put
all the methods that pertain to {\tt Deck}s in the {\tt Deck}
class definition.  Looking at the methods we have written so
far, one obvious candidate is {\tt printDeck}(Section~\ref{printdeck}).
Here's how it looks, rewritten to work with a {\tt Deck}
object:

\index{printDeck}

\begin{verbatim}
public static void printDeck(Deck deck) {
    for(int i=0; i<deck.cards.length; i++) {
        Card.printCard(deck.cards[i]);
    }
}
\end{verbatim}
%
The most obvious thing we have to change is the type of the parameter,
from {\tt Card[]} to {\tt Deck}.  The second change is that we can no
longer use {\tt deck.length} to get the length of the array, because
{\tt deck} is a {\tt Deck} object now, not an array.  It contains an
array, but it is not, itself, an array.  Therefore, we have to write
{\tt deck.cards.length} to extract the array from the {\tt Deck}
object and get the length of the array.

For the same reason, we have to use {\tt deck.cards[i]} to access an
element of the array, rather than just {\tt deck[i]}.  The last change
is that the invocation of {\tt printCard} has to say explicitly that
{\tt printCard} is defined in the {\tt Card} class.

For some of the other methods, it is not obvious whether they should
be included in the {\tt Card} class or the {\tt Deck} class.  For
example, {\tt findCard} takes a {\tt Card} and a {\tt Deck} as
arguments; you could reasonably put it in either class.  As an
exercise, move {\tt findCard} into the {\tt Deck} class and rewrite it
so that the first parameter is a {\tt Deck} object rather than an
array of {\tt Card}s.


\section{Shuffling}
\label{shuffle}
\index{shuffling}

For most card games you need to be able to shuffle the deck;
that is, put the cards in a random order.  In Section~\ref{random}
we saw how to generate random numbers, but it is not obvious how
to use them to shuffle a deck.

One possibility is to model the way humans shuffle, which is usually
by dividing the deck in two and then reassembling the deck by choosing
alternately from each deck.  Since humans usually don't shuffle
perfectly, after about 7 iterations the order of the deck is pretty
well randomized.  But a computer program would have the annoying
property of doing a perfect shuffle every time, which is not really
very random.  In fact, after 8 perfect shuffles, you would find the
deck back in the same order you started in.  For a discussion of that
claim, see \url{http://www.wiskit.com/marilyn/craig.html} or do a web
search with the keywords ``perfect shuffle.''

A better shuffling algorithm is to traverse the deck one card at a
time, and at each iteration choose two cards and swap them.

\index{pseudocode}

Here is an outline of how this algorithm works.  To sketch the
program, I am using a combination of Java statements and English
words that is sometimes called {\bf pseudocode}:

\begin{verbatim}
    for(int i=0; i<deck.length; i++) {
        // choose a random number between i and deck.cards.length
        // swap the ith card and the randomly-chosen card
    }
\end{verbatim}
%
The nice thing about using pseudocode is that it often makes it
clear what methods you are going to need.  In this case, we
need something like {\tt randomInt}, which chooses a random
integer between the parameters {\tt low} and {\tt high},
and {\tt swapCards} which takes two indices and switches the
cards at the indicated positions.

\index{random number}

You can probably figure out how to write {\tt randomInt}
by looking at Section~\ref{random}, although you will have to
be careful about possibly generating indices that are out of range.

\index{swapCards}
\index{reference}

You can also figure out {\tt swapCards} yourself.  The only
tricky thing is to decide whether to swap just the references
to the cards or the contents of the cards.  Does it matter
which one you choose?  Which is faster?

I will leave the remaining implementation of these methods
as an exercise.


\section{Sorting}
\label{sorting}
\index{sorting}

Now that we have messed up the deck, we need a way to put it
back in order.  Ironically, there is an algorithm for
sorting that is very similar to the algorithm for shuffling.
This algorithm is sometimes called {\bf selection sort}
because it works by traversing the array repeatedly and 
selecting the lowest remaining card each time.

\index{selection sort}

During the first iteration we find the lowest card and swap
it with the card in the 0th position.  During the {\tt i}th, we find the
lowest card to the right of {\tt i} and swap it with the {\tt i}th
card.

Here is pseudocode for selection sort:

\begin{verbatim}
    for(int i=0; i<deck.length; i++) {
        // find the lowest card at or to the right of i
        // swap the ith card and the lowest card
    }
\end{verbatim}
%
Again, the pseudocode helps with the design of the {\bf helper
methods}.  In this case we can use {\tt swapCards} again,
so we only need one new one, called {\tt findLowestCard},
that takes an array of cards and an index where it should
start looking.

\index{helper method}
\index{method!helper}

Once again, I am going to leave the implementation up to
the reader.


\section {Subdecks}
\index{subdeck}

How should we represent a hand or some other subset of a full deck?
One possibility is to create a new class called {\tt Hand}, which
might extend {\tt Deck}.  Another possibility, the one I will
demonstrate, is to represent a hand with a {\tt Deck} object that
happens to have fewer than 52 cards.

We might want a method, {\tt subdeck}, that takes a Deck
and a range of indices, and that returns a new Deck that
contains the specified subset of the cards:

\begin{verbatim}
public static Deck subdeck(Deck deck, int low, int high) {
    Deck sub = new Deck(high-low+1);
	
    for(int i = 0; i<sub.cards.length; i++) {
        sub.cards[i] = deck.cards[low+i];
    }
    return sub;
}
\end{verbatim}

The length of the subdeck is {\tt high-low+1} because both the low
card and high card are included.  This sort of computation can be
confusing, and lead to ``off-by-one'' errors.  Drawing a picture is
usually the best way to avoid them.

\index{constructor}
\index{overloading}

Because we provide an argument with {\tt new}, the
contructor that gets invoked will be the first one, which only
allocates the array and doesn't allocate any cards.  Inside the
{\tt for} loop, the subdeck gets populated with copies of the
references from the deck.

The following is a state diagram of a subdeck being created with the
parameters {\tt low=3} and {\tt high=7}.  The result is a hand with 5
cards that are shared with the original deck; i.e. they are aliased.

\myfig{figure=figs/subdeck.eps}

\index{aliasing}
\index{reference}

I have suggested that aliasing is not generally a good idea, since
changes in one subdeck will be reflected in others, which is not the
behavior you would expect from real cards and decks.  But if the
objects in question are immutable, then aliasing is less dangerous.
In this case, there is probably no reason ever to change the
rank or suit of a card.  Instead we will create each card
once and then treat it as an immutable object.  So for {\tt Card}s
aliasing is a reasonable choice.


\section{Shuffling and dealing}
\index{shuffling}
\index{dealing}

In Section~\ref{shuffle} I wrote pseudocode for a shuffling algorithm.
Assuming that we have a method called {\tt shuffleDeck} that takes
a deck as an argument and shuffles it, we can create and shuffle
a deck:

\begin{verbatim}
    Deck deck = new Deck();
    shuffleDeck(deck);
\end{verbatim}
%
Then, to deal out several hands, we can use {\tt subdeck}:

\begin{verbatim}
   Deck hand1 = subdeck(deck, 0, 4);
   Deck hand2 = subdeck(deck, 5, 9);
   Deck pack = subdeck(deck, 10, 51);
\end{verbatim}
%
This code puts the first 5 cards in one hand, the next 5 cards
in the other, and the rest into the pack.

When you thought about dealing, did you think we should give out one
card at a time to each player in the round-robin style that is common
in real card games?  I thought about it, but then realized that it is
unnecessary for a computer program.  The round-robin convention is
intended to mitigate imperfect shuffling and make it more difficult
for the dealer to cheat.  Neither of these is an issue for a computer.

This example is a useful reminder of one of the dangers of engineering
metaphors: sometimes we impose restrictions on computers that are
unnecessary, or expect capabilities that are lacking, because we
unthinkingly extend a metaphor past its breaking point.  Beware of
misleading analogies.


\section {Mergesort}
\label{mergesort}
\index{efficiency}
\index{sorting}
\index{mergesort}

In Section~\ref{sorting}, we saw a simple sorting algorithm that turns
out not to be very efficient.  In order to sort $n$ items, it has to
traverse the array $n$ times, and each traversal takes an amount of
time that is proportional to $n$.  The total time, therefore, is
proportional to $n^2$.

In this section I will sketch a more efficient algorithm called {\bf
mergesort}.  To sort $n$ items, mergesort takes time proportional to
$n \log n$.  That may not seem impressive, but as $n$ gets big, the
difference between $n^2$ and $n \log n$ can be enormous.  Try out a
few values of $n$ and see.

The basic idea behind mergesort is this: if you have two subdecks,
each of which has been sorted, it is easy(and fast) to merge them
into a single, sorted deck.  Try this out with a deck of cards:

\begin{enumerate}

\item Form two subdecks with about 10 cards each and sort
them so that when they are face up the lowest cards are on
top.  Place both decks face up in front of you.

\item Compare the top card from each deck and choose the
lower one.  Flip it over and add it to the merged deck.

\item Repeat step two until one of the decks is empty.
Then take the remaining cards and add them to the merged
deck.

\end{enumerate}

The result should be a single sorted deck.  Here's what this
looks like in pseudocode:

\begin{verbatim}
public static Deck merge(Deck d1, Deck d2) {
    // create a new deck big enough for all the cards
    Deck result = new Deck(d1.cards.length + d2.cards.length);

    // use the index i to keep track of where we are in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;
		
    // the index k traverses the result deck
    for(int k = 0; k<result.cards.length; k++) {
			
        // if d1 is empty, d2 wins; if d2 is empty, d1 wins;
        // otherwise, compare the two cards
			
        // add the winner to the new deck
    }
    return result;
}
\end{verbatim}

The best way to test {\tt merge} is to build and shuffle a deck,
use subdeck to form two(small) hands, and then use the sort
routine from the previous chapter to sort the two halves.  Then
you can pass the two halves to {\tt merge} to see if it works.

\index{testing}

If you can get that working, try a simple implementation of
{\tt mergeSort}:

\begin{verbatim}
public static Deck mergeSort(Deck deck) {
    // find the midpoint of the deck
    // divide the deck into two subdecks
    // sort the subdecks using sortDeck
    // merge the two halves and return the result
}
\end{verbatim}

Then, if you get that working, the real fun begins!  The magical thing
about mergesort is that it is recursive.  At the point where you sort
the subdecks, why should you invoke the old, slow version of {\tt
sort}?  Why not invoke the spiffy new {\tt mergeSort} you are in the
process of writing?

\index{recursion}

Not only is that a good idea, it is {\em necessary} in order to
achieve the performance advantage I promised.  In order to make it
work, though, you have to add a base case so that it doesn't recurse
forever.  A simple base case is a subdeck with 0 or 1 cards.  If {\tt
mergesort} receives such a small subdeck, it can return it
unmodified, since it is already sorted.

The recursive version of {\tt mergesort} should look something
like this:

\begin{verbatim}
public static Deck mergeSort(Deck deck) {
    // if the deck is 0 or 1 cards, return it

    // find the midpoint of the deck
    // divide the deck into two subdecks
    // sort the subdecks using mergesort
    // merge the two halves and return the result
}
\end{verbatim}
%
As usual, there are two ways to think about recursive programs:
you can think through the entire flow of execution, or you
can make the ``leap of faith.''  I have deliberately constructed
this example to encourage you to make the leap of faith.

\index{leap of faith}

When you were using {\tt sortDeck} to sort the subdecks, you didn't
feel compelled to follow the flow of execution, right?  You just
assumed that the {\tt sortDeck} method would work because you already
debugged it.  Well, all you did to make {\tt mergeSort} recursive was
replace one sorting algorithm with another.  There is no reason to read
the program differently.

Well, actually, you have to give some thought to getting the
base case right and making sure that you reach it eventually,
but other than that, writing the recursive version should be
no problem.  Good luck!


\section{Glossary}

\begin{description}

\item[pseudocode:]  A way of designing programs by writing
rough drafts in a combination of English and Java.

\item[helper method:]  Often a small method that does not
do anything enormously useful by itself, but which helps
another, more useful, method.

\index{pseudocode}
\index{helper method}
\index{method!helper}


\end{description}

\section{Exercises}

\begin{exercise}
Write a version of {\tt findBisect} that takes a subdeck as an
argument, rather than a deck and an index range(see
Section~\ref{findcard}).  Which version is more error-prone?  Which
version do you think is more efficient?
\end{exercise}


\begin{exercise}
In the previous version of the Card class, a deck is implemented as an
array of {\tt Card}s.  For example, when we pass a ``deck'' as a
parameter, the actual type of the parameter is {\tt Card[]}.

In this chapter, we developed an alternative representation for a deck,
an object type named {\tt Deck} that contains an array of cards as an
instance variable.  In this exercise, you will implement the new
representation of a deck.

\begin{enumerate}

\item Add a second file, named {\tt Deck.java} to the program.
This file will contain the definition of the Deck class.

\item Type in the constructors for the {\tt Deck} class as
shown in Section~\ref{deck}.

\item Of the methods currently in the {\tt Card} class, decide
which ones would be more appropriate as members of the new
{\tt Deck} class.  Move them there and make any changes necessary
to get the program to compile and run again.

\item Look over the program and identify every place where an
array of {\tt Card}s is being used to represent a deck.  Modify
the program throughout so that it uses a {\tt Deck} object
instead.  You can use the version of {\tt printDeck} in
Section~\ref{deck} as an example.

It is probably a good idea to make this transformation
one method at a time, and test the program after each change.
On the other hand, if you are confident you know what you are
doing, you can make most of the changes with search-and-replace
commands.
\end{enumerate}
\end{exercise}


\begin{exercise}
The goal of this exercise is to implement the shuffling and
sorting algorithms from this chapter.

\begin{enumerate}

\item Write a method called {\tt swapCards} that takes a
deck(array of cards) and two indices, and that switches
the cards at those two locations.

HINT: it should switch the references to the two cards, rather than
the contents of the two objects.  This is not only faster, but it
makes it easier to deal with the case where cards are aliased.

\item Write a method called {\tt shuffleDeck} that uses the algorithm
in Section~\ref{shuffle}.  You might want to use the {\tt randomInt}
method from Exercise~\ref{ex.randomint}.

\item Write a method called {\tt findLowestCard} that uses
the {\tt compareCard} method to find the lowest card
in a given range of the deck(from {\tt lowIndex} to {\tt highIndex},
including both).

\item Write a method called {\tt sortDeck} that arranges
a deck of cards from lowest to highest.

\end{enumerate}
\end{exercise}


\begin{exercise}
In order to make life more difficult for card-counters, many casinos
now use automatic shuffling machines that can do incremental shuffling,
which means that after each hand, the used cards are returned to the
deck and, instead of reshuffling the entire deck, the new cards are
inserted in random locations.

Write a method called {\tt incrementalShuffle} that takes a Deck
and a Card and that inserts the card into the deck at a random location.
This is an example of an {\bf incremental algorithm}.
\end{exercise}


\begin{exercise}
The goal of this exercise is to write a program that generates
random poker hands and classifies them, so that we can estimate
the probability of the various poker hands.  Don't worry if you
don't play poker; I'll tell you everything you need to know.

\begin{enumerate}

\item As a warmup, write a program that uses {\tt shuffleDeck} and
{\tt subdeck} to generate and print four random poker hands with
five cards each.  Did you get anything good?
Here are the possible poker hands, in increasing order of value:

\begin{description}

\item[pair:] two cards with the same rank
\vspace{-0.05in}

\item[two pair:] two pairs of cards with the same rank
\vspace{-0.05in}

\item[three of a kind:] three cards with the same rank
\vspace{-0.05in}

\item[straight:] five cards with ranks in sequence
\vspace{-0.05in}

\item[flush:] five cards with the same suit
\vspace{-0.05in}

\item[full house:] three cards with one rank, two cards with another
\vspace{-0.05in}

\item[four of a kind:] four cards with the same rank
\vspace{-0.05in}

\item[straight flush:] five cards in sequence and with the same suit
\vspace{-0.05in}

\end{description} 


\item Write a method called {\tt isFlush} that takes a Deck
as a parameter and returns a boolean indicating whether the
hand contains a flush.

\item Write a method called {\tt isThreeKind} that takes a hand
and returns a boolean indicating whether the hand contains
Three of a Kind.

\item Write a loop that generates a few thousand hands and
checks whether they contain a flush or three of a kind.
Estimate the probability of getting one of those hands.

\item Write methods that test for the other poker hands.  Some
are easier than others.  You might find it useful to write some
general-purpose helper methods that can be used for more than one
test.

\item In some poker games, players get seven cards each, and
they form a hand with the best five of the seven.  Modify your
program to generate seven-card hands and recompute the probabilities.

\end{enumerate}
\end{exercise}


\begin{exercise}
As a special challenge, think of algorithms to check for various
poker hands if there are wild cards.  For example, if ``deuces are
wild,'' that means that if you have a card with rank 2, you can
use it to represent any card in the deck.
\end{exercise}


\begin{exercise}
The goal of this exercise is to implement mergesort.

\begin{enumerate}

\item Using the pseudocode in Section~\ref{mergesort}, write the
method called {\tt merge}.  Be sure to test it before trying to use it
as part of a {\tt mergeSort}.

\item Write the simple version of {\tt mergeSort}, the one that
divides the deck in half, uses {\tt sortDeck} to sort the two
halves, and uses {\tt merge} to create a new, fully-sorted deck.

\item Write the fully recursive version of {\tt mergeSort}.
Remember that {\tt sortDeck} is a modifier and {\tt mergeSort} is
a function, which means that they get invoked differently:

\begin{verbatim}
sortDeck(deck);              // modifies existing deck
deck = mergeSort(deck);      // replaces old deck with new
\end{verbatim}

\end{enumerate}
\end{exercise}



\beforechapter
\label{chap13}
\chapter{Object-oriented programming}

\section{Programming languages and styles}
\index{programming language}
\index{language!programming}
\index{programming style}
\index{object-oriented programming}
\index{functional programming}
\index{procedural programming}
\index{programming!object-oriented}
\index{programming!functional}
\index{programming!procedural}

There are many programming languages in the world, and almost as many
programming styles(sometimes called paradigms).  Three styles that
have appeared in this book are procedural, functional, and
object-oriented.  Although Java is usually thought of as an
object-oriented language, it is possible to write Java programs in any
style.  The style I have demonstrated in this book is pretty much
procedural.  Existing Java programs and libraries are
written in a mixture of all three styles, but they tend to be more
object-oriented than the programs in this book.

It's not easy to define what object-oriented programming is,
but here are some of its characteristics:

\begin{itemize}

\item Object definitions(classes) usually correspond to 
relevant real-world objects.  For example, in Chapter~\ref{deck},
the creation of the {\tt Deck} class was a step toward object-oriented
programming.

\item The majority of methods are object methods(the kind you
invoke on an object) rather than class methods(the kind you just
invoke).  So far all the methods we have written have been class
methods.  In this chapter we will write some object methods.

\item The language feature most associated with object-oriented
programming is {\bf inheritance}.  I will cover inheritance later in
this chapter.

\end{itemize}

\index{inheritance}

Recently object-oriented programming has become quite popular, and
there are people who claim that it is superior to other styles in
various ways.  I hope that by exposing you to a variety of styles I
have given you the tools you need to understand and evaluate these
claims.


\section{Object and class methods}
\index{object method}
\index{method!object}
\index{class method}
\index{method!class}
\index{static}

There are two types of methods in Java, called {\bf class methods} and
{\bf object methods}.  So far, every method we have written has been a
class method.  Class methods are identified by the keyword {\tt
static} in the first line.  Any method that does not have the keyword
{\tt static} is an object method.

Although we have not written any object methods, we have invoked some.
Whenever you invoke a method ``on'' an object, it's an object method.
For example, {\tt charAt} and the other methods we invoked on {\tt String}
objects are all object methods.

Anything that can be written as a class method can also be written as an
object method, and vice versa.  Sometimes it is just more natural to
use one or the other.  For reasons that will be clear soon, object
methods are often shorter than the corresponding class methods.


\section{The current object}
\index{current object}
\index{object!current}
\index{this}

When you invoke a method on an object, that object becomes {\bf the
current object}.  Inside the method, you can refer to the instance
variables of the current object by name, without having to specify the
name of the object.

\index{constructor}

Also, you can refer to the current object using the keyword {\tt
this}.  We have already seen {\tt this} used in constructors.  In
fact, you can think of constructors as being a special kind of object
method.


\section{Complex numbers}
\index{complex number}
\index{Complex}
\index{class!Complex}
\index{arithmetic!complex}

As a running example for the rest of this chapter we will consider a
class definition for complex numbers.  Complex numbers are useful for
many branches of mathematics and engineering, and many computations
are performed using complex arithmetic.  A complex number is the sum
of a real part and an imaginary part, and is usually written in the
form $x + yi$, where $x$ is the real part, $y$ is the imaginary part,
and $i$ represents the square root of -1.
Thus, $i \cdot i = -1$.

The following is a class definition for a new object type called {\tt
Complex}:

\begin{verbatim}
class Complex
{
    // instance variables
    double real, imag;

    // constructor
    public Complex() {
        this.real = 0.0;  this.imag = 0.0;
    }
	
    // constructor
    public Complex(double real, double imag) {
        this.real = real;  
        this.imag = imag;
    }
}
\end{verbatim}
%
There should be nothing surprising here.  The instance variables
are doubles that contain the real and imaginary parts.
The two constructors are the usual kind: one takes no parameters
and assigns default values to the instance variables, the other
takes parameters that are identical to the instance variables.
As we have seen before, the keyword {\tt this} is used to refer
to the object being initialized.

\index{instance variable}
\index{variable!instance}
\index{constructor}

In {\tt main}, or anywhere else we want to create {\tt Complex}
objects, we have the option of creating the object and then
setting the instance variables, or doing both at the same time:

\begin{verbatim}
    Complex x = new Complex();
    x.real = 1.0;
    x.imag = 2.0;
    Complex y = new Complex(3.0, 4.0);
\end{verbatim}


\section{A function on {\tt Complex} numbers}
\index{operator!Complex}
\index{method!function}
\index{pure function}

Let's look at some of the operations we might want to perform
on complex numbers.  The absolute value of a complex number is
defined to be $\sqrt {x^2 + y^2}$.  The {\tt abs} method is
a pure function that computes the absolute value.  Written as
a class method, it looks like this:

\begin{verbatim}
// class method
public static double abs(Complex c) {
    return Math.sqrt(c.real * c.real + c.imag * c.imag);
} 
\end{verbatim}
%
This version of {\tt abs} calculates the absolute value of {\tt c},
the {\tt Complex} object it receives as a parameter.  The next version
of {\tt abs} is an object method; it calculates the absolute value of
the current object(the object the method was invoked on).  Thus,
it does not receive any parameters:

\begin{verbatim}
// object method
public double abs() {
    return Math.sqrt(real*real + imag*imag);
}
\end{verbatim}
%
I removed the keyword {\tt static} to indicate that this is an object
method.  Also, I eliminated the unnecessary parameter.  Inside the
method, I can refer to the instance variables {\tt real} and {\tt
imag} by name without having to specify an object.  Java knows
implicitly that I am referring to the instance variables of the
current object.  If I wanted to make it explicit, I could have used
the keyword {\tt this}:

\begin{verbatim}
// object method
public double abs() {
    return Math.sqrt(this.real * this.real + this.imag * this.imag);
}
\end{verbatim}

But that would be longer and not really any clearer.  To invoke
this method, we invoke it on an object, for example

\begin{verbatim}
    Complex y = new Complex(3.0, 4.0);
    double result = y.abs();
\end{verbatim}


\section{Another function on {\tt Complex} numbers}

Another operation we might want to perform on complex numbers
is addition.  You can add complex numbers by adding the real
parts and adding the imaginary parts.  Written as a class method,
that looks like:

\begin{verbatim}
public static Complex add(Complex a, Complex b) {
    return new Complex(a.real + b.real, a.imag + b.imag);
}
\end{verbatim}

To invoke this method, we would pass both operands as arguments:

\begin{verbatim}
    Complex sum = add(x, y);
\end{verbatim}

Written as an object method, it would take only one argument,
which it would add to the current object:

\begin{verbatim}
public Complex add(Complex b) {
    return new Complex(real + b.real, imag + b.imag);
}
\end{verbatim}

Again, we can refer to the instance variables of the current
object implicitly, but to refer to the instance variables of
{\tt b} we have to name {\tt b} explicitly using dot notation.
To invoke this method, you invoke it on one of the operands
and pass the other as an argument.

\index{dot notation}

\begin{verbatim}
    Complex sum = x.add(y);
\end{verbatim}

From these examples you can see that the current object({\tt this})
can take the place of one of the parameters.  For this reason,
the current object is sometimes called an {\bf implicit parameter}.


\section{A modifier}
\index{modifier}
\index{method!modifier}

As yet another example, we'll look at {\tt conjugate}, which is
a modifier method that transforms a {\tt Complex} number into
its complex conjugate.  The complex conjugate of $x + yi$ is
$x - yi$.

As a class method, this looks like:

\begin{verbatim}
public static void conjugate(Complex c) {
    c.imag = -c.imag;
}
\end{verbatim}

As an object method, it looks like

\begin{verbatim}
public void conjugate() {
    imag = -imag;
}
\end{verbatim}

By now you should be getting the sense that converting a method
from one kind to another is a mechanical process.  With a little
practice, you will be able to do it without giving it much
thought, which is good because you should not be constrained to
writing one kind of method or the other.  You should be equally
familiar with both so that you can choose whichever one seems
most appropriate for the operation you are writing.

For example, I think that {\tt add} should be written as a class
method because it is a symmetric operation of two operands, and
it makes sense for both operands to appear as parameters.  To me, it
seems odd to invoke the method on one of the operands and pass
the other as an argument.

On the other hand, simple operations that apply to a single object
can be written most concisely as object methods(even if they
take some additional arguments).


\section{The {\tt toString} method}
\index{toString}
\index{method!toString}

Every object type has a method called {\tt toString} that generates
a string representation of the object.
When you print an object using {\tt print} or {\tt println},
Java invokes the object's {\tt toString} method.  The default
version of {\tt toString} returns a string that contains the type
of the object and a unique identifier(see Section~\ref{printobject}).
When you define a new object
type, you can {\bf override} the default behavior by providing a
new method with the behavior you want.

Here is what {\tt toString} might look like for the {\tt Complex}
class:

\begin{verbatim}
public String toString() {
    return real + " + " + imag + "i";
}
\end{verbatim}
%
The return type for {\tt toString} is {\tt String}, naturally,
and it takes no parameters.  You can invoke {\tt toString} in
the usual way:

\begin{verbatim}
    Complex x = new Complex(1.0, 2.0);
    String s = x.toString();
\end{verbatim}
%
or you can invoke it indirectly through {\tt println}:

\begin{verbatim}
    System.out.println(x);
\end{verbatim}
%
In this case, the output is {\tt 1.0 + 2.0i}.

This version of {\tt toString} does not look good if the imaginary
part is negative.  As an exercise, write a better version.


\section{The {\tt equals} method}
\index{equals}
\index{method!equals}

When you use the {\tt ==} operator to compare two objects,
what you are really asking is, ``Are these two things the same
object?''  That is, do both objects refer to the same location
in memory.

For many types, that is not the appropriate definition of
equality.  For example, two complex numbers are equal if their
real parts are equal and their imaginary parts are equal.  They
don't have to be the same object.

\index{type!object}

When you define a new object type, you can provide your own
definition of equality by providing an object method called
{\tt equals}.  For the {\tt Complex} class, this looks like:

\begin{verbatim}
public boolean equals(Complex b) {
    return(real == b.real && imag == b.imag);
}
\end{verbatim}
%
By convention, {\tt equals} is always an object method that
returns a {\tt boolean}.

The documentation of {\tt equals} in the {\tt Object} class
provides some guidelines you should keep in mind when you
make up your own definition of equality:

\begin{quote}

The {\tt equals} method implements an equivalence relation: 

\index{equality}
\index{identity}

\begin{itemize}

\item It is reflexive: for any reference value {\tt x}, {\tt
x.equals(x)} should return {\tt true}.

\item It is symmetric: for any reference values {\tt x} and {\tt y},
{\tt x.equals(y)} should return {\tt true} if and only if {\tt
y.equals(x)} returns {\tt true}.

\item It is transitive: for any reference values {\tt x}, {\tt y}, and
{\tt z}, if {\tt x.equals(y)} returns {\tt true} and {\tt y.equals(z)}
returns {\tt true}, then {\tt x.equals(z)} should return {\tt true}.

\item It is consistent: for any reference values {\tt x} and {\tt y},
multiple invocations of {\tt x.equals(y)} consistently return {\tt true} or
consistently return {\tt false}.

\item For any reference value {\tt x}, {\tt x.equals(null)} should
return {\tt false}.

\end{itemize}

\end{quote}

The definition of {\tt equals} I provided satisfies all these
conditions except one.  Which one?  As an exercise, fix it.


\section{Invoking one object method from another}
\index{method!invoking}

As you might expect, it is legal and common to invoke
one object method from another.  For example, to normalize a
complex number, you divide both parts by the absolute
value.  It may not be obvious why this is useful, but it is.

Let's write the method {\tt normalize} as an object method, and
let's make it a modifier.

\begin{verbatim}
public void normalize() {
    double d = this.abs();
    real = real/d;
    imag = imag/d;
}
\end{verbatim}
%
The first line finds the absolute value of the current object
by invoking {\tt abs} on the current object.  In this case
I named the current object explicitly, but I could have left
it out.  If you invoke one object method within another, Java
assumes that you are invoking it on the current object.

\begin{exercise}
Rewrite {\tt normalize} as a pure function. 
Then rewrite it as a class method.
\end{exercise}


\section{Oddities and errors}
\index{method!object}
\index{method!class}
\index{overloading}

If you have both object methods and class methods in the same class
definition, it is easy to get confused.  A common way to organize a
class definition is to put all the constructors at the beginning,
followed by all the object methods and then all the class methods.

You can have an object method and a class method with the same
name, as long as they do not have the same number and types of
parameters.  As with other kinds of overloading, Java decides
which version to invoke by looking at the arguments you provide.

\index{static}

Now that we know what the keyword {\tt static} means, you
have probably figured out that {\tt main} is a class method,
which means that there is no ``current object'' when it is invoked.

\index{current object}
\index{this}
\index{instance variable}
\index{variable!instance}

Since there is no current object in a class method, it is an
error to use the keyword {\tt this}.  If you try, you might get
an error message like: ``Undefined variable: this.''  Also, you
cannot refer to instance variables without using dot notation
and providing an object name.  If you try, you might get 
``Can't make a static reference to nonstatic variable...''
This is not one of the better error messages, since it uses
some non-standard language.  For example, by ``nonstatic
variable'' it means ``instance variable.''  But once you know
what it means, you know what it means.


\section{Inheritance}
\index{inheritance}

The language feature that is most often associated with
object-oriented programming is {\bf inheritance}.  Inheritance is the
ability to define a new class that is a modified version of a
previously-defined class.

The primary advantage of this feature is that you can add new methods
or instance variables to an existing class without modifying the
existing class.  This is particularly useful for Java classes,
since you can't modify them even if you want to.

The reason inheritance is called ``inheritance'' is that the
new class inherits all the instance variables and methods
of the existing class.  Extending this metaphor, the existing
class is sometimes called the {\bf parent} class.


\section{Drawable rectangles}
\index{Rectangle}
\index{class!Rectangle}
\index{drawable}

An an example of inheritance, we are going to take the existing
{\tt Rectangle} class and make it ``drawable.''  That is, we are going to
create a new class called {\tt DrawableRectangle} that will have all
the instance variables and methods of a {\tt Rectangle}, plus an
additional method called {\tt draw} that will take a {\tt Graphics}
object as a parameter and draw the rectangle.

The class definition looks like this:

\begin{verbatim}
import java.awt.*;

class DrawableRectangle extends Rectangle {

    public void draw(Graphics g) {
        g.drawRect(x, y, width, height);
    }
}
\end{verbatim}

Yes, that's really all there is in the whole class definition.  The
first line imports the {\tt java.awt} package, which is where {\tt
Rectangle} and {\tt Graphics} are defined.

\index{AWT}
\index{import}
\index{statement!import}

The next line indicates that {\tt DrawableRectangle} inherits from
{\tt Rectangle}.  The keyword {\tt extends} is used to identify the
class we are inheriting from, which is called the {\bf parent class}.

The rest is the definition of the {\tt draw} method, which refers to
the instance variables {\tt x}, {\tt y}, {\tt width} and {\tt height}.
It might seem odd to refer to instance variables that don't appear in
this class definition, but remember that they are inherited from the
parent class.

To create and draw a {\tt DrawableRectangle}, you could use
the following:

\begin{verbatim}
public static void draw(Graphics g, int x, int y, int width, int height) {
    DrawableRectangle dr = new DrawableRectangle();
    dr.x = 10;       dr.y = 10;
    dr.width = 200;  dr.height = 200;
    dr.draw(g);
}
\end{verbatim}

The parameters of {\tt draw} are a {\tt Graphics} object and
the bounding box of the drawing area(not the coordinates of the
rectangle).

It might seem odd to use {\tt new} for a class
that has no constructors.  {\tt DrawableRectangle}
inherits the default constructor of its parent class, so there
is no problem there.

\index{constructor}

We can set the instance variables of {\tt dr} and invoke methods
on it in the usual way.  When we invoke {\tt draw}, Java invokes
the method we defined in {\tt DrawableRectangle}.  If we invoked
{\tt grow} or some other {\tt Rectangle} method on {\tt dr}, Java
would know to use the method defined in the parent class.


\section{The class hierarchy}
\index{class hierarchy}
\index{Object}
\index{parent class}
\index{class!parent}

In Java, all classes extend some other class.  The most basic class is
called {\tt Object}.  It contains no instance variables, but it does
provide the methods {\tt equals} and {\tt toString}, among others.

Many classes extend {\tt Object}, including almost all of the classes
we have written and many Java classes, like {\tt
Rectangle}.  Any class that does not explicitly name a parent inherits
from {\tt Object} by default.

Some inheritance chains are longer, though.  For example, 
in Appendix~\ref{slate}, the
{\tt Slate} class
extends {\tt Frame}, which
extends {\tt Window}, which extends {\tt Container}, which extends
{\tt Component}, which extends {\tt Object}.  No matter how long the
chain, {\tt Object} is the ultimate parent of all classes.

All the classes in Java can be organized into a ``family tree'' that
is called the class hierarchy.  {\tt Object} usually appears at the
top, with all the ``child'' classes below.  If you look at the
documentation of {\tt Frame}, for example, you will see the part of
the hierarchy that makes up {\tt Frame}'s pedigree.


\section {Object-oriented design}
\index{object-oriented design}

Inheritance is a powerful feature.  Some programs that would be
complicated without it can be written concisely and simply
with it.  Also, inheritance can facilitate code reuse, since you can
customize the behavior of existing classes without having to modify
them.

On the other hand, inheritance can make programs difficult to read,
since it is sometimes not clear, when a method is invoked, where to
find the definition.  For example, one of the methods you can invoke
on a {\tt Slate} is {\tt getBounds}.  Can you find the documentation
for {\tt getBounds}?  It turns out that {\tt getBounds} is defined in
the parent of the parent of the parent of the parent of {\tt Slate}.

Also, many of the things that can be done using inheritance can
be done almost as elegantly(or more so) without it.


\section{Glossary}

\begin{description}

\item[object method:]  A method that is invoked on an object,
and that operates on that object, which is referred to by
the keyword {\tt this} in Java or ``the current object'' in
English.  Object methods do not have the keyword {\tt static}.

\item[class method:]  A method with the keyword {\tt static}.
Class methods are not invoked on objects and they do not have
a current object.

\item[current object:]  The object on which an object method
is invoked.  Inside the method,
the current object is referred to by {\tt this}.

\item[{\tt this}:]  The keyword that refers to the current object.

\item[implicit:]  Anything that is left unsaid or implied.  Within
an object method, you can refer to the instance variables
implicitly(without naming the object).

\item[explicit:]  Anything that is spelled out completely.  Within
a class method, all references to the instance variables have to
be explicit.

\index{object method}
\index{class method}
\index{current object}
\index{this}
\index{implicit}
\index{explicit}

\end{description}


\section{Exercises}

\begin{exercise}

Transform the following class method into an object method.

\begin{verbatim}
public static double abs(Complex c) {
    return Math.sqrt(c.real * c.real + c.imag * c.imag);
} 
\end{verbatim}
\end{exercise}


\begin{exercise}
Transform the following object method into a class method.

\begin{verbatim}
public boolean equals(Complex b) {
    return(real == b.real && imag == b.imag);
}
\end{verbatim}
\end{exercise}


\begin{exercise}

This exercise is a continuation of Exercise~\ref{ex.rational}.
The purpose is to practice the syntax of object methods and
get familiar with the relevant error messages.

\begin{enumerate}

\item Transform the methods in the {\tt Rational} class
from class methods to object methods, and make the necessary
changes in {\tt main}.

\item Make a few mistakes.  Try invoking class methods as if
they were object methods and vice-versa.  Try to get a sense for
what is legal and what is not, and for the error messages that
you get when you mess things up.

\item Think about the pros and cons of
class and object methods.  Which is more concise(usually)?
Which is a more natural way to express computation(or, maybe
more fairly, what kind of computations can be expressed most
naturally using each style)?

\end{enumerate}
\end{exercise}


\beforechapter

\appendix

\chapter{Program development plan}
\label{development}

If you are spending a lot of time debugging, it is probably
because you do not have an effective {\bf program development
plan}.

A typical, bad program development plan goes something like
this:

\begin{enumerate}

\item Write an entire method.

\item Write several more methods.

\item Try to compile the program.

\item Spend an hour finding syntax errors.

\item Spend an hour finding run time errors.

\item Spend three hours finding semantic errors.

\end{enumerate}

The problem, of course, is the first two steps.  If you
write more than one method, or even an entire method, before
you start the debugging process, you are likely to write more
code than you can debug.

If you find yourself in this situation, the {\em only} solution
is to remove code until you have a working program again, and
then gradually build the program back up.  Beginning programmers
are often unwilling to do this, because their carefully crafted
code is precious to them.  To debug effectively, you have to
be ruthless!


Here is a better program development plan:

\begin{enumerate}

\item Start with a working program that does something visible,
   like printing something.

\item Add a small number of lines of code at a time,
   and test the program after every change.

\item Repeat until the program does what it is supposed to do.

\end{enumerate}

After every change, the program should produce some visible effect
that demonstrates the new code.  This approach to programming can save
a lot of time.  Because you only add a few lines of code at a time, it
is easy to find syntax errors.  Also, because each version of the
program produces a visible result, you are constantly testing your
mental model of how the program works.  If your mental model is
erroneous, you will be confronted with the conflict(and have a chance
to correct it) before you have written a lot of erroneous code.

One problem with this approach is that it is often
difficult to figure out a path from the starting place
to a complete and correct program.

I will demonstrate by developing a method called {\tt isIn} that takes
a String and a character, and that returns a boolean: {\tt true} if
the character appears in the String and {\tt false} otherwise.

\begin{enumerate}

\item The first step is to write the shortest possible method
that will compile, run, and do something visible:

\begin{verbatim}
public static boolean isIn(char c, String s) {
    System.out.println("isIn");
    return false;
}
\end{verbatim}

Of course, to test the method we have to invoke it.  In
{\tt main}, or somewhere else in a working program, we need
to create a simple test case.

We'll start with a case where the character appears in the
String(so we expect the result to be {\tt true}).

\begin{verbatim}
public static void main(String[] args) {
    boolean test = isIn('n', "banana");
    System.out.println(test);
}
\end{verbatim}

If everything goes according to plan, this code will compile,
run, and print the word {\tt isIn} and the value {\tt false}.
Of course, the answer isn't correct, but at this point we know
that the method is getting invoked and returning a value.

In my programming career, I have wasted way too much time debugging
a method, only to discover that it was never getting invoked.
If I had used this development plan, it never would have happened.

\item The next step is to check the parameters the method
receives.

\begin{verbatim}
public static boolean isIn(char c, String s) {
    System.out.println("isIn looking for " + c);
    System.out.println("in the String " + s);
    return false;
}
\end{verbatim}

The first print statement allows us to confirm that {\tt isIn}
is looking for the right letter.  The second statement confirms
that we are looking in the right place.

Now the output looks like this:

%changed to 'n' to match the call to isIn from above
\begin{verbatim}
isIn looking for n
in the String banana
\end{verbatim}

Printing the parameters might seem silly, since we know what they
are supposed to be.  The point is to confirm that they are what we
think they are.


\item To traverse the String, we can take advantage of the code
from Section~\ref{traverse}.  In general, it is a great idea to
reuse code fragments rather than writing them from scratch.

\begin{verbatim}
public static boolean isIn(char c, String s) {
    System.out.println("isIn looking for " + c);
    System.out.println("in the String " + s);

    int index = 0;
    while (index < s.length()) {
        char letter = s.charAt(index);
        System.out.println(letter);
        index = index + 1;
    }
    return false;
}
\end{verbatim}

Now when we run the program it prints the characters in
the String one at a time.  
If all goes well, we can confirm that
the loop examines all the letters in the String.


\item So far we haven't given much thought to what this method
is going to do.  At this point we probably need to figure out an
algorithm.  The simplest algorithm is a linear search, which
traverses the vector and compares each element to the target word.

Happily, we have already written the code that traverses the
vector.  As usual, we'll proceed by adding just a few lines
at a time:

\begin{verbatim}
public static boolean isIn(char c, String s) {
    System.out.println("isIn looking for " + c);
    System.out.println("in the String " + s);

    int index = 0;
    while (index < s.length()) {
        char letter = s.charAt(index);
        System.out.println(letter);
        if (letter == c) {
            System.out.println("found it");
        }
        index = index + 1;
    }
    return false;
}
\end{verbatim}

As we traverse the String, we compare each letter to the target
character.  If we find it, we print something, so
that when the new code executes it produces a visible effect.

\item At this point we are pretty close to working code.  The
next change is to return from the method if we find what we are
looking for:

\begin{verbatim}
public static boolean isIn(char c, String s) {
    System.out.println("isIn looking for " + c);
    System.out.println("in the String " + s);

    int index = 0;
    while (index < s.length()) {
        char letter = s.charAt(index);
        System.out.println(letter);
        if (letter == c) {
            System.out.println("found it");
            return true;
        }
        index = index + 1;
    }
    return false;
}
\end{verbatim}

If we find the target character, we return {\tt true}.
If we get all the way through the loop without finding it, then
the correct return value is {\tt false}.

If we run the program at this point, we should get

\begin{verbatim}
isIn looking for n
in the String banana
b
a
n
found it
true
\end{verbatim}


\item The next step is to make sure that the other test cases
work correctly.  First, we should confirm that the method returns
{\tt false} if the character is not in the String.
Then we should check some of the typical troublemakers, like
an empty String, {\tt ""}, or a String with a single character.

As always, this kind of testing can help find bugs if there
are any, but it can't tell you if the method is correct.

\item The penultimate step is to remove or comment out the print
statements.

\begin{verbatim}
public static boolean isIn(char c, String s) {
    int index = 0;
    while (index < s.length()) {
        char letter = s.charAt(index);
        if (letter == c) {
	    return true;
        }
        index = index + 1;
    }
    return false;
}
\end{verbatim}

Commenting out the print statements is a good idea if you
think you might have to revisit this method later.  But if
this is the final version of the method, and you are convinced
that it is correct, you should remove them.

Removing the comments allows you to see the code most clearly,
which can help you spot any remaining problems.

If there is anything about the code that is not obvious, you
should add comments to explain it.  Resist the temptation to
translate the code line by line.  For example, no one needs this:

\begin{verbatim}
        // if letter equals c, return true
        if (letter == c) {
            return true;
        }
\end{verbatim}

You should use comments to explain non-obvious code, to warn
about conditions that could cause errors, and to document any
assumptions that are built into the code.  Also, before each
method, it is a good idea to write an abstract description of
what the method does.


\item The final step is to examine the code and see if you
can convince yourself that it is correct.  
At this point we know that the method is syntactically correct,
because it compiles.
To check for run time errors, you should find every statement
that can cause an error and figure out what conditions cause
the error.

In this method, the only statement that can cause a run-time error is
{\tt s.charAt(index)}.  This statement will fail if {\tt s} is {\tt
null} or if the index is out of bounds.  Since we get {\tt s} as a
parameter, we can't be sure that it is not {\tt null}; all we can do
is check.  In general, it is a good idea for methods to make sure
their parameters are legal.  The structure of the {\tt while} loop
ensures that {\tt index} is always between 0 and {\tt s.length-1}.  If
we check all the problem conditions, or prove that they cannot happen,
then we can prove that this method will not cause a run time error.

We haven't proven yet that the method is semantically correct, but by
proceeding incrementally, we have avoided many possible errors.  For
example, we already know that the method is getting parameters
correctly and that the loop traverses the entire String.  We also know
that it is comparing characters successfully, and returning {\tt true} if
it finds the target.  Finally, we know that if the loop exits,
%of course the loop exists, we just wrote it!
the target is not in the String.

Short of a formal proof, that is probably the best we can do.

\end{enumerate}



\beforechapter
\chapter{Debugging}
\label{debug}
\index{debugging}

There are a few different kinds of errors that can occur
in a program, and it is useful to distinguish between them
in order to track them down more quickly.

\begin{itemize}

\item Syntax errors are produced by the compiler and usually
indicate that there is something wrong with the syntax of the
program.  Example: omitting the semi-colon at the end of a
statement.

\item Run-time errors are produced by the run-time system if something
goes wrong while the program is running.  Most run-time errors
are Exceptions.  Example: an infinite recursion eventually causes
a StackOverflowException.

\item Semantic errors are problems with a program that compiles and
runs, but doesn't do the right thing.  Example: an expression may
not be evaluated in the order you expect, yielding an unexpected
result.

\end{itemize}

\index{syntax error}
\index{run-time error}
\index{semantic error}
\index{error!syntax}
\index{error!run-time}
\index{error!semantic}
\index{exception}

The first step in debugging is to figure out which kind of
error you are dealing with.  Although the following sections are
organized by error type, there are some techniques that are
applicable in more than one situation.


\section{Syntax errors}

The best kind of debugging is the kind you don't have to do,
because you avoid making errors in the first place.  In the
previous section, I suggested a program development plan that
minimizes the number of errors you will make and makes it easy
to find them when you do.  The key is to start with a working
program and add small amounts of code at a time.  That way,
when there is an error, you will have a pretty good idea where it
is.

Nevertheless, you might find yourself in one of the following
situations.  For each situation, I make some suggestions about
how to proceed.


\subsection*{The compiler is spewing error messages.}
\index{error messages}
\index{compiler}

If the compiler reports 100 error messages, that doesn't mean
there are 100 errors in your program.  When the compiler encounters
an error, it often gets thrown off track for a while.  It tries to
recover and pick up again after the first error, but sometimes
it fails, and it reports spurious errors.

In general, only the first error message is reliable.  I suggest
that you only fix one error at a time, and then recompile the
program.  You may find that one semi-colon ``fixes'' 100 errors.
Of course, if you see several legitimate error messages, you
might as well fix more than one bug per compilation attempt.


\subsection*{I'm getting a weird compiler message and it
won't go away.}

First of all, read the error message carefully.  It is written
in terse jargon, but often there is a kernel of information
there that is carefully hidden.

If nothing else, the message will tell you where in the program the
problem occurred.  Actually, it tells you where the compiler was
when it noticed a problem, which is not necessarily where the error
is.  Use the information the compiler gives you as a guideline,
but if you don't see an error where the compiler is pointing,
broaden the search.

Generally the error will be prior to the location of the error
message, but there are cases where it will be somewhere else
entirely.  For example, if you get an error message at a method
invocation, the actual error may be in the method definition.

If you are building the program incrementally, you should have
a good idea about where the error is.  It will be in the last
line you added.

If you are copying code from a book, start by comparing 
your code to the book's code very carefully.  Check every character.
At the same time, remember that the book might be wrong, so
if you see something that looks like a syntax error, it might be.

If you don't find the error quickly, take a breath and look more
broadly at the entire program.  Now is a good time to go through the
whole program and make sure it is indented properly.  I won't say that
good indentation makes it easy to find syntax errors, but bad
indentation sure makes it harder.

Now, start examining the code for the common syntax errors.
\index{syntax}

\begin{enumerate}

\item Check that all parentheses and brackets are
balanced and properly nested.  All method definitions should be nested
within a class definition.  All program statements should be within a
method definition.

\item Remember that upper case letters are not the same as
lower case letters.

\item Check for semi-colons at the end of statements(and
no semi-colons after squiggly-braces).

\item Make sure that any strings in the code have matching
quotation marks.  Make sure that you use double-quotes for
Strings and single quotes for characters.

\item For each assignment statement, make sure that the type
on the left is the same as the type on the right.  Make sure
that the expression on the left is a variable name or something
else that you can assign a value to(like an element of an array).

\item For each method invocation, make sure that the arguments
you provide are in the right order, and have right type, and that the
object you are invoking the method on is the right type.

\item If you are invoking a fruitful method, make sure you
are doing something with the result.  If you are invoking a
void method, make sure you are not {\em trying} to do something
with the result.

\item If you are invoking an object method, make sure you are
invoking it on an object with the right type.  If you are invoking
a class method from outside the class where it is defined, make
sure you specify the class name.

\item Inside an object method you can refer to the instance
variables without specifying an object.  If you try that in
a class method, you will get a confusing message like, ``Static
reference to non-static variable.''

\end{enumerate}

If nothing works, move on to the next section...


\subsection*{I can't get my program to compile no matter
what I do.}

If the compiler says there is an error and you don't see it, that
might be because you and the compiler are not looking at the same
code.  Check your development environment to make sure the program
you are editing is the program the compiler is compiling.  If you
are not sure, try putting an obvious and deliberate syntax error
right at the beginning of the program.  Now compile again.  If
the compiler doesn't find the new error, there is probably something
wrong with the way you set up the project.

Otherwise, if you have examined the code thoroughly,
it is time for desperate measures.  You should start over with
a program that you can compile and then gradually add your code
back.

\begin{itemize}

\item Make a copy of the file you are working on.  If you are
working on {\tt Bob.java}, make a copy called {\tt Bob.java.old}.

\item Delete about half the code from {\tt Bob.java}.  Try compiling
again.

\begin{itemize}

\item If the program compiles now, then you know the error is in
the other half.  Bring back about half of the code you deleted and
repeat.

\item If the program still doesn't compile, the error must be in
this half.  Delete about half of the code and repeat.

\end{itemize}

\item Once you have found and fixed the error, start bringing back
the code you deleted, a little bit at a time.

\end{itemize}

This process is called ``debugging by bisection.''  As an
alternative, you can comment out chunks of code instead of
deleting them.  For really sticky syntax problems, though,
I think deleting is more reliable---you don't have to worry
about the syntax of the comments, and by making the program
smaller you make it more readable.

\index{bisection!debugging by}
\index{debugging by bisection}


\subsection*{I did what the compiler told me to do, but it
still doesn't work.}

Some compiler messages come with tidbits of advice, like
``class Golfer must be declared
abstract. It does not define int compareTo(java.lang.Object) from
interface java.lang.Comparable.''  It sounds like the compiler
is telling you to declare Golfer as an abstract class, and if
you are reading this book, you probably don't know what that is
or how to do it.

Fortunately, the compiler is wrong.  The solution in this case
is to make sure {\tt Golfer} has a method called {\tt compareTo}
that takes an {\tt Object} as a parameter.

In general, don't let the compiler lead you by the nose.  Error
messages give you evidence that something is wrong, but they can
be misleading, and their ``advice'' is often wrong.


\section{Run-time errors}

\subsection*{My program hangs.}
\index{infinite loop}
\index{infinite recursion}
\index{hanging}

If a program stops and seems to be doing nothing, we
say it is ``hanging.''  Often that means that it is caught in
an infinite loop or an infinite recursion.

\begin{itemize}

\item If there is a particular loop that you suspect is the
problem, add a print statement immediately before the loop
that says
``entering the loop'' and another immediately after that
says ``exiting the loop.''

Run the program.  If you get the first message and not
the second, you've got an infinite loop.  Go to the section
titled ``Infinite loop.''

\item Most of the time an infinite recursion will cause the program
to run for a while and then produce a StackOverflowException.
If that happens, go to the section
titled ``Infinite recursion.''

If you are not getting a StackOverflowException, but you suspect
there is a problem with a recursive method, you can still use
the techniques in the infinite recursion section.

\item If neither of those things works, start testing other
loops and other recursive methods.

\item If none of these suggestions helps, then it is possible that
you don't understand the flow of execution in your program.
Go to the section titled ``Flow of execution.''

\end{itemize}


\subsubsection*{Infinite loop}

If you think you have an infinite loop and think you know
what loop is causing the problem, add a print statement at
the end of the loop that prints the values of the variables in
the condition, and the value of the condition.

For example,

\begin{verbatim}
    while (x > 0 && y < 0) {
        // do something to x
        // do something to y

        System.out.println("x: " + x);
        System.out.println("y: " + y);
        System.out.println("condition: " +(x > 0 && y < 0));
    }
\end{verbatim}
%
Now when you run the program you will see three lines of output
for each time through the loop.  The last time through the
loop, the condition should be {\tt false}.  If the loop keeps
going, you will be able to see the values of {\tt x} and {\tt y}
and you might figure out why they are not being updated correctly.


\subsubsection*{Infinite recursion}

Most of the time an infinite recursion will cause the program
to run for a while and then produce a StackOverflowException.

If you know that a method is causing an infinite recursion, start by
checking to make sure that there is a base case.  In other words,
there should be some condition that will cause the method to return
without making a recursive invocation.  If not, then you need to
rethink the algorithm and identify a base case.

If there is a base case, but the program doesn't seem to be reaching
it, add a print statement at the beginning of the method that prints
the parameters.  Now when you run the program you will see a few lines
of output every time the method is invoked, and you will see the
parameters.  If the parameters are not moving toward the base case,
you will get some ideas about why not.


\subsubsection*{Flow of execution}
\index{flow of execution}

If you are not sure how the flow of execution is moving through
your program, add print statements to the beginning of each
method with a message like ``entering method foo,'' where
{\tt foo} is the name of the method.

Now when you run the program it will print a trace of each
method as it is invoked.

It is often useful to print the parameters each method receives
when it is invoked.  When you run the program, check whether
the parameters are reasonable, and check for one of the
classic errors---providing parameters in the wrong order.


\subsection*{When I run the program I get an Exception.}
\index{Exception}

If something goes wrong during run time, the Java run-time
system prints a message that includes the name of the
exception, the line of the program where the problem occurred,
and a stack trace.

The stack trace includes the method that is currently running,
and then the method that invoked it, and then the method that
invoked {\em that}, and so on.  In other words, it traces the
stack of method invocations that got you to where you are.

The first step is to examine the place in the program where
the error occurred and see if you can figure out what happened.

\begin{description}

\item[NullPointerException:] You tried to access an instance
variable or invoke a method on an object that is currently
{\tt null}.  You should figure out what variable is {\tt null}
and then figure out how it got to be that way.

Remember that when you declare a variable with an object type,
it is initially {\tt null}, until you assign a value to it.
For example, this code causes a NullPointerException:

\begin{verbatim}
Point blank;
System.out.println(blank.x);
\end{verbatim}

\item[ArrayIndexOutOfBoundsException:] The index you are using
to access an array is either negative or greater than
{\tt array.length-1}.  If you can find the site where the
problem is, add a print statement immediately before it to
print the value of the index and the length of the array.
Is the array the right size?  Is the index the right value?

Now work your way backwards through the program and see where
the array and the index come from.  Find the nearest assignment
statement and see if it is doing the right thing.

If either one is a parameter, go to the place where the method
is invoked and see where the values are coming from.

\item[StackOverFlowException:] See ``Infinite recursion.''

\end{description}


\subsection*{I added so many print statements I get inundated with
output.}
\index{print statement}
\index{statement!print}

One of the problems with using print statements for debugging
is that you can end up buried in output.  There are two ways
to proceed: either simplify the output or simplify the program.

To simplify the output, you can remove or comment out print
statements that aren't helping, or combine them, or format
the output so it is easier to understand.  As you develop a program,
you will conceive ways to visualize the execution of
the program, and develop code that generates concise,
informative visualizations.

To simplify the program, there are several things you can do.  First,
scale down the problem the program is working on.  For example, if you
are sorting an array, sort a {\em small} array.  If the program takes
input from the user, give it the simplest input that causes the
error.

Second, clean up the program.  Remove dead code and reorganize the
program to make it as easy to read as possible.  For example, if you
suspect that the error is in a deeply-nested part of the program,
try rewriting that part with simpler structure.  If you suspect a
large method, try splitting it into smaller methods and testing them
separately.

Often the process of finding the minimal test case leads you to the
bug.  For example, if you find that a program works when the array has
an even number of elements, but not when it has an odd number, that
gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle
bugs.  If you make a change that you think doesn't affect the
program, and it does, that can tip you off.


\section{Semantic errors}

\subsection*{My program doesn't work.}

In some ways semantic errors are the hardest, because the
compiler and the run-time system provide no information about
what is wrong.  Only you know what the program was supposed to
do, and only you know that it isn't doing it.

The first step is to make a connection between the program
text and the behavior you are seeing.  You need a hypothesis
about what the program is actually doing.  One of the things
that makes this hard is that computers run so fast.
You will often wish that you could slow the program down to
human speed, but there is no straightforward way to do that,
and even if there were, it is not really a good way to debug.

Here are some questions to ask yourself:

\begin{itemize}

\item Is there something the program was supposed to do, but
doesn't seem to be happening?  Find the section of the code
that performs that function and make sure it is executing when
you think it should.  Add a print statement to the beginning
of the suspect methods.

\item Is something happening that shouldn't?  Find code in
your program that performs that function and see if it is
executing when it shouldn't.

\item Is a section of code producing an effect that is not
what you expected?  Make sure that you understand the code in
question, especially if it involves invocations to 
Java methods.  Read the documentation for the methods you invoke.
Try out the methods by invoking the methods directly with
simple test cases, and check the results.

\end{itemize}

In order to program, you need to have a mental model of how
programs work.  If your program that doesn't do what you expect,
very often the problem is not in the program; it's in your mental
model.

\index{model!mental}
\index{mental model}

The best way to correct your mental model is to break the program
into its components(usually the classes and methods) and test
each component independently.  Once you find the discrepancy
between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you
develop the program.  If you encounter a problem, there should be only
a small amount of new code that is not known to be correct.

Here are some common semantic errors that you might want to check for:

\begin{itemize}

\item If you use the assignment operator,
{\tt =}, instead of the equality operator, {\tt ==}, in the
condition of an {\tt if}, {\tt while} or {\tt for} statement,
you might get an expression that is syntactically legal, but
it doesn't do what you expect.

\item When you apply the equality operator, {\tt ==}, to an
object, it checks shallow equality.  If you meant to check
deep equality, you should use the {\tt equals} method(or
define one, for user-defined objects).

\item Some Java libraries expect user-defined objects to
define methods like {\tt equals}.  If you don't define them
yourself, you will inherit the default behavior from the parent
class, which may not be what you want.

\item Inheritance can lead to subtle semantic errors,
because you may be executing inherited code without realizing it.
To make sure you understand the flow of execution in your
program, see the section titled ``Flow of Execution.''

\end{itemize}


\subsection*{I've got a big hairy expression and it doesn't
do what I expect.}
\index{expression!big and hairy}

Writing complex expressions is fine as long as they are readable,
but they can be hard to debug.  It is often a good idea to
break a complex expression into a series of assignments to
temporary variables.

For example:

\begin{verbatim}
rect.setLocation(rect.getLocation().translate
                    (-rect.getWidth(), -rect.getHeight()));
\end{verbatim}
%
Can be rewritten as

\begin{verbatim}
int dx = -rect.getWidth();
int dy = -rect.getHeight();
Point location = rect.getLocation();
Point newLocation = location.translate(dx, dy);
rect.setLocation(newLocation);
\end{verbatim}
%
The explicit version is easier to read, because the variable
names provide additional documentation, and easier to debug,
because we can check the types of the intermediate variables
and display their values.

\index{temporary variable}
\index{variable!temporary}
\index{order of evaluation}
\index{precedence}

Another problem that can occur with big expressions is
that the order of evaluation may not be what you expect.
For example, if you are translating the expression
$\frac{x}{2 \pi}$ into Java, you might write

\begin{verbatim}
double y = x / 2 * Math.PI;
\end{verbatim}
%
That is not correct, because multiplication and division have
the same precedence, and are evaluated from left to right.
So this expression computes $x \pi / 2$.

A good way to debug expressions is to add parentheses to make
the order of evaluation explicit.

\begin{verbatim}
double y = x /(2 * Math.PI);
\end{verbatim}
%
Any time you are not sure of the order of evaluation, use
parentheses.  Not only will the program be correct(in the sense
of doing what you intend); it will also be more readable for
other people who haven't memorized the rules of precedence.



\subsection*{I've got a method that doesn't return what I
expect.}
\index{return statement}
\index{statement!return}

If you have a return statement with a complex expression,
you don't have a chance to print the return value before
returning.  Again, you can use a temporary variable.  For
example, instead of

\begin{verbatim}
public Rectangle intersection(Rectangle a, Rectangle b) { 
    return new Rectangle(
        Math.min(a.x, b.x),
        Math.min(a.y, b.y),
        Math.max(a.x+a.width, b.x+b.width)-Math.min(a.x, b.x)
        Math.max(a.y+a.height, b.y+b.height)-Math.min(a.y, b.y) );
}
\end{verbatim}
%
You could write

\begin{verbatim}
public Rectangle intersection(Rectangle a, Rectangle b) { 
    int x1 = Math.min(a.x, b.x);
    int y2 = Math.min(a.y, b.y);
    int x2 = Math.max(a.x+a.width, b.x+b.width);
    int y2 = Math.max(a.y+a.height, b.y+b.height);
    Rectangle rect = new Rectangle(x1, y1, x2-x1, y2-y1);
    return rect;
}
\end{verbatim}
%
Now you have the opportunity to display any of
the intermediate variables before returning.


\subsection*{My print statement isn't doing anything}
\index{print statement}
\index{statement!print}

If you use the {\tt println} method, the output gets displayed
immediately, but if you use {\tt print}(at least in some
environments) the output gets stored without being displayed until the
next newline character gets output.  If the program terminates without
producing a newline, you may never see the stored output.

If you suspect that this is happening to you, try changing
some or all of the {\tt print} statements to {\tt println}.


\subsection*{I'm really, really stuck and I need help}

First of all, try getting away from the computer for a few minutes.
Computers emit waves that affect the brain, causing the following
symptoms:

\begin{itemize}

\item Frustration and/or rage.

\item Superstitious beliefs(``the computer hates me'') and
magical thinking(``the program only works when I wear my
hat backwards'').

\item Random walk programming(the attempt to program by writing
every possible program and choosing the one that does the right
thing).

\end{itemize}

If you find yourself suffering from any of these symptoms, get
up and go for a walk.  When you are calm, think about the program.
What is it doing?  What are some possible causes of that
behavior?  When was the last time you had a working program,
and what did you do next?

Sometimes it just takes time to find a bug.  I often find bugs
when I am away from the computer and I let my mind wander.  Some
of the best places to find bugs are trains, showers, and in bed,
just before you fall asleep.


\subsection*{No, I really need help.}

It happens.  Even the best programmers occasionally get stuck.
Sometimes you work on a program so long that you can't see the
error.  A fresh pair of eyes is just the thing.

Before you bring someone else in, make sure you have exhausted
the techniques described here.  You program should be as simple
as possible, and you should be working on the smallest input
that causes the error.  You should have print statements in the
appropriate places(and the output they produce should be
comprehensible).  You should understand the problem well enough
to describe it concisely.

When you bring someone in to help, be sure to give
them the information they need.

\begin{itemize}

\item What kind of bug is it?  compiler, run-time, or
semantic?

\item If the bug occurs at compile-time or run-time, what is
the error message, and what part of the program does it indicate?

\item What was the last thing you did before this error occurred?
What were the last lines of code that you wrote, or what is
the new test case that fails?

\item What have you tried so far, and what have you learned? 

\end{itemize}

Often you will find that by the time you have explained the problem
to someone else, you will see the answer.  This phenomenon
is so pervasive that some people recommend a debugging technique
called ``rubber ducking.''  Here's how it works:

\begin{enumerate}

\item Buy a standard-issue rubber duck.

\item When you are really stuck on a problem, put the rubber
duck on the desk in front of you and say, ``Rubber duck, I
am stuck on a problem.  Here's what's happening...''

\item Explain the problem to the rubber duck.

\item See the solution.

\item Thank the rubber duck.

\end{enumerate}


\subsection*{I found the bug!}

Most often, when you find a bug, it is obvious how to fix it.  But not
always.  Sometimes what seems to be a bug is really an indication that
you don't really understand the program, or there is an error in your
algorithm.  In these cases, you might have to rethink the algorithm,
or adjust your mental model of the program.  Take some time away from
the computer to think about the program, work through some test cases
by hand, or draw diagrams to represent the computation.

When you fix a bug, don't just dive in and start making new errors.
Take a second to think about what kind of bug it was, why you made
the error in the first place, how the error manifested itself, and
what you could have done to find it faster.  Next time you see something
similar, you will be able to find the bug more quickly.



\beforechapter
\chapter{Input and Output in Java}
\label{javaio}

\section* {System objects}
\label{system}
\index{System object}
\index{object!System}

{\tt System} is the name of the Java class that contains
methods and objects used to get input from the keyboard,
print text on the screen, and do file input/output(I/0).

{\tt System.out} is the name of the object we use to to display text
on the screen.  When you invoke {\tt print} and {\tt println}, you
invoke them on the object named {\tt System.out}.

Interestingly, you can print {\tt System.out}:

\begin{verbatim}
System.out.println(System.out);
\end{verbatim}
%
The output is:

\begin{verbatim}
java.io.PrintStream@80cc0e5
\end{verbatim}
%
As usual, when Java prints an object, it prints the type
of the object, which is {\tt PrintStream}, the package
in which that type is defined, {\tt java.io}, and a
unique identifier for the object.  On my machine the identifier
is {\tt 80cc0e5}, but if you run the same code, you will
probably get something different.

There is also an object named {\tt System.in} that has
type {\tt BufferedInputStream}.  {\tt System.in} makes it
possible to get input from the keyboard.  Unfortunately,
it does not make it easy to get input from the keyboard.


\section* {Keyboard input}
\label{keyboard}
\index{keyboard}
\index{input!keyboard}

First, you have to use {\tt System.in} to create a new
{\tt InputStreamReader}.

\begin{verbatim}
    InputStreamReader in = new InputStreamReader(System.in);
\end{verbatim}
%
Then you use {\tt in} to create a new {\tt BufferedReader}:

\begin{verbatim}
    BufferedReader keyboard = new BufferedReader(in);
\end{verbatim}
%
The point of all this manipulation is that there is a method
you can invoke on a {\tt BufferedReader}, called {\tt readLine},
that gets input from the keyboard and converts it into a
String.  For example:

\begin{verbatim}
    String s = keyboard.readLine();
    System.out.println(s);
\end{verbatim}
%
reads a line from the keyboard and prints the result.

There is only one problem.  There are things that can go wrong
when you invoke {\tt readLine}, and they might cause an
IOException.  There is a rule in Java that if a method might
cause an exception, it should say so.  The syntax looks
like this:

\begin {verbatim}
public static void main(String[] args) throws IOException {
    // body of main
}
\end{verbatim}

This indicates that {\tt main} might ``throw'' an IOException.
You can think of throwing an exception as similar to throwing
a tantrum.


\section* {File input}
\label{fileIO}
\index{file input}
\index{input!file}

Here is an example that reads words from a file.

\begin{verbatim}
    public static void main(String[] args)
        throws FileNotFoundException, IOException {
	
        processFile("/usr/dict/words");
    }

    public static void processFile(String filename)
        throws FileNotFoundException, IOException {

        FileReader fileReader = new FileReader(filename);
        BufferedReader in = new BufferedReader(fileReader);

        while (true) {
            String s = in.readLine();
            if (s == null) break;
            System.out.println(s);
        }
    }
\end{verbatim}

This program reads each line of the named file({\tt /usr/dict/words})
into a {\tt String} and then prints the line.  Again, the declaration {\tt
throws FileNotFoundException, IOException} is required by the
compiler.  The object types {\tt FileReader} and {\tt BufferedReader}
are part of the insanely complicated class hierarchy Java uses to do
incredibly common, simple things.  Other than that, there is not
much value in the details of how this code fragment works.


\beforechapter

\printindex
\beforechapter

\end{document}



